(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],2:[function(require,module,exports){
(function (Buffer){(function (){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

}).call(this)}).call(this,require("buffer").Buffer)

},{"base64-js":1,"buffer":2,"ieee754":3}],3:[function(require,module,exports){
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],4:[function(require,module,exports){
const moduleSwitchDialog=require("../sharedSourceFiles/moduleSwitchDialog")
const modelManagerDialog = require("../sharedSourceFiles/modelManagerDialog")
const projectSelectionDialog = require("./projectSelectionDialog")

function deviceManagementMainToolbar() {
}

deviceManagementMainToolbar.prototype.render = function () {
    this.switchProjectBtn=$('<a class="w3-bar-item w3-button" href="#">Project</a>')
    this.modelIOBtn=$('<a class="w3-bar-item w3-button" href="#">Models</a>')

    $("#MainToolbar").empty()
    $("#MainToolbar").append(moduleSwitchDialog.modulesSidebar)
    $("#MainToolbar").append(moduleSwitchDialog.modulesSwitchButton,this.switchProjectBtn,this.modelIOBtn)

    modelManagerDialog.showRelationVisualizationSettings=false
    this.switchProjectBtn.on("click",()=>{ projectSelectionDialog.popup() })
    this.modelIOBtn.on("click",()=>{ modelManagerDialog.popup() })
}

module.exports = new deviceManagementMainToolbar();
},{"../sharedSourceFiles/modelManagerDialog":18,"../sharedSourceFiles/moduleSwitchDialog":19,"./projectSelectionDialog":7}],5:[function(require,module,exports){
'use strict';
const globalAppSettings = require("../globalAppSettings.js");
const msalHelper=require("../msalHelper")
const deviceManagementMainToolbar = require("./deviceManagementMainToolbar")
const modelEditorDialog = require("../sharedSourceFiles/modelEditorDialog")
const modelIoTSettingDialog= require("./modelIoTSettingDialog")
const twinInfoPanel= require("./twinInfoPanel");
const modelManagerDialog = require("../sharedSourceFiles/modelManagerDialog")
const twinsList=require("./twinsList")
const newTwinDialog=require("../sharedSourceFiles/newTwinDialog");
const projectSelectionDialog=require("./projectSelectionDialog")
const serviceWorkerHelper=require("../sharedSourceFiles/serviceWorkerHelper")
const globalCache = require("../sharedSourceFiles/globalCache")

function deviceManagementUI() {    
    globalCache.checkTooLongIdle()
    deviceManagementMainToolbar.render()

    this.myMSALObj = new msal.PublicClientApplication(globalAppSettings.msalConfig);

    this.broadcastMessage()

    var theAccount=msalHelper.fetchAccount();
    if(theAccount==null && !globalAppSettings.isLocalTest) window.open(globalAppSettings.logoutRedirectUri,"_self")

    this.initData()
}

deviceManagementUI.prototype.initData=async function(){
    try{
        await msalHelper.reloadUserAccountData()
    }catch(e){
        console.log(e)
        if(e.responseText) alert(e.responseText)
        return
    }
    projectSelectionDialog.popup()
}

deviceManagementUI.prototype.broadcastMessage=function(source,msgPayload){
    var componentsArr=[modelManagerDialog,modelEditorDialog,deviceManagementMainToolbar,twinsList,newTwinDialog,modelIoTSettingDialog,twinInfoPanel,projectSelectionDialog,serviceWorkerHelper,globalCache]

    if(source==null){
        for(var i=0;i<componentsArr.length;i++){
            var theComponent=componentsArr[i]
            this.assignBroadcastMessage(theComponent)
        }
    }else{
        for(var i=0;i<componentsArr.length;i++){
            var theComponent=componentsArr[i]
            if(theComponent.rxMessage && theComponent!=source) theComponent.rxMessage(msgPayload)
        }
    }
}
deviceManagementUI.prototype.assignBroadcastMessage=function(uiComponent){
    uiComponent.broadcastMessage=(msgObj)=>{this.broadcastMessage(uiComponent,msgObj)}
}


module.exports = new deviceManagementUI();
},{"../globalAppSettings.js":11,"../msalHelper":12,"../sharedSourceFiles/globalCache":15,"../sharedSourceFiles/modelEditorDialog":17,"../sharedSourceFiles/modelManagerDialog":18,"../sharedSourceFiles/newTwinDialog":20,"../sharedSourceFiles/serviceWorkerHelper":21,"./deviceManagementMainToolbar":4,"./modelIoTSettingDialog":6,"./projectSelectionDialog":7,"./twinInfoPanel":9,"./twinsList":10}],6:[function(require,module,exports){
const modelAnalyzer=require("../sharedSourceFiles/modelAnalyzer")
const simpleSelectMenu= require("../sharedSourceFiles/simpleSelectMenu")
const msalHelper=require("../msalHelper")
const globalCache=require("../sharedSourceFiles/globalCache")
const simpleConfirmDialog = require("../sharedSourceFiles/simpleConfirmDialog")

function modelIoTSettingDialog() {
    if(!this.DOM){
        this.DOM = $('<div style="position:absolute;top:50%;background-color:white;left:50%;transform: translateX(-50%) translateY(-50%);z-index:99" class="w3-card-2"></div>')
        $("body").append(this.DOM)
        this.DOM.hide()
        globalCache.makeDOMDraggable(this.DOM)
    }
}

modelIoTSettingDialog.prototype.popup = async function(modelID) {
    this.DOM.show()
    this.DOM.empty()
    this.contentDOM = $('<div style="width:620px"></div>')
    this.DOM.append(this.contentDOM)
    this.contentDOM.append($('<div style="height:40px" class="w3-bar w3-red"><div class="w3-bar-item" style="font-size:1.5em">IoT Settings</div></div>'))
    var closeButton = $('<button class="w3-bar-item w3-button w3-right" style="font-size:2em;padding-top:4px"></button>')
    this.contentDOM.children(':first').append(closeButton)
    closeButton.on("click", () => { this.DOM.hide() })

    var okButton = $('<button class="w3-button w3-card w3-green w3-hover-light-green" style="height:100%">Accept</button>')
    this.contentDOM.children(':first').append(okButton)
    okButton.on("click", async () => { 
        this.checkModelIoTSettingChange()    
    })

    var firstRow=$('<div class="w3-cell-row" style="padding-bottom:10px"></div>')
    this.contentDOM.append(firstRow)
    var topLeftDom=$('<div class="w3-container w3-cell" style=""></div>')
    var topRightDom=$('<div class="w3-container w3-cell" style="width:320px;padding-left:0px;padding-right:0px" />')
    firstRow.append(topLeftDom,topRightDom)

    this.sampleTelemetryDiv=$('<div class="w3-border" style="margin:5px;height:100px;position:relative;overflow:auto" />')
    this.sampleTelemetryDiv.append($('<div style="padding:2px;right:0px;position:absolute;font-size:9px" class="w3-dark-gray">Telemetry Format Sample</div>'))
    topRightDom.append(this.sampleTelemetryDiv)
    this.sampleTelemetryDiv.hide()
    
    var modelInfo=modelAnalyzer.DTDLModels[modelID]
    this.modelID=modelID
    var DBModelInfo=globalCache.getSingleDBModelByID(modelID)
    this.DBModelInfo=DBModelInfo
    if(DBModelInfo && DBModelInfo.isIoTDeviceModel){
        this.iotInfo=this.DBModelInfo
    }else{
        this.iotInfo=null
    }
    this.originalDesiredPropertiesStr=JSON.stringify(DBModelInfo.desiredProperties)

    topLeftDom.append($("<div style='padding-top:10px'/>").append(
        $("<div class='w3-padding' style='display:inline;font-weight:bold;color:black'>Model</div>")
        , $('<label type="text" style="margin:8px 0;padding:2px;display:inline"/>').text(modelID)))
    topLeftDom.append($("<div class='w3-padding-16'/>").append(
        $("<div class='w3-padding' style='display:inline;font-weight:bold;color:black'>Name</div>")
        , $('<label type="text" style="margin:8px 0;padding:2px;display:inline"/>').text(modelInfo["displayName"])))

    var isIoTCheck = $('<input class="w3-check" style="width:20px;margin-left:16px;margin-right:10px" type="checkbox">')
    var isIoTText = $('<label class="w3-dark-gray" style="padding:2px 8px;font-size:1.2em;border-radius: 3px;"> This is NOT a IoT Model</label>')
    this.isIoTCheck = isIoTCheck
    topLeftDom.append(isIoTCheck, isIoTText)


    var dialogDOM = $('<div />')
    this.contentDOM.append(dialogDOM)

    var editableProperties=modelInfo.editableProperties
    if($.isEmptyObject(editableProperties)){
        var titleTable=$('<div>Warning: There is no propertie in this model to map with a IoT device</div>')
    }else{
        var titleTable=$('<table style="width:100%" cellspacing="0px" cellpadding="0px"></table>')
        titleTable.append($('<tr><td style="font-weight:bold; width:220px">IoT Setting</td><td style="font-weight:bold">Parameter Tree</td></tr>'))
        titleTable.hide() 
    }

    dialogDOM.append($("<div class='w3-container'/>").append(titleTable))

    var IoTSettingDiv=$("<div class='w3-container w3-border' style='width:100%;max-height:300px;overflow:auto'></div>")
    this.IoTSettingDiv=IoTSettingDiv
    IoTSettingDiv.hide()
    dialogDOM.append(IoTSettingDiv)
    this.iotSettingsArr=[]
    this.drawIoTSettings()

    isIoTCheck.on("change",(e)=>{
        if(isIoTCheck.prop('checked')) {
            var theHeight= IoTSettingDiv.height()
            isIoTText.removeClass("w3-dark-gray").addClass("w3-lime")
            isIoTText.text("This is a IoT Model")

            if(!this.iotInfo) this.iotInfo=this.DBModelInfo
            if(e.isTrigger){ // it is from programmaticaltrigger
                IoTSettingDiv.css("height",theHeight+10+"px")
                titleTable.show()
                IoTSettingDiv.show()    
                this.sampleTelemetryDiv.show()
            }else{
                IoTSettingDiv.css("height","0px")
                titleTable.show()
                IoTSettingDiv.show()
                IoTSettingDiv.animate({"height":theHeight+10+"px"})
                this.sampleTelemetryDiv.fadeIn()
            }
        }else {
            this.iotInfo=null;
            isIoTText.removeClass("w3-lime").addClass("w3-dark-gray")
            isIoTText.text("This is NOT a IoT Model")
            if(e.isTrigger){ // it is from programmaticaltrigger
                IoTSettingDiv.css("height","");
                IoTSettingDiv.hide();
                titleTable.hide()
                this.sampleTelemetryDiv.hide()    
            }else{
                IoTSettingDiv.animate({"height":"0px"},()=>{IoTSettingDiv.css("height","");IoTSettingDiv.hide();titleTable.hide()})
                this.sampleTelemetryDiv.fadeOut()    
            }
        }
    })

    if(this.iotInfo){
        isIoTCheck.prop( "checked", true );
        isIoTCheck.trigger("change")    
    }

    
}

modelIoTSettingDialog.prototype.checkModelIoTSettingChange= function(){
    //if it is to remove the iot setting and there are twins under this model that have been provisioned
    //give a warning dialog to confirm the change
    if(this.iotInfo) {
        this.commitChange()
        return;
    }

    var affectTwins= globalCache.getDBTwinsByModelID(this.modelID)

    var provisionedTwins=[]
    for(var i=0;i<affectTwins.length;i++){
        var oneTwin=affectTwins[i]
        if(oneTwin.IoTDeviceID!=null && oneTwin.IoTDeviceID!=""){
            provisionedTwins.push(globalCache.twinIDMapToDisplayName[oneTwin.id])
        }
    }

    if(provisionedTwins.length==0){
        this.commitChange()
        return;
    }

    var dialogStr="Turning off model IoT setting will deactive "
    if(provisionedTwins.length>10) dialogStr+= provisionedTwins.length +" IoT devices of this model type"
    else dialogStr+="IoT devices: "+provisionedTwins.join()
    dialogStr+=". Are you sure?"

    var confirmDialogDiv=new simpleConfirmDialog()

    confirmDialogDiv.show(
        { width: "250px" },
        {
            title: "Warning"
            , content: dialogStr
            , buttons:[
                {
                    colorClass: "w3-red w3-hover-pink", text: "Confirm", "clickFunc": () => {
                        confirmDialogDiv.close()
                        this.commitChange()
                    }
                },
                {
                    colorClass: "w3-gray",text: "Cancel", "clickFunc": () => {
                        confirmDialogDiv.close()
                }}
            ]
        }
    )

}

modelIoTSettingDialog.prototype.commitChange = async function() {
    //ask taskmaster to update model 
    //in case of iot setting enabled, provision all twins to iot hub
    //otherwise, deprovision all twins
    var postBody= {"modelID":this.modelID}
    postBody.updateInfo={}
    if(this.iotInfo){
        postBody.updateInfo.isIoTDeviceModel=true
        postBody.updateInfo.telemetryProperties=[]
        postBody.updateInfo.desiredProperties=[]
        postBody.desiredInDeviceTwin={}
        postBody.updateInfo.reportProperties=[]
        this.iotSettingsArr.forEach(ele=>{
            if(ele.type=="telemetry") postBody.updateInfo.telemetryProperties.push(ele)
            else if(ele.type=="desired"){
                postBody.updateInfo.desiredProperties.push(ele)
                var propertyName=ele.path[ele.path.length-1]
                postBody.desiredInDeviceTwin[propertyName]=""
            }else if(ele.type=="report") postBody.updateInfo.reportProperties.push(ele)
        })
    }else{
        postBody.updateInfo.isIoTDeviceModel=false
    }

    if(this.iotInfo){
        var curDesiredPropertyStr=JSON.stringify(postBody.updateInfo.desiredProperties)
        if(curDesiredPropertyStr!=this.originalDesiredPropertiesStr) {
            postBody.forceRefreshDeviceDesired=true
        }
    }

    postBody.updateInfo = JSON.stringify(postBody.updateInfo)
    try {
        var response = await msalHelper.callAPI("devicemanagement/changeModelIoTSettings", "POST", postBody,"withProjectID")
        globalCache.storeSingleDBModel(response.updatedModelDoc)
        globalCache.mergeDBTwinsArr(response.DBTwins)
    } catch (e) {
        console.log(e)
        if (e.responseText) alert(e.responseText)
    }

    this.broadcastMessage({ "message": "ModelIoTSettingEdited","modelID":response.updatedModelDoc.id })
    this.DOM.hide()
}

modelIoTSettingDialog.prototype.drawIoTSettings = async function() {
    var modelDetail= modelAnalyzer.DTDLModels[this.modelID]
    var copyModelEditableProperty=JSON.parse(JSON.stringify(modelDetail.editableProperties))
    var iotTable=$('<table style="width:100%" cellspacing="0px" cellpadding="0px"></table>')
    this.IoTSettingDiv.append(iotTable)

    var initialPathArr=[]
    this.allSelectMenu=[]
    var lastRootNodeRecord=[]
    this.drawEditable(iotTable,copyModelEditableProperty,initialPathArr,lastRootNodeRecord)

    this.IoTSettingDiv.on("click",()=>{this.shrinkAllSelectMenu()})
    this.IoTSettingDiv.on("scroll",()=>{this.shrinkAllSelectMenu()})
}

modelIoTSettingDialog.prototype.shrinkAllSelectMenu = async function() {
    this.allSelectMenu.forEach(selectmenu=>{
        selectmenu.shrink()
    })
}

modelIoTSettingDialog.prototype.drawEditable = async function(parentTable,jsonInfo,pathArr,lastRootNodeRecord) {
    if(jsonInfo==null) return;
    var arr=[]
    for(var ind in jsonInfo) arr.push(ind)

    for(var theIndex=0;theIndex<arr.length;theIndex++){
        if(theIndex==arr.length-1) lastRootNodeRecord[pathArr.length] =true;
        
        var ind = arr[theIndex]
        var tr=$("<tr/>")
        var leftTD=$("<td style='width:220px'/>")
        var rightTD=$("<td style='height:30px'/>")
        tr.append(leftTD,rightTD)
        parentTable.append(tr)
        
        
        for(var i=0;i<pathArr.length;i++){
            if(!lastRootNodeRecord[i]) rightTD.append(this.treeLineDiv(2))
            else rightTD.append(this.treeLineDiv(4))
        }

        if(theIndex==arr.length-1) rightTD.append(this.treeLineDiv(3))
        else rightTD.append(this.treeLineDiv(1))

        var pNameDiv=$("<label style='display:inline;line-height:28px;margin-left:3px'>"+ind+"</label>")
        rightTD.append(pNameDiv)
        var newPath=pathArr.concat([ind])

        if(Array.isArray(jsonInfo[ind])){ //it is a enumerator
            var typeDOM=$("<label class='w3-dark-gray' style='font-size:9px;padding:2px;margin-left:5px'>enum</label>")
            rightTD.append(typeDOM)
            var valueArr=[]
            jsonInfo[ind].forEach(ele=>{valueArr.push(ele.enumValue)})
            var label1=$("<label class='w3-dark-gray' style='font-size:9px;padding:2px;margin-left:2px'>"+valueArr.join()+"</label>")
            rightTD.append(label1)

            var IoTsettingObj={"type":"","path":newPath,"ptype":"enumerator"}
            this.iotSettingsArr.push(IoTsettingObj)
            IoTsettingObj.type=this.checkPropertyPathIoTType(newPath)
            this.drawIoTSelectDropdown(leftTD,IoTsettingObj,pNameDiv)
        }else if(typeof(jsonInfo[ind])==="object") {
            this.drawEditable(parentTable,jsonInfo[ind],newPath,lastRootNodeRecord)
        }else {
            var IoTsettingObj={"type":"","path":newPath,"ptype":jsonInfo[ind]}
            this.iotSettingsArr.push(IoTsettingObj)
            IoTsettingObj.type=this.checkPropertyPathIoTType(newPath)
            this.drawIoTSelectDropdown(leftTD,IoTsettingObj,pNameDiv)
            var typeDOM=$("<label class='w3-dark-gray' style='font-size:9px;padding:2px;margin-left:5px'>"+jsonInfo[ind]+"</label>")
            rightTD.append(typeDOM)
        } 
    }
}

modelIoTSettingDialog.prototype.checkPropertyPathIoTType=function(pathArr){
    if(!this.iotInfo) return ""
    var desiredProperties=this.iotInfo["desiredProperties"]
    var reportProperties=this.iotInfo["reportProperties"]
    var telemetryProperties=this.iotInfo["telemetryProperties"]
    var checkPathStr=JSON.stringify(pathArr)
    var tmpFunc=(arr,reStr)=>{
        for(var i=0;i<arr.length;i++){
            var elePath=JSON.stringify(arr[i].path)
            if(elePath==checkPathStr) return reStr
        }
        return ""
    }
    var re=tmpFunc(desiredProperties,"desired")
    if(re=="") re=tmpFunc(reportProperties,"report")
    if(re=="") re=tmpFunc(telemetryProperties,"telemetry")
    return re;
}

modelIoTSettingDialog.prototype.drawIoTSelectDropdown=function(td,IoTsettingObj,pNameDiv){
    var aSelectMenu = new simpleSelectMenu(""
        , {
            width: "210px","isClickable": true, "withBorder": true
            , buttonCSS: { "padding": "4px 16px" }
            ,"optionListMarginTop":50,"optionListMarginLeft":210
            ,"adjustPositionAnchor":this.DOM.offset()
        }
    )
    aSelectMenu.callBack_beforeClickExpand=()=>{
        this.shrinkAllSelectMenu()
    }
    this.allSelectMenu.push(aSelectMenu)
    td.append(aSelectMenu.rowDOM)
    aSelectMenu.addOption("NOT IoT Device parameter","NONE")
    aSelectMenu.addOption("IoT Device Telemetry","telemetry","w3-lime")
    aSelectMenu.addOption("IoT Device Desired Property","desired","w3-amber")
    aSelectMenu.addOption("IoT Device Report Property","report","w3-blue")

    aSelectMenu.callBack_clickOption=(optionText,optionValue,realMouseClick,colorClass)=>{
        aSelectMenu.changeName(optionText)
        if(colorClass){
            aSelectMenu.button.attr('class', 'w3-button w3-border '+colorClass);
            pNameDiv.attr('class', colorClass);
        } else{
            aSelectMenu.button.attr('class', 'w3-button w3-border')   
            pNameDiv.attr('class', '');
        }
        if(realMouseClick) {
            IoTsettingObj["type"]=optionValue
        }
        this.refreshIoTTelemetrySample()
    }
    if(IoTsettingObj.type!="") aSelectMenu.triggerOptionValue(IoTsettingObj.type)
    else aSelectMenu.triggerOptionIndex(0)
}



modelIoTSettingDialog.prototype.propertyTypeSampleValue = function(ptype){
    //["Enum","Object","boolean","date","dateTime","double","duration","float","integer","long","string","time"]
    var mapping={
        "enumerator":"stringValue"
        ,"string":"stringValue"
        ,"boolean":true
        ,"dateTime":new Date().toISOString()
        ,"date": (new Date().toISOString()).split("T")[0]
        ,"double":0.1
        ,"float":0.1
        ,"duration":"PT16H30M"
        ,"integer":0
        ,"long":0
        ,"time": "T"+((new Date().toISOString()).split("T")[1])
    }
    if(mapping[ptype]!=null) return mapping[ptype]
    else return "unknown"
}

modelIoTSettingDialog.prototype.refreshIoTTelemetrySample = function(){
    var sampleObj={}
    this.iotSettingsArr.forEach(onep=>{
        if(onep.type!="telemetry") return;
        var pathArr=onep.path
        var ptype=onep.ptype
        
        var theRoot=sampleObj
        for(var i=0;i<pathArr.length;i++){
            var str=pathArr[i]
            if(i==pathArr.length-1) {
                var valueSample=this.propertyTypeSampleValue(ptype)
                theRoot[str]=valueSample
            }else{
                if(!theRoot[str])theRoot[str]={}
                theRoot=theRoot[str]
            }
        }
    })

    var label=this.sampleTelemetryDiv.find(':first-child');
    var script= $('<pre style="color:gray;margin:0px">'+JSON.stringify(sampleObj,null,2)+'</pre>')
    this.sampleTelemetryDiv.empty().append(label,script)
}

modelIoTSettingDialog.prototype.treeLineDiv = function(typeNumber) {
    var reDiv=$('<div style="margin-left:10px;width:15px;height: 100%;float: left"></div>')
    if(typeNumber==1){
        reDiv.append($('<div class="w3-border-bottom w3-border-left" style="width:100%;height:50%;"></div><div class="w3-border-left" style="width:100%;height:50%;"></div>'))
    }else if(typeNumber==2){
        reDiv.append($('<div class="w3-border-left" style="width:100%;height:50%;"></div><div class="w3-border-left" style="width:100%;height:50%;"></div>'))
    }else if(typeNumber==3){
        reDiv.append($('<div class="w3-border-bottom w3-border-left" style="width:100%;height:50%;">'))
    }else if(typeNumber==4){
        
    }
    return reDiv
}

module.exports = new modelIoTSettingDialog();
},{"../msalHelper":12,"../sharedSourceFiles/globalCache":15,"../sharedSourceFiles/modelAnalyzer":16,"../sharedSourceFiles/simpleConfirmDialog":23,"../sharedSourceFiles/simpleSelectMenu":25}],7:[function(require,module,exports){
const globalCache = require("../sharedSourceFiles/globalCache")
const simpleSelectMenu=require("../sharedSourceFiles/simpleSelectMenu")
const msalHelper=require("../msalHelper")
const editProjectDialog=require("../sharedSourceFiles/editProjectDialog")
const modelManagerDialog = require("../sharedSourceFiles/modelManagerDialog")
const modelAnalyzer = require("../sharedSourceFiles/modelAnalyzer")

function projectSelectionDialog() {
    if(!this.DOM){
        this.DOM = $('<div style="position:absolute;top:50%;background-color:white;left:50%;transform: translateX(-50%) translateY(-50%);z-index:99" class="w3-card-2"></div>')
        $("body").append(this.DOM)
        this.DOM.hide()
        globalCache.makeDOMDraggable(this.DOM)
    }
}

projectSelectionDialog.prototype.popup = async function() {
    this.DOM.show()
    this.DOM.empty()
    this.contentDOM = $('<div style="width:450px"></div>')
    this.DOM.append(this.contentDOM)
    this.contentDOM.append($('<div style="height:40px" class="w3-bar w3-red"><div class="w3-bar-item" style="font-size:1.5em">Select Project</div></div>'))
    var closeButton = $('<button class="w3-bar-item w3-button w3-right" style="font-size:2em;padding-top:4px"></button>')
    this.contentDOM.children(':first').append(closeButton)

    this.buttonHolder = $("<div style='height:100%'></div>")
    this.contentDOM.children(':first').append(this.buttonHolder)
    closeButton.on("click", () => {
        this.useProject()
    })

    var row1=$('<div class="w3-bar" style="padding:2px"></div>')
    this.contentDOM.append(row1)
    var lable=$('<div class="w3-bar-item w3-opacity" style="padding-right:5px;">Project </div>')
    row1.append(lable)
    var switchProjectSelector=new simpleSelectMenu(" ",{withBorder:1,colorClass:"w3-light-gray",buttonCSS:{"padding":"5px 10px"}})
    this.switchProjectSelector=switchProjectSelector
    row1.append(switchProjectSelector.DOM)
    var joinedProjects=globalCache.accountInfo.joinedProjects
    joinedProjects.forEach(aProject=>{
        var str = aProject.name
        if(aProject.owner!=globalCache.accountInfo.accountID) str+=" (from "+aProject.owner+")"
        switchProjectSelector.addOption(str,aProject.id)
    })
    switchProjectSelector.callBack_clickOption=(optionText,optionValue)=>{
        switchProjectSelector.changeName(optionText)
        this.chooseProject(optionValue)
    }

    this.editProjectBtn=$('<a class="w3-bar-item w3-button" href="#"><i class="fa fa-edit fa-lg"></i></a>')
    this.deleteProjectBtn=$('<a class="w3-button" href="#"><i class="fa fa-trash fa-lg"></i></a>')
    this.newProjectBtn=$('<a class="w3-button" href="#"><i class="fa fa-plus fa-lg"></i></a>')
    row1.append(this.editProjectBtn,this.deleteProjectBtn,this.newProjectBtn)
    
    if(this.previousSelectedProject!=null){
        switchProjectSelector.triggerOptionValue(this.previousSelectedProject)
    }else{
        switchProjectSelector.triggerOptionIndex(0)
    }
}

projectSelectionDialog.prototype.chooseProject = async function (selectedProjectID) {
    this.buttonHolder.empty()

    var projectInfo=globalCache.findProjectInfo(selectedProjectID)
    if(projectInfo.owner==globalCache.accountInfo.accountID){
        this.editProjectBtn.show()
        this.deleteProjectBtn.show()
        this.editProjectBtn.on("click", () => { editProjectDialog.popup(projectInfo) })
        this.deleteProjectBtn.on("click",async ()=>{
            try {
                await msalHelper.callAPI("accountManagement/deleteProjectTo", "POST", {"projectID":selectedProjectID})
            } catch (e) {
                console.log(e)
                if (e.responseText) alert(e.responseText)
                return
            }
        })
    }else{
        this.editProjectBtn.hide()
        this.deleteProjectBtn.hide()
    }
    this.newProjectBtn.on("click",async ()=>{
        var tsStr=(new Date().toLocaleString()) 
        try {
            var newProjectInfo = await msalHelper.callAPI("accountManagement/newProjectTo", "POST", { "projectName": "New Project " + tsStr })
            globalCache.accountInfo.joinedProjects.unshift(newProjectInfo)
            this.switchProjectSelector.clearOptions()
            var joinedProjects = globalCache.accountInfo.joinedProjects
            joinedProjects.forEach(aProject => {
                var str = aProject.name
                if(aProject.owner!=globalCache.accountInfo.accountID) str+=" (from "+aProject.owner+")"
                this.switchProjectSelector.addOption(str, aProject.id)
            })
            //NOTE: must query the new joined projects JWT token again
            await msalHelper.reloadUserAccountData()
            this.switchProjectSelector.triggerOptionIndex(0)
        } catch (e) {
            console.log(e)
            if (e.responseText) alert(e.responseText)
            return
        }
    })
    
    if(this.previousSelectedProject == selectedProjectID){
        var startButton = $('<button class="w3-button w3-card w3-hover-deep-orange w3-green" style="height:100%; margin-right:8px">Start</button>')
        startButton.on("click", () => { this.closeDialog() })
        this.buttonHolder.append(startButton)
    }else{
        var startButton = $('<button class="w3-button w3-card w3-hover-deep-orange w3-green" style="height:100%; margin-right:8px">Start</button>')
        startButton.on("click", () => { this.useProject() })
        this.buttonHolder.append(startButton)
    }
    globalCache.currentProjectID = selectedProjectID
}

projectSelectionDialog.prototype.closeDialog=function(){
    this.DOM.hide()
}

projectSelectionDialog.prototype.useProject=async function(){
    var bool_broadCastProjectChanged=false
    if(this.previousSelectedProject!=globalCache.currentProjectID){
        globalCache.initStoredInformtion()
        this.previousSelectedProject=globalCache.currentProjectID
        bool_broadCastProjectChanged=true
    }
    var projectInfo=globalCache.findProjectInfo(globalCache.currentProjectID)
    var projectOwner=projectInfo.owner

    try {
        var res = await msalHelper.callAPI("digitaltwin/fetchProjectModelsData", "POST", null, "withProjectID")
        globalCache.storeProjectModelsData(res.DBModels, res.adtModels)
        modelAnalyzer.clearAllModels();
        modelAnalyzer.addModels(res.adtModels)
        modelAnalyzer.analyze();

        var res = await msalHelper.callAPI("digitaltwin/fetchProjectTwinsAndVisualData", "POST", {"projectOwner":projectOwner}, "withProjectID")
        globalCache.storeProjectTwinsAndVisualData(res)
    } catch (e) {
        console.log(e)
        if (e.responseText) alert(e.responseText)
        return
    }

    if(globalCache.DBModelsArr.length==0){
        //directly popup to model management dialog allow user import or create model
        modelManagerDialog.popup()
        modelManagerDialog.DOM.hide()
        modelManagerDialog.DOM.fadeIn()
        //pop up welcome screen
        var popWin=$('<div class="w3-blue w3-card-4 w3-padding-large" style="position:absolute;top:50%;background-color:white;left:50%;transform: translateX(-50%) translateY(-50%);z-index:105;width:400px;cursor:default"></div>')
        popWin.html(`Welcome, ${msalHelper.userName}! Firstly, let's import or create a few twin models to start. <br/><br/>Click to continue...`)
        $("body").append(popWin)
        popWin.on("click",()=>{popWin.remove()})
        setTimeout(()=>{
            popWin.fadeOut("slow",()=>{popWin.remove()});
        },3000)
    }

    if(bool_broadCastProjectChanged){
        this.broadcastMessage({ "message": "projectIsChanged","projectID":globalCache.currentProjectID})
    }

    this.closeDialog()
}


module.exports = new projectSelectionDialog();
},{"../msalHelper":12,"../sharedSourceFiles/editProjectDialog":14,"../sharedSourceFiles/globalCache":15,"../sharedSourceFiles/modelAnalyzer":16,"../sharedSourceFiles/modelManagerDialog":18,"../sharedSourceFiles/simpleSelectMenu":25}],8:[function(require,module,exports){
const globalCache = require("../sharedSourceFiles/globalCache");
const newTwinDialog=require("../sharedSourceFiles/newTwinDialog");
const modelIoTSettingDialog = require("./modelIoTSettingDialog")
const simpleExpandableSection = require("../sharedSourceFiles/simpleExpandableSection")

function singleModelTwinsList(singleADTModel,parentTwinsList) {
    this.parentTwinsList=parentTwinsList
    this.info=singleADTModel
    this.childTwins=[]
    this.name=singleADTModel.displayName;
    this.createDOM()
}

singleModelTwinsList.prototype.removeMemoryReference=function(){
    for(var ind in this) this[ind]=null
}

singleModelTwinsList.prototype.createDOM=function(){
    var oneSection= new simpleExpandableSection("Properties Section",this.parentTwinsList.DOM,{"marginTop":"1px"})
    this.oneSection=oneSection
    this.listDOM=oneSection.listDOM

    //fill in the twins under this model
    var twins=[]
    for(var twinID in globalCache.DBTwins){
        var aTwin=globalCache.DBTwins[twinID]
        if(aTwin.modelID==this.info["@id"]) twins.push(aTwin)
    }
    twins.sort(function (a, b) { 
        var aName=a.displayName.toLowerCase()
        var bName=b.displayName.toLowerCase()
        return aName.localeCompare(bName) 
    });
    twins.forEach(aTwin=>{
        this.childTwins.push(new singleTwinIcon(aTwin,this))
    })

    this.refreshName()
}

singleModelTwinsList.prototype.addTwin=function(DBTwinInfo){
    this.childTwins.push(new singleTwinIcon(DBTwinInfo,this))
    this.refreshName()
}


singleModelTwinsList.prototype.refreshName=function(){
    this.oneSection.headerTextDOM.empty()
    var nameDiv=$("<div class='w3-text-dark-gray' style='display:inline;padding-right:3px;vertical-align:middle;font-weight:bold;color:darkgray'></div>")
    nameDiv.text(this.name)

    var modelID=this.info["@id"]
    var singleDBModel= globalCache.getSingleDBModelByID(modelID)

    var countTwins=0
    var countIoTDevices=0
    this.childTwins.forEach(aTwin=>{
        countTwins++
        if(aTwin.twinInfo["IoTDeviceID"]!=null) countIoTDevices++
    })
    var numberlabel=$("<label style='display:inline;font-size:9px;padding:2px 4px;font-weight:normal;border-radius: 2px;'>"+countTwins+" twins</label>")
    if(countTwins==0) numberlabel.addClass("w3-gray")
    else numberlabel.addClass("w3-orange")

    var numberlabel2=$("<label class='w3-lime' style='display:inline;font-size:9px;padding:2px 4px;font-weight:normal;border-radius: 2px;'>"+countIoTDevices+" IoT Devices</label>")
    
    var addButton= $('<button class="w3-ripple w3-bar-item w3-button w3-red w3-hover-pink w3-right" style="margin-top:2px;font-size:1.2em;padding:4px 8px">+</button>')
    addButton.on("click",(e)=>{
        this.oneSection.expand()
        newTwinDialog.popup({
            "$metadata": {
                "$model": this.info["@id"]
            }
        })
        return false
    })

    var iotSetButton=$('<button class="w3-ripple w3-bar-item w3-button w3-red w3-hover-pink w3-right" style="margin-top:2px;margin-left:10px;font-size:1.2em;padding:4px 8px"><i class="fa fa-cog fa-lg"></i> IoT Setting</button>')
    iotSetButton.on("click",(e)=>{
        this.oneSection.expand()
        modelIoTSettingDialog.popup(this.info["@id"])
        return false
    })


    this.oneSection.headerTextDOM.append(nameDiv,numberlabel)
    if(singleDBModel && singleDBModel.isIoTDeviceModel) this.oneSection.headerTextDOM.append(numberlabel2)
    this.oneSection.headerTextDOM.append(iotSetButton,addButton)
}

singleModelTwinsList.prototype.refreshTwinsIcon=function(){
    this.childTwins.forEach(aTwin=>{aTwin.redrawIcon()})
}

singleModelTwinsList.prototype.refreshTwinsIoTStatus=function(){
    this.childTwins.forEach(aTwin=>{aTwin.redrawIoTState()})
}

singleModelTwinsList.prototype.refreshTwinsInfo=function(){
    this.childTwins.forEach(aTwin=>{aTwin.refreshTwinInfo()})
}

singleModelTwinsList.prototype.getSingleTwinIcon=function(twinID){
    for(var i=0;i<this.childTwins.length;i++){
        var oneTwinIcon=this.childTwins[i]
        if(oneTwinIcon.twinInfo.id==twinID) return oneTwinIcon
    }
    return null;
}



//--------------------------------------------------------------------------------------

function singleTwinIcon(singleDBTwin,parentModelTwinsList) {
    this.twinInfo=singleDBTwin
    this.parentModelTwinsList=parentModelTwinsList
    this.DOM=$("<div class='w3-hover-gray'  style='width:80px;float:left;height:100px;margin:8px;cursor:default;text-align:center'/>")

    this.IoTLable=$('<span class="w3-text-amber fa-stack fa-xs" style="opacity: 100;"><i class="fas fa-signal fa-stack-2x"></i><i class="fas fa-slash fa-stack-2x"></i></span>')

    this.iconDOM=$("<div style='width:30px;height:30px;margin:0 auto;margin-top:10px;position:relative'></div>")
    this.nameDOM=$("<div style='word-break: break-word;width:100%;text-align:center;margin-top:5px'>"+this.twinInfo.displayName+"</div>")
    this.redrawIcon()
    this.redrawIoTState()
    parentModelTwinsList.listDOM.append(this.DOM)
    this.DOM.append(this.IoTLable, this.iconDOM,this.nameDOM)


    var clickF=(e)=>{
        this.highlight();
        var clickDetail=e.detail
        if (e.ctrlKey) {
            this.parentModelTwinsList.parentTwinsList.appendTwinIconToSelection(this)
            this.parentModelTwinsList.parentTwinsList.lastClickedTwinIcon=this;
        }else if(e.shiftKey){
            if(this.parentModelTwinsList.parentTwinsList.lastClickedTwinIcon==null){
                this.clickSelf()
            }else{
                var allTwinIconArr=this.parentModelTwinsList.parentTwinsList.getAllTwinIconArr()
                var index1 = allTwinIconArr.indexOf(this.parentModelTwinsList.parentTwinsList.lastClickedTwinIcon)
                var index2 = allTwinIconArr.indexOf(this)
                if(index1==-1 || index2==-1){
                    this.clickSelf()
                }else{
                    //select all twinicons between
                    var lowerI= Math.min(index1,index2)
                    var higherI= Math.max(index1,index2)
                    
                    var middleArr=allTwinIconArr.slice(lowerI,higherI)                  
                    middleArr.push(allTwinIconArr[higherI])
                    this.parentModelTwinsList.parentTwinsList.addTwinIconArrayToSelection(middleArr)
                }
            }
        }else{
            this.clickSelf(clickDetail)
        }
    }
    this.DOM.on("click",(e)=>{clickF(e)})
}

singleTwinIcon.prototype.clickSelf=function(mouseClickDetail){
    this.parentModelTwinsList.parentTwinsList.lastClickedTwinIcon=this;
    this.parentModelTwinsList.parentTwinsList.selectTwinIcon(this,mouseClickDetail)
}

singleTwinIcon.prototype.refreshTwinInfo=function(){
    var twinID=this.twinInfo.id
    this.twinInfo=globalCache.DBTwins[twinID]
}

singleTwinIcon.prototype.redrawIoTState=function(){
    this.IoTLable.css("opacity",0)
    if(this.twinInfo.IoTDeviceID!=null) {
        this.IoTLable.css("opacity",100) //use opacity to control so it holds its visual space even when it is no visible
        if(this.twinInfo.connectState) {
            this.IoTLable.removeClass("w3-text-red")
            this.IoTLable.addClass("w3-text-lime")
            this.IoTLable.html('<i class="fas fa-signal fa-stack-2x"></i>')
        }else{
            this.IoTLable.addClass("w3-text-red")
            this.IoTLable.removeClass("w3-text-lime")
            this.IoTLable.html('<i class="fas fa-signal fa-stack-2x"></i><i class="fas fa-slash fa-stack-2x"></i>')
        }
    }

}

singleTwinIcon.prototype.redrawIcon=function(){
    this.iconDOM.empty()
    var modelID= this.twinInfo.modelID;

    var visualJson=globalCache.visualDefinition["default"].detail
    var fillColor="darkGray"
    if(visualJson[modelID] && visualJson[modelID].color) fillColor=visualJson[modelID].color
    if(visualJson[modelID]) var secondColor=visualJson[modelID].secondColor
    var dimension=30;
    if(visualJson[modelID] && visualJson[modelID].dimensionRatio){
        dimension*=parseFloat(visualJson[modelID].dimensionRatio)
        this.iconDOM.css({"width":dimension+"px","height":dimension+"px"})
    } 
    var shape="ellipse"
    if(visualJson[modelID] && visualJson[modelID].shape) shape=visualJson[modelID].shape
    var avarta=null
    if(visualJson[modelID] && visualJson[modelID].avarta) avarta=visualJson[modelID].avarta

    var imgSrc=encodeURIComponent(globalCache.shapeSvg(shape,fillColor,secondColor))

    this.iconDOM.append($("<img src='data:image/svg+xml;utf8,"+imgSrc+"'></img>"))
    if(avarta){
        var avartaimg=$(`<img style='max-width:${dimension*0.75}px;max-height:${dimension*0.75}px;position:absolute;left:50%;top:50%;transform:translateX(-50%) translateY(-50%)' src='${avarta}'></img>`)
        this.iconDOM.append(avartaimg)
    }
}

singleTwinIcon.prototype.highlight=function(){
    this.DOM.addClass("w3-hover-orange")
    this.DOM.addClass("w3-amber")
    this.DOM.removeClass("w3-hover-gray")
}
singleTwinIcon.prototype.dim=function(){
    this.DOM.removeClass("w3-hover-orange")
    this.DOM.removeClass("w3-amber")
    this.DOM.addClass("w3-hover-gray")
}


module.exports = singleModelTwinsList;
},{"../sharedSourceFiles/globalCache":15,"../sharedSourceFiles/newTwinDialog":20,"../sharedSourceFiles/simpleExpandableSection":24,"./modelIoTSettingDialog":6}],9:[function(require,module,exports){
const globalCache = require("../sharedSourceFiles/globalCache")
const msalHelper = require("../msalHelper")
const baseInfoPanel = require("../sharedSourceFiles/baseInfoPanel")
const simpleExpandableSection= require("../sharedSourceFiles/simpleExpandableSection")

class twinInfoPanel extends baseInfoPanel{
    constructor() {
        super()
        this.openFunctionButtonSection=true
        this.openPropertiesSection=true
        this.DOM = $("#InfoContent")
        this.drawButtons(null)
        this.selectedObjects = null;
    }

    async rxMessage(msgPayload) {
        var tt=this.abc+1
        
        if (msgPayload.message == "showInfoSelectedDevices") {
            this.DOM.empty()
            var arr = msgPayload.info;

            if (arr == null || arr.length == 0) {
                this.drawButtons(null)
                this.selectedObjects = [];
                return;
            }
            this.selectedObjects = arr;
            if (arr.length == 1) {
                this.drawButtons("singleNode")
                var singleDBTwinInfo = arr[0];
                var modelID = singleDBTwinInfo.modelID

                if (!globalCache.storedTwins[singleDBTwinInfo.id]) {
                    //query all twins of this parent model if they havenot been queried from ADT yet
                    var twinIDs = []
                    for(var twinID in globalCache.DBTwins){
                        var ele=globalCache.DBTwins[twinID]
                        if (ele.modelID == modelID) twinIDs.push(ele.id)
                    }
                    var twinsData = await msalHelper.callAPI("digitaltwin/listTwinsForIDs", "POST", twinIDs)
                    globalCache.storeADTTwins(twinsData)
                }

                var singleADTTwinInfo = globalCache.storedTwins[singleDBTwinInfo.id] 
                var propertiesSection= new simpleExpandableSection("Properties Section",this.DOM)
                propertiesSection.callBack_change=(status)=>{this.openPropertiesSection=status}
                if(this.openPropertiesSection) propertiesSection.expand()
                this.drawSingleNodeProperties(singleDBTwinInfo,singleADTTwinInfo,propertiesSection.listDOM)
            } else if (arr.length > 1) {
                this.drawButtons("multiple")
                var textDiv = $("<label style='display:block;margin-top:10px;margin-left:16px'></label>")
                textDiv.text(arr.length + " node" + ((arr.length <= 1) ? "" : "s"))
                this.DOM.append(textDiv)
            }
        }
    }

    drawButtons(selectType){
        if(selectType==null){
            this.DOM.html("<div style='padding:8px'><a style='display:block;font-style:italic;color:gray'>Define IoT setting in model so its twin type can be mapped to physical IoT device type</a><a style='display:block;font-style:italic;color:gray;padding-top:20px;padding-bottom:20px'>Press ctrl or shift key to select multiple twins</a></div>")
            return;
        }

        var buttonSection= new simpleExpandableSection("Function Buttons Section",this.DOM,{"marginTop":0})
        buttonSection.callBack_change=(status)=>{this.openFunctionButtonSection=status}
        if(this.openFunctionButtonSection) buttonSection.expand()

        var delBtn =  $('<button style="width:45%" class="w3-ripple w3-button w3-red w3-hover-pink w3-border">Delete All</button>')
        buttonSection.listDOM.append(delBtn)
        //delBtn.on("click",()=>{this.deleteSelected()})
        var latestTelemetryBtn=$('<button style="width:45%"  class="w3-ripple w3-button w3-border">Telemetry</button>')
        buttonSection.listDOM.append(latestTelemetryBtn)
    
        var allAreIOT=true
        for(var i=0;i<this.selectedObjects.length;i++){
            var modelID=this.selectedObjects[i].modelID
            var theDBModel=globalCache.getSingleDBModelByID(modelID)
            if(!theDBModel.isIoTDeviceModel){
                allAreIOT=false
                break;
            }
        }
    
        if(allAreIOT){
            var provisionBtn =$('<button style="width:45%"  class="w3-ripple w3-button w3-border">IoT Provision</button>')
            var deprovisionBtn =$('<button style="width:45%"  class="w3-ripple w3-button w3-border">IoT Deprovision</button>')
            buttonSection.listDOM.append(provisionBtn,deprovisionBtn)
            
            if(selectType=="singleNode"){
                var sampleCodeBtn =$('<button style="width:90%"  class="w3-ripple w3-button w3-border">Sample Code</button>')
                buttonSection.listDOM.append(sampleCodeBtn) 
            }
        }
    
        if(selectType=="singleNode"){
            var refreshBtn =$('<button style="width:45%"  class="w3-ripple w3-button w3-border">Refresh</button>')
            var inputSimulationBtn =$('<button style="width:45%"  class="w3-ripple w3-button w3-border">Input Simulation</button>')
            buttonSection.listDOM.append(refreshBtn,inputSimulationBtn)
        }
        
    }
}


module.exports = new twinInfoPanel();
},{"../msalHelper":12,"../sharedSourceFiles/baseInfoPanel":13,"../sharedSourceFiles/globalCache":15,"../sharedSourceFiles/simpleExpandableSection":24}],10:[function(require,module,exports){
const globalCache = require("../sharedSourceFiles/globalCache");
const modelAnalyzer = require("../sharedSourceFiles/modelAnalyzer")
const singleModelTwinsList=require("./singleModelTwinsList")


function twinsList() {
    this.DOM=$("#TwinsList")
    this.singleModelTwinsListArr=[]
    this.selectedTwinIcons=[];

    this.callback_afterSelectTwinIcons=(twinIcons,mouseClickDetail)=>{
        var infoArr=[]
        twinIcons.forEach((item, index) =>{
            infoArr.push(item.twinInfo)
        });
        this.broadcastMessage({ "message": "showInfoSelectedDevices", info:infoArr, "mouseClickDetail":mouseClickDetail})
    }
}

twinsList.prototype.findSingleModelTwinsListByModelID=function(modelID){
    for(var i=0;i<this.singleModelTwinsListArr.length;i++){
        var aModelTwinsList=this.singleModelTwinsListArr[i]
        if(aModelTwinsList.info["@id"]==modelID) return aModelTwinsList
    }
    return null;
}

twinsList.prototype.refill=function(){
    this.DOM.empty()
    this.singleModelTwinsListArr.forEach(ele=>{ele.removeMemoryReference()})

    this.singleModelTwinsListArr.length=0

    for(var ind in modelAnalyzer.DTDLModels){
        this.singleModelTwinsListArr.push(new singleModelTwinsList(modelAnalyzer.DTDLModels[ind],this,this.DOM))
    }

}

twinsList.prototype.rxMessage=function(msgPayload){
    if(msgPayload.message=="projectIsChanged"){
        this.refill()
    }else if(msgPayload.message=="visualDefinitionChange"){
        if(msgPayload.modelID)  var theSingleModelTwinsList=this.findSingleModelTwinsListByModelID(msgPayload.modelID)
        theSingleModelTwinsList.refreshTwinsIcon()
    }else if(msgPayload.message=="ModelIoTSettingEdited"){
        if(msgPayload.modelID)  var theSingleModelTwinsList=this.findSingleModelTwinsListByModelID(msgPayload.modelID)
        theSingleModelTwinsList.refreshTwinsInfo()
        theSingleModelTwinsList.refreshName()
        theSingleModelTwinsList.refreshTwinsIoTStatus()
    }else if(msgPayload.message=="addNewTwin"){
        var theSingleModelTwinsList=this.findSingleModelTwinsListByModelID(msgPayload.DBTwinInfo.modelID)
        theSingleModelTwinsList.addTwin(msgPayload.DBTwinInfo) 
    }else if(msgPayload.message=="liveData"){
        var msgBody=msgPayload.body
        if(msgBody.connectionState && msgBody.projectID==globalCache.currentProjectID){
            var twinID=msgBody.twinID
            var twinDBInfo=globalCache.DBTwins[twinID]
            var theSingleModelTwinsList=this.findSingleModelTwinsListByModelID(twinDBInfo.modelID)
            var theTwinIcon=theSingleModelTwinsList.getSingleTwinIcon(twinID)
            if(theTwinIcon) theTwinIcon.redrawIoTState()
        }
    }
}

twinsList.prototype.appendTwinIconToSelection=function(aTwinIcon){
    var newArr=[].concat(this.selectedTwinIcons)
    newArr.push(aTwinIcon)
    this.selectTwinIconArr(newArr)
}

twinsList.prototype.addTwinIconArrayToSelection=function(arr){
    var newArr = this.selectedTwinIcons
    var filterArr=arr.filter((item) => newArr.indexOf(item) < 0)
    newArr = newArr.concat(filterArr)
    this.selectTwinIconArr(newArr)
}

twinsList.prototype.selectTwinIcon=function(aTwinIcon,mouseClickDetail){
    this.selectTwinIconArr([aTwinIcon],mouseClickDetail)
}

twinsList.prototype.selectTwinIconArr=function(twiniconArr,mouseClickDetail){
    for(var i=0;i<this.selectedTwinIcons.length;i++){
        this.selectedTwinIcons[i].dim()
    }
    this.selectedTwinIcons.length=0;
    this.selectedTwinIcons=this.selectedTwinIcons.concat(twiniconArr)
    for(var i=0;i<this.selectedTwinIcons.length;i++){
        this.selectedTwinIcons[i].highlight()
    }

    if(this.callback_afterSelectTwinIcons) this.callback_afterSelectTwinIcons(this.selectedTwinIcons,mouseClickDetail)
}

twinsList.prototype.getAllTwinIconArr=function(){
    var allTwinIcons=[]
    this.singleModelTwinsListArr.forEach(aModelTwinsList=>{
        allTwinIcons=allTwinIcons.concat(aModelTwinsList.childTwins)
    })
    return allTwinIcons;
}


module.exports = new twinsList();
},{"../sharedSourceFiles/globalCache":15,"../sharedSourceFiles/modelAnalyzer":16,"./singleModelTwinsList":8}],11:[function(require,module,exports){
const signupsigninname="B2C_1_singupsignin_spaapp1"
const b2cTenantName="azureiotb2c"

const url = new URL(window.location.href);

var strArr=window.location.href.split("?")
var isLocalTest=(strArr.indexOf("test=1")!=-1)

const globalAppSettings={
    "b2cSignUpSignInName": signupsigninname,
    "b2cScope_taskmaster":"https://"+b2cTenantName+".onmicrosoft.com/taskmastermodule/operation",
    "b2cScope_functions":"https://"+b2cTenantName+".onmicrosoft.com/azureiotrocksfunctions/basic",
    "logoutRedirectUri": url.origin+"/spaindex.html",
    "msalConfig":{
        auth: {
            clientId: "f4693be5-601b-4d0e-9208-c35d9ad62387",
            authority: "https://"+b2cTenantName+".b2clogin.com/"+b2cTenantName+".onmicrosoft.com/"+signupsigninname,
            knownAuthorities: [b2cTenantName+".b2clogin.com"],
            redirectUri: window.location.href
        },
        cache: {
            cacheLocation: "sessionStorage", 
            storeAuthStateInCookie: false
        },
        system: {
            loggerOptions: {
                loggerCallback: (level, message, containsPii) => {}
            }
        }
    },
    "isLocalTest":isLocalTest,
    "taskMasterAPIURI":((isLocalTest)?"http://localhost:5002/":"https://azureiotrockstaskmastermodule.azurewebsites.net/"),
    "functionsAPIURI":"https://azureiotrocksfunctions.azurewebsites.net/api/"
}

module.exports = globalAppSettings;
},{}],12:[function(require,module,exports){
(function (Buffer){(function (){
const globalAppSettings=require("./globalAppSettings")
const globalCache=require("./sharedSourceFiles/globalCache")


function msalHelper(){
    this.myMSALObj = new msal.PublicClientApplication(globalAppSettings.msalConfig);
}

msalHelper.prototype.signIn=async function(){
    try{
        var response= await this.myMSALObj.loginPopup({ scopes:[]  }) //globalAppSettings.b2cScopes
        if (response != null){
            this.setAccount(response.account)
            return response.account
        } 
        else  return this.fetchAccount()
    }catch(e){
        if(e.errorCode!="user_cancelled") console.log(e)
    }
}

msalHelper.prototype.setAccount=function(theAccount){
    if(theAccount==null)return;
    this.accountId = theAccount.homeAccountId;
    this.accountName = theAccount.username;
    this.userName=theAccount.name;
}

msalHelper.prototype.fetchAccount=function(){
    const currentAccounts = this.myMSALObj.getAllAccounts();
    if (currentAccounts.length < 1) return;
    var foundAccount=null;
    for(var i=0;i<currentAccounts.length;i++){
        var anAccount= currentAccounts[i]
        if(anAccount.homeAccountId.toUpperCase().includes(globalAppSettings.b2cSignUpSignInName.toUpperCase())
            && anAccount.idTokenClaims.iss.toUpperCase().includes(globalAppSettings.msalConfig.auth.knownAuthorities[0].toUpperCase())
            && anAccount.idTokenClaims.aud === globalAppSettings.msalConfig.auth.clientId
        ){
            foundAccount= anAccount;
        }
    }
    this.setAccount(foundAccount)
    return foundAccount;
}


msalHelper.prototype.callAzureFunctionsService=async function(APIString,RESTMethod,payload){
    var headersObj={}
    var token=await this.getToken(globalAppSettings.b2cScope_functions)
    headersObj["Authorization"]=`Bearer ${token}`
    return new Promise((resolve, reject) => {
        var ajaxContent={
            type: RESTMethod || 'GET',
            "headers":headersObj,
            url: globalAppSettings.functionsAPIURI+APIString,
            contentType: "application/json; charset=utf-8",
            crossDomain: true,
            success: function (responseData, textStatus, jqXHR) {
                resolve(responseData)
            },
            error: function (responseData, textStatus, errorThrown) {
                reject(responseData)
            }
        }
        if(RESTMethod=="POST") ajaxContent.data= JSON.stringify(payload)
        $.ajax(ajaxContent);
    })
}

msalHelper.prototype.parseJWT=function(token){
    var base64Url = token.split('.')[1];
    var base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
    base64= Buffer.from(base64, 'base64').toString();
    var jsonPayload = decodeURIComponent(base64.split('').map(function(c) {
        return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
    }).join(''));

    return JSON.parse(jsonPayload);
}

msalHelper.prototype.reloadUserAccountData=async function(){
    try{
        var res=await this.callAPI("accountManagement/fetchUserData")
    }catch(e){
        console.log(e)
        if(e.responseText) alert(e.responseText)
        return

    }
    globalCache.storeUserData(res)
}

msalHelper.prototype.callAPI=async function(APIString,RESTMethod,payload,withProjectID){
    var headersObj={}
    if(withProjectID){
        payload=payload||{}
        payload["projectID"]=globalCache.currentProjectID
    } 
    if(!globalAppSettings.isLocalTest){
        try{
            var token=await this.getToken(globalAppSettings.b2cScope_taskmaster)
        }catch(e){
            window.open(globalAppSettings.logoutRedirectUri,"_self")
        }
        
        headersObj["Authorization"]=`Bearer ${token}`

        //in case joined projects JWT is going to expire, renew another one
        if(globalCache.joinedProjectsToken) {
            var expTS=this.parseJWT(globalCache.joinedProjectsToken).exp
            var currTime=parseInt(new Date().getTime()/1000)
            if(expTS-currTime<60){ //fetch a new projects JWT token 
                await this.reloadUserAccountData()
            }
        }

        //if the API need to use project ID, must add a header "projects" jwt token so server side will verify
        if(payload && payload.projectID && globalCache.joinedProjectsToken){
            headersObj["projects"]=globalCache.joinedProjectsToken
        }

    }
    return new Promise((resolve, reject) => {
        var ajaxContent={
            type: RESTMethod || 'GET',
            "headers":headersObj,
            url: globalAppSettings.taskMasterAPIURI+APIString,
            contentType: "application/json; charset=utf-8",
            crossDomain: true,
            success: function (responseData, textStatus, jqXHR) {
                resolve(responseData)
            },
            error: function (responseData, textStatus, errorThrown) {
                reject(responseData)
            }
        }
        if(RESTMethod=="POST") ajaxContent.data= JSON.stringify(payload)
        $.ajax(ajaxContent);
    })
}

msalHelper.prototype.getToken=async function(b2cScope){
    try{
        if(this.storedToken==null) this.storedToken={}
        if(this.storedToken[b2cScope]!=null){
            var currTime=parseInt(new Date().getTime()/1000)
            if(currTime+60 < this.storedToken[b2cScope].expire) return this.storedToken[b2cScope].accessToken
        }
        var tokenRequest={
            scopes: [b2cScope],
            forceRefresh: false, // Set this to "true" to skip a cached token and go to the server to get a new token
            account: this.myMSALObj.getAccountByHomeId(this.accountId)
        }
    
        console.log("try to silently get token")
        var response = await this.myMSALObj.acquireTokenSilent(tokenRequest)
        console.log("get token successfully")
        if (!response.accessToken || response.accessToken === "") {
            throw new msal.InteractionRequiredAuthError();
        }
        this.storedToken[b2cScope]={"accessToken":response.accessToken,"expire":response.idTokenClaims.exp}
    }catch(error){
        if (error instanceof msal.InteractionRequiredAuthError) {
            // fallback to interaction when silent call fails
            var response=await this.myMSALObj.acquireTokenPopup(tokenRequest)
        } else {
            throw error;
        }
    }

    return response.accessToken;
}

module.exports = new msalHelper();
}).call(this)}).call(this,require("buffer").Buffer)

},{"./globalAppSettings":11,"./sharedSourceFiles/globalCache":15,"buffer":2}],13:[function(require,module,exports){
const simpleSelectMenu= require("./simpleSelectMenu")
const globalCache = require("../sharedSourceFiles/globalCache")
const modelAnalyzer = require("../sharedSourceFiles/modelAnalyzer");
const msalHelper = require("../msalHelper")
const simpleChart=require("./simpleChart")

class baseInfoPanel {
    drawEditable(parent,jsonInfo,originElementInfo,pathArr,funcGetKeyLblColorClass){
        if(jsonInfo==null) return;
        for(var ind in jsonInfo){
            var keyDiv= $("<label style='display:block'><div style='display:inline;padding:.1em .3em .1em .3em; margin-right:5px'>"+ind+"</div></label>")
            parent.append(keyDiv)
            
            keyDiv.css("padding-top",".3em") 
    
            var contentDOM=$("<label style='padding-top:.2em'></label>")
            var newPath=pathArr.concat([ind])
            var keyLabelColorClass="w3-dark-gray"
            if(funcGetKeyLblColorClass) keyLabelColorClass=funcGetKeyLblColorClass(newPath)
            if(Array.isArray(jsonInfo[ind])){
                keyDiv.children(":first").addClass(keyLabelColorClass)
                if (this.readOnly) {
                    var val = globalCache.searchValue(originElementInfo, newPath)
                    if (val == null) {
                        contentDOM.css({ "color": "gray", "font-size": "9px" })
                        contentDOM.text("[empty]")
                    } else contentDOM.text(val)
                }else{
                    this.drawDropdownOption(contentDOM,newPath,jsonInfo[ind],originElementInfo)
                }
            }else if(typeof(jsonInfo[ind])==="object") {
                keyDiv.children(":first").css("font-weight","bold")
                contentDOM.css("display","block")
                contentDOM.css("padding-left","1em")
                this.drawEditable(contentDOM,jsonInfo[ind],originElementInfo,newPath,funcGetKeyLblColorClass)
            }else {
                keyDiv.children(":first").addClass(keyLabelColorClass)
                var val = globalCache.searchValue(originElementInfo, newPath)
                if (this.readOnly) {
                    if (val == null) {
                        contentDOM.css({ "color": "gray", "font-size": "9px" })
                        contentDOM.text("[empty]")
                    } else contentDOM.text(val)
                } else {
                    var aInput = $('<input type="text" style="padding:2px;width:50%;outline:none;display:inline" placeholder="type: ' + jsonInfo[ind] + '"/>').addClass("w3-input w3-border");
                    contentDOM.append(aInput)
                    if (val != null) aInput.val(val)
                    aInput.data("path", newPath)
                    aInput.data("dataType", jsonInfo[ind])
                    aInput.change((e) => {
                        this.editDTProperty(originElementInfo, $(e.target).data("path"), $(e.target).val(), $(e.target).data("dataType"))
                    })
                }
            }
            keyDiv.append(contentDOM)
        }
    }

    drawDropdownOption(contentDOM,newPath,valueArr,originElementInfo){
        var aSelectMenu=new simpleSelectMenu("",{buttonCSS:{"padding":"4px 16px"}})
        contentDOM.append(aSelectMenu.DOM)
        aSelectMenu.DOM.data("path", newPath)
        valueArr.forEach((oneOption)=>{
            var str =oneOption["displayName"]  || oneOption["enumValue"] 
            aSelectMenu.addOption(str)
        })
        aSelectMenu.callBack_clickOption=(optionText,optionValue,realMouseClick)=>{
            aSelectMenu.changeName(optionText)
            if(realMouseClick) this.editDTProperty(originElementInfo,aSelectMenu.DOM.data("path"),optionValue,"string")
        }
        var val=globalCache.searchValue(originElementInfo,newPath)
        if(val!=null){
            aSelectMenu.triggerOptionValue(val)
        }    
    }

    generateSmallKeyDiv(str,paddingTop){
        var keyDiv = $("<label style='display:block'><div class='w3-border' style='background-color:#f6f6f6;display:inline;padding:.1em .3em .1em .3em;margin-right:.3em;font-size:10px'>"+str+"</div></label>")
        keyDiv.css("padding-top",paddingTop)
        return keyDiv
    }

    drawConnectionStatus(status,parentDom) {
        parentDom=parentDom||this.DOM
        var keyDiv=this.generateSmallKeyDiv("Connection",".5em")
        parentDom.append(keyDiv)
        var contentDOM = $('<span class="fa-stack" style="font-size:.5em;padding-left:5px"></span>')
        if(status) {
            contentDOM.addClass("w3-text-lime")
            contentDOM.html('<i class="fas fa-signal fa-stack-2x"></i>')
        }else{
            contentDOM.addClass("w3-text-red")
            contentDOM.html('<i class="fas fa-signal fa-stack-2x"></i><i class="fas fa-slash fa-stack-2x"></i>')
        }
        keyDiv.append(contentDOM)
    }

    drawStaticInfo(parent,jsonInfo,paddingTop,fontSize,fontColor){
        fontColor=fontColor||"black"
        for(var ind in jsonInfo){
            var keyDiv=this.generateSmallKeyDiv(ind,paddingTop)
            parent.append(keyDiv)
    
            var contentDOM=$("<label></label>")
            contentDOM.css({"fontSize":fontSize,"color":fontColor})
            if(jsonInfo[ind]==null){
                contentDOM.css({ "color": "gray", "font-size": "9px" })
                contentDOM.text("[empty]")
            }else if(typeof(jsonInfo[ind])==="object") {
                contentDOM.css("display","block")
                contentDOM.css("padding-left","1em")
                this.drawStaticInfo(contentDOM,jsonInfo[ind],".5em",fontSize)
            }else {
                contentDOM.css("padding-top",".2em")
                contentDOM.text(jsonInfo[ind])
            }
            
            keyDiv.append(contentDOM)
        }
    }

    fetchRealElementInfo(singleElementInfo){ //the input is possibly from topology view which might not be precise about property value
        var returnElementInfo={}
        if(singleElementInfo==null) return;
        if (singleElementInfo["$dtId"]) {
            returnElementInfo=globalCache.storedTwins[singleElementInfo["$dtId"]] //note that dynamical property value is not stored in topology node, so always get refresh data from globalcache
        }else if (singleElementInfo["$sourceId"]) {
            var arr=globalCache.storedOutboundRelationships[singleElementInfo["$sourceId"]]
            for(var i=0;i<arr.length;i++){
                if(arr[i]['$relationshipId']==singleElementInfo["$relationshipId"]){
                    returnElementInfo=arr[i]
                    break;
                }
            }
        }else if(singleElementInfo["simNodeName"]){
            var attachTwinID=singleElementInfo["twinID"]
            var dbtwin=globalCache.DBTwins[attachTwinID]
            var simNodeName=singleElementInfo["simNodeName"]
            singleElementInfo.detail=dbtwin.simulate[simNodeName]
            returnElementInfo=singleElementInfo
        }
        return returnElementInfo
    }

    drawSingleRelationProperties(singleRelationInfo,parentDom) {
        parentDom=parentDom||this.DOM
        this.drawStaticInfo(parentDom, {
            "sourceI":globalCache.twinIDMapToDisplayName[singleRelationInfo["$sourceId"]],
            "target": globalCache.twinIDMapToDisplayName[singleRelationInfo["$targetId"]],
            "$relationshipName": singleRelationInfo["$relationshipName"]
        }, "1em", "13px")
        this.drawStaticInfo(parentDom, {
            "$relationshipId": singleRelationInfo["$relationshipId"]
        }, "1em", "10px")
        var relationshipName = singleRelationInfo["$relationshipName"]
        var sourceModel = singleRelationInfo["sourceModel"]

        this.drawEditable(parentDom, this.getRelationShipEditableProperties(relationshipName, sourceModel), singleRelationInfo, [])
        for (var ind in singleRelationInfo["$metadata"]) {
            var tmpObj = {}
            tmpObj[ind] = singleRelationInfo["$metadata"][ind]
            this.drawStaticInfo(parentDom, tmpObj, "1em", "10px")
        }
        //this.drawStaticInfo(parentDom,{"$etag":singleRelationInfo["$etag"]},"1em","10px","DarkGray")
    }

    getRelationShipEditableProperties(relationshipName, sourceModel) {
        if (!modelAnalyzer.DTDLModels[sourceModel] || !modelAnalyzer.DTDLModels[sourceModel].validRelationships[relationshipName]) return
        return modelAnalyzer.DTDLModels[sourceModel].validRelationships[relationshipName].editableRelationshipProperties
    }


    drawSimDatasourceInfo(simNodeInfo,parentDom){
        parentDom=parentDom||this.DOM
        var dbTwin=globalCache.DBTwins[simNodeInfo.twinID]
        var twinName=globalCache.twinIDMapToDisplayName[simNodeInfo.twinID]
        if(!this.readOnly) {
            var containerDiv=$("<div class='w3-container'/>")
            parentDom.append(containerDiv)
            parentDom=containerDiv 
        }
        this.drawStaticInfo(parentDom, { "name": twinName }, ".5em", "13px")
        this.drawStaticInfo(parentDom, { "Model": dbTwin.modelID }, ".5em", "13px")
        if (this.readOnly) {//in float info panel
            this.drawStaticInfo(parentDom, { "Simulate Property": simNodeInfo.propertyPath }, ".5em", "13px")
            this.drawStaticInfo(parentDom, { "Cycle Length": simNodeInfo.cycleLength }, ".5em", "13px")
            this.drawStaticInfo(parentDom, { "Sampling": simNodeInfo.sampleInterval }, ".5em", "13px")
            this.drawStaticInfo(parentDom, { "Formula": simNodeInfo.formula }, ".5em", "13px")
        }else{ // in right side info panel
            this.drawSimDatasourceInfo_propertyPath(parentDom,simNodeInfo,dbTwin)
            //draw cycleLength,sampleInterval and formula
            var demoChart=this.drawSimDatasourceInfo_chart(simNodeInfo,parentDom)
            this.drawSimDatasourceInfo_input("Cycle Length(_T)","cycleLength","Cycle time length in seconds",parentDom,simNodeInfo,dbTwin,demoChart)
            this.drawSimDatasourceInfo_input("Sampling","sampleInterval","Sampling time in seconds",parentDom,simNodeInfo,dbTwin,demoChart) 
            this.drawSimDatasourceInfo_formula(parentDom,simNodeInfo,dbTwin,demoChart)
            parentDom.append(demoChart.canvas) //move chart to the end
            this.drawSimDatasourceInfo_refreshChart(simNodeInfo,demoChart)
        }
    }

    drawSimDatasourceInfo_refreshChart(simNodeInfo,theChart){
        var _T=parseFloat(simNodeInfo.detail["cycleLength"])
        var sampling=parseFloat(simNodeInfo.detail["sampleInterval"])
        var formula=simNodeInfo.detail["formula"]
        var numOfPoints=parseInt(2*_T/sampling)+1
        theChart.setXLength(numOfPoints)

        if(_T==0 || sampling==0 || formula=="" || _T==null || sampling==null || formula==null || _T<0 || sampling<0) return;

        var _t=0;
        var dataArr=[]
        var _output=null;
        for(var i=0;i<numOfPoints;i++){
            var evalStr=formula+"\n_output"
            try{
                _output=eval(evalStr) // jshint ignore:line
            }catch(e){
                return e
            }
            dataArr.push(_output)
            _t+=sampling
            if(_t>=_T)_t=_t-_T
        }
        theChart.setDataArr(dataArr)
    }

    drawSimDatasourceInfo_chart(simNodeInfo,parentDom){
        var cycleL= simNodeInfo.detail["cycleLength"]
        var sampling=simNodeInfo.detail["sampleInterval"]
        var numOfPoints=100
        var demoChart=new simpleChart(parentDom,numOfPoints,{width:"100%","height":"130px"}) 
        return demoChart
    }
    drawSimDatasourceInfo_formula(parentDom,simNodeInfo,dbTwin,demoChart){
        var scriptLbl=this.generateSmallKeyDiv("Calculation Script","2px")
        scriptLbl.css("margin-top","10px")

        var lbl2=$('<lbl style="font-size:10px;color:gray">(Build in variables:_t _T _output)</lbl>')
        scriptLbl.append(lbl2)

        var placeHolderStr='Sample&#160;Script&#58;&#10;&#10;SIN&#160;Wave&#10;_output=Math.sin(_t/_T*2*3.14)&#10;&#10;Value&#160;List&#10;var&#160;valueList=[2,3.5,-1,10.3,9.1]&#10;var&#160;index=(_t/_T*valueList.length).toFixed(0)&#10;_output=valueList[index]&#10;&#10;Square&#160;Wave&#10;_output=1-_output' 
        var scriptTextArea=$('<textarea class="w3-border" spellcheck="false" style="outline:none;font-size:11px;height:140px;width:100%;font-family:Verdana" placeholder='+placeHolderStr+'></textarea>')
        parentDom.append(scriptLbl,scriptTextArea)
        scriptTextArea.on("keydown", (e) => {
            if (e.keyCode == 9){
                this.insertToTextArea('\t',scriptTextArea)
                return false;
            }
        })
        scriptTextArea.highlightWithinTextarea({highlight: [
            { "highlight": "_t", "className": "Purple"},
            { "highlight": "_T", "className": "Cyan"},
            { "highlight": "_output", "className": "Amber"},
        ]});
        var confirmBtn=$('<button class="w3-button w3-amber w3-ripple" style="padding:2px 10px;display:block">Commit Script</button>')
        parentDom.append(confirmBtn)
        var originalV=simNodeInfo.detail["formula"]
        if (originalV != null) {
            scriptTextArea.val(originalV)
            scriptTextArea.highlightWithinTextarea('update');
        }
        confirmBtn.on("click",()=>{
            simNodeInfo.detail["formula"] = scriptTextArea.val()
            try {
                var error=this.drawSimDatasourceInfo_refreshChart(simNodeInfo,demoChart)
                if(error){
                    alert(error)
                    return;
                }
                msalHelper.callAPI("digitaltwin/updateTwin", "POST"
                    , { "twinID": simNodeInfo.twinID, "updateInfo": JSON.stringify({ "simulate": dbTwin.simulate }) }
                    , "withProjectID")
            } catch (e) {
                console.log(e)
                if (e.responseText) alert(e.responseText)
            }
        })
    }

    drawSimDatasourceInfo_input(lblText, keyStr,placeHolderStr, parentDom, simNodeInfo, dbTwin,demoChart) {
        var keyDiv = $("<div style='display:block;margin-top:.5em'><div style='display:inline;padding:.1em .3em .1em .3em; margin-right:5px'>"+lblText+"</div></div>")
        parentDom.append(keyDiv)
        var contentDOM = $("<label style='padding-top:.2em'></label>")
        keyDiv.append(contentDOM)
        var aInput = $('<input type="text" style="padding:2px;width:40%;outline:none;display:inline" placeholder="' + placeHolderStr + '"/>').addClass("w3-input w3-border");
        contentDOM.append(aInput)
        contentDOM.append($('<label>sec</label>')) 
        var originalV=simNodeInfo.detail[keyStr] 
        if (originalV != null) aInput.val(originalV)
        aInput.change((e) => {
            simNodeInfo.detail[keyStr] = $(e.target).val()
            try {
                this.drawSimDatasourceInfo_refreshChart(simNodeInfo,demoChart)
                msalHelper.callAPI("digitaltwin/updateTwin", "POST"
                    , { "twinID": simNodeInfo.twinID, "updateInfo": JSON.stringify({ "simulate": dbTwin.simulate }) }
                    , "withProjectID")
            } catch (e) {
                console.log(e)
                if (e.responseText) alert(e.responseText)
            }
        })
    }


    drawSimDatasourceInfo_propertyPath(parentDom,simNodeInfo,dbTwin){
        var keyDiv= $("<label style='display:block;padding-top:.3em'><div style='display:inline;padding:.1em .3em .1em .3em; margin-right:5px'>Simulate Property</div></label>")
        parentDom.append(keyDiv)    
        var contentDOM=$("<label style='padding-top:.2em'></label>")
        keyDiv.append(contentDOM)
        var aSelectMenu = new simpleSelectMenu("", { buttonCSS: { "padding": "4px 16px" } })
        contentDOM.append(aSelectMenu.DOM)
        var propertiesArr=modelAnalyzer.fetchPropertyPathsOfModel(dbTwin.modelID)
        propertiesArr.forEach((oneProperty) => {
            aSelectMenu.addOption(oneProperty.join("."),oneProperty)
        })
        var originalPath=simNodeInfo.detail.propertyPath
        aSelectMenu.callBack_clickOption = (optionText, optionValue, realMouseClick) => {
            aSelectMenu.changeName(optionText)
            if(!realMouseClick) return;
            if(originalPath==null || originalPath.join()!=optionValue.join){
                simNodeInfo.detail.propertyPath=optionValue
                try {
                    msalHelper.callAPI("digitaltwin/updateTwin", "POST"
                        , {"twinID":simNodeInfo.twinID,"updateInfo":JSON.stringify({"simulate":dbTwin.simulate})}
                        , "withProjectID")
                } catch (e) {
                    console.log(e)
                    if (e.responseText) alert(e.responseText)
                }
            }
        }
        if (originalPath != null) aSelectMenu.triggerOptionText(originalPath.join("."))
    }


    drawSingleNodeProperties(singleDBTwinInfo,singleADTTwinInfo,parentDom,notEmbedMetadata) {
        //instead of draw the $dtId, draw display name instead
        //this.drawStaticInfo(this.DOM,{"$dtId":singleElementInfo["$dtId"]},"1em","13px")
        parentDom=parentDom||this.DOM
        const constDesiredColor="w3-amber"
        const constReportColor="w3-blue"
        const constTelemetryColor="w3-lime"
        const constCommonColor="w3-dark-gray"

        var modelID = singleDBTwinInfo.modelID
        this.drawStaticInfo(parentDom, { "name": singleDBTwinInfo["displayName"] }, ".5em", "13px")
        var theDBModel = globalCache.getSingleDBModelByID(modelID)
        if (theDBModel.isIoTDeviceModel) {
            this.drawConnectionStatus(singleDBTwinInfo["connectState"],parentDom)
            this.drawStaticInfo(parentDom, { "Connection State Time": singleDBTwinInfo["connectStateUpdateTime"] }, ".5em", "10px")
            parentDom.append($('<table style="font-size:smaller;margin:3px 0px"><tr><td class="'+constTelemetryColor+'">&nbsp;&nbsp;</td><td>telemetry</td><td class="'+constReportColor+'">&nbsp;&nbsp;</td><td>report</td><td class="'+constDesiredColor+'">&nbsp;&nbsp;</td><td>desired</td><td class="'+constCommonColor+'">&nbsp;&nbsp;</td><td>common</td></tr></table>'))
        }

        if (modelAnalyzer.DTDLModels[modelID]) {
            if (theDBModel.isIoTDeviceModel) {
                var funcGetKeyLblColorClass = (propertyPath) => {
                    var colorCodeMapping = {}
                    theDBModel.desiredProperties.forEach(desiredP => {
                        colorCodeMapping[JSON.stringify(desiredP.path)] = constDesiredColor
                    })
                    theDBModel.reportProperties.forEach(reportP => {
                        colorCodeMapping[JSON.stringify(reportP.path)] = constReportColor
                    })
                    theDBModel.telemetryProperties.forEach(telemetryP => {
                        colorCodeMapping[JSON.stringify(telemetryP.path)] = constTelemetryColor
                    })
                    var pathStr = JSON.stringify(propertyPath)
                    if (colorCodeMapping[pathStr]) return colorCodeMapping[pathStr]
                    else return constCommonColor
                }
            }
            this.drawEditable(parentDom, modelAnalyzer.DTDLModels[modelID].editableProperties, singleADTTwinInfo, [], funcGetKeyLblColorClass)
        }

        var metadataContent = $("<label style='display:block'></label>")
        var expandMetaBtn=$("<div class='w3-border w3-button w3-light-gray' style='padding:.1em .5em;margin-right:1em;font-size:10px'>...</div>")
        parentDom.append(metadataContent)
        var metaDataDiv=$('<div/>')
        metadataContent.append(expandMetaBtn,metaDataDiv)
        metaDataDiv.hide()
        expandMetaBtn.on("click",()=>{expandMetaBtn.hide();metaDataDiv.show()})
        if(notEmbedMetadata) expandMetaBtn.trigger("click")


        this.drawStaticInfo(metaDataDiv, { "Model": modelID }, "1em", "10px")
        for (var ind in singleADTTwinInfo["$metadata"]) {
            if (ind == "$model") continue;
            var tmpObj = {}
            tmpObj[ind] = singleADTTwinInfo["$metadata"][ind]
            this.drawStaticInfo(metaDataDiv, tmpObj, ".5em", "10px")
        }
    }

    async editDTProperty(originElementInfo, path, newVal, dataType) {
        if (["double", "float", "integer", "long"].includes(dataType)) newVal = Number(newVal)
        if(dataType=="boolean"){
            if(newVal=="true") newVal=true
            else newVal=false
        }

        //{ "op": "add", "path": "/x", "value": 30 }
        if (path.length == 1) {
            var str = ""
            path.forEach(segment => { str += "/" + segment })
            var jsonPatch = [{ "op": "add", "path": str, "value": newVal }]
        } else {
            //it is a property inside a object type of root property,update the whole root property
            var rootProperty = path[0]
            var patchValue = originElementInfo[rootProperty]
            if (patchValue == null) patchValue = {}
            else patchValue = JSON.parse(JSON.stringify(patchValue)) //make a copy
            this.updateOriginObjectValue(patchValue, path.slice(1), newVal)

            var jsonPatch = [{ "op": "add", "path": "/" + rootProperty, "value": patchValue }]
        }

        if (originElementInfo["$dtId"]) { //edit a node property
            var twinID = originElementInfo["$dtId"]
            var payLoad = { "jsonPatch": JSON.stringify(jsonPatch), "twinID": twinID }
        } else if (originElementInfo["$relationshipId"]) { //edit a relationship property
            var twinID = originElementInfo["$sourceId"]
            var relationshipID = originElementInfo["$relationshipId"]
            var payLoad = { "jsonPatch": JSON.stringify(jsonPatch), "twinID": twinID, "relationshipID": relationshipID }
        }


        try {
            await msalHelper.callAPI("digitaltwin/changeAttribute", "POST", payLoad)
            this.updateOriginObjectValue(originElementInfo, path, newVal)
        } catch (e) {
            console.log(e)
            if (e.responseText) alert(e.responseText)
        }

    }

    updateOriginObjectValue(nodeInfo, pathArr, newVal) {
        if (pathArr.length == 0) return;
        var theJson = nodeInfo
        for (var i = 0; i < pathArr.length; i++) {
            var key = pathArr[i]

            if (i == pathArr.length - 1) {
                theJson[key] = newVal
                break
            }
            if (theJson[key] == null) theJson[key] = {}
            theJson = theJson[key]
        }
    }

}

module.exports = baseInfoPanel;
},{"../msalHelper":12,"../sharedSourceFiles/globalCache":15,"../sharedSourceFiles/modelAnalyzer":16,"./simpleChart":22,"./simpleSelectMenu":25}],14:[function(require,module,exports){
const msalHelper=require("../msalHelper")
const globalCache=require("./globalCache")

function editProjectDialog() {
    if(!this.DOM){
        this.DOM = $('<div style="position:absolute;top:50%;background-color:white;left:50%;transform: translateX(-50%) translateY(-50%);z-index:101" class="w3-card-2"></div>')
        $("body").append(this.DOM)
        this.DOM.hide()
        globalCache.makeDOMDraggable(this.DOM)
    }
}

editProjectDialog.prototype.popup = function (projectInfo) {
    this.DOM.show()
    this.DOM.empty()
    this.projectInfo=projectInfo

    this.DOM.css({"width":"420px","padding-bottom":"3px"})
    this.DOM.append($('<div style="height:40px;margin-bottom:2px" class="w3-bar w3-red"><div class="w3-bar-item" style="font-size:1.2em">Project Setting</div></div>'))
    var closeButton = $('<button class="w3-bar-item w3-button w3-right" style="font-size:2em;padding-top:4px"></button>')
    this.DOM.children(':first').append(closeButton)
    closeButton.on("click", () => { this.DOM.hide() })

    var row1=$('<div class="w3-bar" style="padding:2px"></div>')
    this.DOM.append(row1)
    var lable=$('<div class="w3-bar-item w3-opacity" style="padding-right:5px;">Name </div>')
    row1.append(lable)
    var nameInput=$('<input type="text" style="outline:none; width:70%; display:inline;margin-left:2px;margin-right:2px"  placeholder="Project Name..."/>').addClass("w3-input w3-border");   
    row1.append(nameInput)
    nameInput.val(projectInfo.name)
    nameInput.on("change",async ()=>{
        var nameStr=nameInput.val()
        if(nameStr=="") {
            alert("Name can not be empty!")
            return;
        }
        var requestBody={"projectID":projectInfo.id,"accounts":[],"newProjectName":nameStr}
        requestBody.accounts=requestBody.accounts.concat(projectInfo.shareWith)
        try {
            await msalHelper.callAPI("accountManagement/changeOwnProjectName", "POST", requestBody)
            nameInput.blur()
        } catch (e) {
            console.log(e)
            if (e.responseText) alert(e.responseText)
            return
        }
    })



    var row2=$('<div class="w3-bar" style="padding:2px"></div>')
    this.DOM.append(row2)
    var lable=$('<div class="w3-bar-item w3-opacity" style="padding-right:5px;">Share With </div>')
    row2.append(lable)
    var shareAccountInput=$('<input type="text" style="outline:none; width:60%; display:inline;margin-left:2px;margin-right:2px"  placeholder="Invitee Email..."/>').addClass("w3-input w3-border");   
    row2.append(shareAccountInput)
    var inviteBtn=$('<a class="w3-button w3-border w3-red w3-hover-amber" href="#">Invite</a>') 
    row2.append(inviteBtn) 

    var shareAccountsList=$("<div class='w3-border w3-padding' style='margin:1px 1px; height:200px;overflow-x:hidden;overflow-y:auto'><div>")
    this.DOM.append(shareAccountsList)
    this.shareAccountsList=shareAccountsList;
    this.drawSharedAccounts()

    shareAccountInput.on("keydown",(event) =>{
        if (event.keyCode == 13) this.shareWithAccount(shareAccountInput)
    });
    inviteBtn.on("click",()=>{ this.shareWithAccount(shareAccountInput)})
}

editProjectDialog.prototype.shareWithAccount=async function(accountInput){
    var shareToAccount=accountInput.val()
    if(shareToAccount=="") return;
    var theIndex= this.projectInfo.shareWith.indexOf(shareToAccount)
    if(theIndex!=-1) return;
    var requestBody={"projectID":this.projectInfo.id,"shareToAccount":shareToAccount}
    try {
        await msalHelper.callAPI("accountManagement/shareProjectTo", "POST", requestBody)
        this.addAccountToShareWith(shareToAccount)
        this.drawSharedAccounts()
        accountInput.val("")
    } catch (e) {
        console.log(e)
        if (e.responseText) alert(e.responseText)
        return
    }
}

editProjectDialog.prototype.addAccountToShareWith=function(shareToAccountID){
    var theIndex= this.projectInfo.shareWith.indexOf(shareToAccountID)
    if(theIndex==-1) this.projectInfo.shareWith.push(shareToAccountID)
}

editProjectDialog.prototype.drawSharedAccounts=function(){
    this.shareAccountsList.empty()
    var sharedAccount=this.projectInfo.shareWith
    sharedAccount.forEach(oneEmail => {
        var arow = $('<div class="w3-bar" style="padding:2px"></div>')
        this.shareAccountsList.append(arow)
        var lable = $('<div class="w3-bar-item w3-opacity" style="padding-right:5px;">'+oneEmail+' </div>')
        arow.append(lable)
        var removeBtn=$('<a class="w3-button w3-border w3-red w3-hover-amber" style="margin-left:10pxyy" href="#">Remove</a>')
        arow.append(removeBtn)
        removeBtn.on("click",async ()=>{
            var requestBody={"projectID":this.projectInfo.id,"notShareToAccount":oneEmail}
            try {
                await msalHelper.callAPI("accountManagement/notShareProjectTo", "POST", requestBody)
                var theIndex = this.projectInfo.shareWith.indexOf(oneEmail)
                if (theIndex != -1) this.projectInfo.shareWith.splice(theIndex, 1)
                this.drawSharedAccounts()
            } catch (e) {
                console.log(e)
                if (e.responseText) alert(e.responseText)
                return
            }
        })
    })
}

module.exports = new editProjectDialog();
},{"../msalHelper":12,"./globalCache":15}],15:[function(require,module,exports){
(function (global){(function (){
function globalCache(){
    this.accountInfo=null;
    this.joinedProjectsToken=null;
    this.showFloatInfoPanel=true
    this.DBModelsArr = []
    this.DBTwins = {}
    this.modelIDMapToName={}
    this.modelNameMapToID={}
    this.twinIDMapToDisplayName={}
    this.twinDisplayNameMapToID={}
    this.storedTwins = {}
    this.layoutJSON={}
    this.visualDefinition={"default":{"detail":{}}}
    this.symbolLibs={}

    this.clipboardNodeStyle=null

    this.initStoredInformtion()
}

globalCache.prototype.checkTooLongIdle = function () {
    var previousTime=new Date().getTime()
    var maxDiff=10*60*1000

    var previousMouseDown=new Date().getTime()
    $(document).ready( ()=> {
        $(document).mousedown( (e)=> {
            previousMouseDown=new Date().getTime()
        });
    })

    setInterval(()=>{
        var currentTime=new Date().getTime()
        var diff1=currentTime-previousTime
        var diff2=currentTime-previousMouseDown
        if(diff1>maxDiff || diff2>maxDiff){
            //log out as it means the page just resumed from long time computer sleep
            this.stallPage()
        }
        previousTime=currentTime
    },60000)
}

globalCache.prototype.stallPage=function(){
    $('body').empty()
    for(var ind in global){
        if(ind=="location") continue
        try{
            global[ind]=null
        }catch(e){
            console.log(e)
        }
    } 

    const url = new URL(window.location.href);
    var destURL= url.origin+"/spaindex.html"
    window.location.replace(destURL);
}

globalCache.prototype.initStoredInformtion = function () {
    this.storedOutboundRelationships = {} 
    //stored data, seperately from ADT service and from cosmosDB service
    this.currentLayoutName=null   
}

globalCache.prototype.findProjectInfo=function(projectID){
    var joinedProjects=this.accountInfo.joinedProjects
    for(var i=0;i<joinedProjects.length;i++){
        var oneProject=joinedProjects[i]
        if(oneProject.id==projectID) return oneProject
    }
}


globalCache.prototype.storeADTTwins=function(twinsData){
    twinsData.forEach((oneNode)=>{this.storeSingleADTTwin(oneNode)});
}

globalCache.prototype.storeSingleADTTwin=function(oneNode){
    this.storedTwins[oneNode["$dtId"]] = oneNode
    oneNode["displayName"]= this.twinIDMapToDisplayName[oneNode["$dtId"]]
    //this.broadcastMessage({ "message": "ADTTwinInfoUpdate","twinID":oneNode["$dtId"]})
}


globalCache.prototype.storeSingleDBTwin=function(DBTwin){
    this.DBTwins[DBTwin["id"]]=DBTwin
    this.twinIDMapToDisplayName[DBTwin["id"]]=DBTwin["displayName"]
    this.twinDisplayNameMapToID[DBTwin["displayName"]]=DBTwin["id"]
}

globalCache.prototype.storeDBTwinsArr=function(DBTwinsArr){
    for(var ind in this.DBTwins) delete this.DBTwins[ind]
    for(var ind in this.twinIDMapToDisplayName) delete this.twinIDMapToDisplayName[ind]
    for(var ind in this.twinDisplayNameMapToID) delete this.twinDisplayNameMapToID[ind]

    this.mergeDBTwinsArr(DBTwinsArr)
}

globalCache.prototype.mergeDBTwinsArr=function(DBTwinsArr){
    DBTwinsArr.forEach(oneDBTwin=>{
        this.DBTwins[oneDBTwin["id"]]=oneDBTwin
        this.twinIDMapToDisplayName[oneDBTwin["id"]]=oneDBTwin["displayName"]
        this.twinDisplayNameMapToID[oneDBTwin["displayName"]]=oneDBTwin["id"]
    })
}

globalCache.prototype.storeUserData=function(res){
    res.forEach(oneResponse=>{
        if(oneResponse.type=="joinedProjectsToken") this.joinedProjectsToken=oneResponse.jwt;
        else if(oneResponse.type=="user") this.accountInfo=oneResponse
    })
}

globalCache.prototype.storeProjectModelsData=function(DBModels,adtModels){
    this.storeDBModelsArr(DBModels)

    for(var ind in this.modelIDMapToName) delete this.modelIDMapToName[ind]
    for(var ind in this.modelNameMapToID) delete this.modelNameMapToID[ind]

    var tmpNameToObj = {}
    for (var i = 0; i < adtModels.length; i++) {
        if (adtModels[i]["displayName"] == null) adtModels[i]["displayName"] = adtModels[i]["@id"]
        if ($.isPlainObject(adtModels[i]["displayName"])) {
            if (adtModels[i]["displayName"]["en"]) adtModels[i]["displayName"] = adtModels[i]["displayName"]["en"]
            else adtModels[i]["displayName"] = JSON.stringify(adtModels[i]["displayName"])
        }
        if (tmpNameToObj[adtModels[i]["displayName"]] != null) {
            //repeated model display name
            adtModels[i]["displayName"] = adtModels[i]["@id"]
        }
        tmpNameToObj[adtModels[i]["displayName"]] = 1

        this.modelIDMapToName[adtModels[i]["@id"]] = adtModels[i]["displayName"]
        this.modelNameMapToID[adtModels[i]["displayName"]] = adtModels[i]["@id"]
    }
}

globalCache.prototype.storeProjectTwinsAndVisualData=function(resArr){
    var dbtwins=[]
    for(var ind in this.visualDefinition) delete this.visualDefinition[ind]
    for(var ind in this.layoutJSON) delete this.layoutJSON[ind]
    this.visualDefinition["default"]={"detail":{}}

    resArr.forEach(element => {
        if(element.type=="visualSchema") {
            //TODO: now there is only one "default" schema to use,consider allow creating more user define visual schema
            //TODO: only choose the schema belongs to self
            this.recordSingleVisualSchema(element.detail,element.accountID,element.name,element.isShared)
        }else if(element.type=="Topology") {
            this.recordSingleLayout(element.detail,element.accountID,element.name,element.isShared)
        }else if(element.type=="DTTwin") dbtwins.push(element)
        else if(element.type=="symbols"){
            this.symbolLibs[element.displayName]=element.detail
        }
    });
    this.storeDBTwinsArr(dbtwins)

    resArr.forEach(element => {
        if(element.originalScript!=null) { 
            var twinID=element.twinID
            var oneDBTwin=this.DBTwins[twinID]
            if(oneDBTwin){
                oneDBTwin["originalScript"]=element["originalScript"]
                oneDBTwin["lastExecutionTime"]=element["lastExecutionTime"]
                oneDBTwin["author"]=element["author"]
                oneDBTwin["invalidFlag"]=element["invalidFlag"]
                oneDBTwin["inputs"]=element["inputs"]
                oneDBTwin["outputs"]=element["outputs"]

            }
        }
    });
}

globalCache.prototype.recordSingleVisualSchema=function(detail,accountID,oname,isShared){
    if (accountID == this.accountInfo.id) var vsName = oname
    else vsName = oname + `(from ${accountID})`
    var dict = { "detail": detail, "isShared": isShared, "owner": accountID, "oname": oname}
    this.visualDefinition[vsName]=dict
}

globalCache.prototype.recordSingleLayout=function(detail,accountID,oname,isShared){
    if (accountID == this.accountInfo.id) var layoutName = oname
    else layoutName = oname + `(from ${accountID})`
    var dict = { "detail": detail, "isShared": isShared, "owner": accountID, "name": layoutName, "oname":oname }
    this.layoutJSON[layoutName] = dict
}

globalCache.prototype.getDBTwinsByModelID=function(modelID){
    var resultArr=[]
    for(var ind in this.DBTwins){
        var ele=this.DBTwins[ind]
        if(ele.modelID==modelID){
            resultArr.push(ele)
        }
    }
    return resultArr;
}

globalCache.prototype.getSingleDBTwinByName=function(twinName){
    var twinID=this.twinDisplayNameMapToID[twinName]
    return this.DBTwins[twinID]
}

globalCache.prototype.getSingleDBTwinByIndoorFeatureID=function(featureID){
    for(var ind in this.DBTwins){
        var ele=this.DBTwins[ind]
        if(ele.GIS && ele.GIS.indoor){
            if(ele.GIS.indoor.IndoorFeatureID==featureID) return ele
        }
    }
    return null;
}

globalCache.prototype.getSingleDBModelByID=function(modelID){
    for(var i=0;i<this.DBModelsArr.length;i++){
        var ele = this.DBModelsArr[i]
        if(ele.id==modelID){
            return ele
        }
    }
    return null;
}

globalCache.prototype.storeSingleDBModel=function(singleDBModelInfo){
    var modelID = singleDBModelInfo.id
    for(var i=0;i<this.DBModelsArr.length;i++){
        var ele = this.DBModelsArr[i]
        if(ele.id==modelID){
            for(var ind in ele) delete ele[ind]
            for(var ind in singleDBModelInfo) ele[ind]=singleDBModelInfo[ind]
            return;
        }
    }
    //it is a new single model if code reaches here
    this.DBModelsArr.push(singleDBModelInfo)
    this.sortDBModelsArr()
}

globalCache.prototype.storeDBModelsArr=function(DBModelsArr){
    this.DBModelsArr.length=0
    this.DBModelsArr=this.DBModelsArr.concat(DBModelsArr)
    this.sortDBModelsArr()
    
}
globalCache.prototype.sortDBModelsArr=function(){
    this.DBModelsArr.sort(function (a, b) { 
        var aName=a.displayName.toLowerCase()
        var bName=b.displayName.toLowerCase()
        return aName.localeCompare(bName) 
    });
}


globalCache.prototype.getStoredAllInboundRelationsSources=function(twinID){
    var srcTwins={}
    for(var srcTwin in this.storedOutboundRelationships){
        var arr=this.storedOutboundRelationships[srcTwin]
        arr.forEach(oneRelation=>{
            if(oneRelation["$targetId"]==twinID) srcTwins[oneRelation["$sourceId"]]=1
        })
    }
    return srcTwins;
}

globalCache.prototype.storeTwinRelationships=function(relationsData){
    relationsData.forEach((oneRelationship)=>{
        var twinID=oneRelationship['$sourceId']
        this.storedOutboundRelationships[twinID]=[]
    })

    relationsData.forEach((oneRelationship)=>{
        this.storedOutboundRelationships[oneRelationship['$sourceId']].push(oneRelationship)
    })
}

globalCache.prototype.storeTwinRelationships_append=function(relationsData){
    relationsData.forEach((oneRelationship)=>{
        if(!this.storedOutboundRelationships[oneRelationship['$sourceId']])
            this.storedOutboundRelationships[oneRelationship['$sourceId']]=[]
        this.storedOutboundRelationships[oneRelationship['$sourceId']].push(oneRelationship)
    })
}

globalCache.prototype.storeTwinRelationships_remove=function(relationsData){
    relationsData.forEach((oneRelationship)=>{
        var srcID=oneRelationship["srcID"]
        if(this.storedOutboundRelationships[srcID]){
            var arr=this.storedOutboundRelationships[srcID]
            for(var i=0;i<arr.length;i++){
                if(arr[i]['$relationshipId']==oneRelationship["relID"]){
                    arr.splice(i,1)
                    break;
                }
            }
        }
    })
}

globalCache.prototype.findAllInputsInScript=function(calcScript,formulaTwinName){
    //find all properties in the script
    calcScript+="\n" //make sure the below patterns using "[^. ] not fail because of it is the end of string "
    var patt = /_self(?<=_self)\[\".*?(?=\"\][^\[])\"\]/g; 
    var allSelfProperties=calcScript.match(patt)||[];
    var countAllSelfTimes={}
    allSelfProperties.forEach(oneSelf=>{
        if(countAllSelfTimes[oneSelf]) countAllSelfTimes[oneSelf]+=1
        else countAllSelfTimes[oneSelf]=1
    })

    var patt = /_twinVal(?<=_twinVal)\[\".*?(?=\"\][^\[])\"\]/g; 
    var allOtherTwinProperties=calcScript.match(patt)||[];
    var listAllOthers={}
    allOtherTwinProperties.forEach(oneOther=>{listAllOthers[oneOther]=1 })

    //analyze all variables that can not be as input as they are changed during calcuation
    //they disqualify as input as they will trigger infinite calculation, all these belongs to _self
    var outputpatt = /_self(?<=_self)\[\"[^;{]*?[^\=](?=\=[^\=])/g;
    var outputProperties=calcScript.match(outputpatt)||[];
    var countOutputTimes={}
    outputProperties.forEach(oneOutput=>{
        if(countOutputTimes[oneOutput]) countOutputTimes[oneOutput]+=1
        else countOutputTimes[oneOutput]=1
    })
    

    var inputPropertiesArr=[]
    for(var ind in listAllOthers) inputPropertiesArr.push(ind)
    for(var ind in countAllSelfTimes){
        if(countAllSelfTimes[ind]!=countOutputTimes[ind]) inputPropertiesArr.push(ind)
    }

    var returnArr=[]
    inputPropertiesArr.forEach(oneProperty=>{
        var oneInputObj={} //twinID, path, value
        var fetchpropertypatt = /(?<=\[\").*?(?=\"\])/g;
        if(oneProperty.startsWith("_self")){
            oneInputObj.path=oneProperty.match(fetchpropertypatt);
            oneInputObj.twinName=formulaTwinName+"(self)"
            oneInputObj.twinName_origin=formulaTwinName
            var twinID=this.twinDisplayNameMapToID[formulaTwinName]
            oneInputObj.value=this.searchValue(this.storedTwins[twinID],oneInputObj.path)
        }else if(oneProperty.startsWith("_twinVal")){
            var arr=oneProperty.match(fetchpropertypatt);
            var firstEle=arr[0]
            arr.shift()
            oneInputObj.path=arr
            var twinID=this.twinDisplayNameMapToID[firstEle]
            oneInputObj.value=this.searchValue(this.storedTwins[twinID],oneInputObj.path)
            oneInputObj.twinName=oneInputObj.twinName_origin=firstEle
        }
        returnArr.push(oneInputObj)
    })
    return returnArr
}

globalCache.prototype.searchValue=function(originElementInfo,pathArr){
    if(pathArr.length==0) return null;
    var theJson=originElementInfo
    for(var i=0;i<pathArr.length;i++){
        var key=pathArr[i]
        theJson=theJson[key]
        if(theJson==null) return null;
    }
    return theJson //it should be the final value
}

globalCache.prototype.shapeSvg=function(shape,color,secondColor){
    var svgStart='<svg xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" fill="none" version="1.1" >'
    if(secondColor){
        if(color=="none") color="darkGray" 
        var gradientDefinition='<defs>'+
            '<linearGradient id="grad1" x1="0%" y1="0%" x2="0%" y2="100%">'+
            '<stop offset="0%" style="stop-color:'+color+';stop-opacity:1" />'+
            '<stop offset="50%" style="stop-color:'+color+';stop-opacity:1" />'+
            '<stop offset="51%" style="stop-color:'+secondColor+';stop-opacity:1" />'+
            '</linearGradient></defs>'
        svgStart+=gradientDefinition
    }
    var colorStr=(secondColor)?"url(#grad1)":color
    if(shape=="ellipse"){
        return svgStart+'<circle cx="50" cy="50" r="50"  fill="'+colorStr+'"/></svg>'
    }else if(shape=="hexagon"){
        return svgStart+'<polygon points="50 0, 93.3 25, 93.3 75, 50 100, 6.7 75, 6.7 25"  fill="'+colorStr+'" /></svg>'
    }else if(shape=="rectangle"){
        return svgStart+'<rect x="10" y="10" rx="10" ry="10" width="80" height="80" fill="'+colorStr+'" /></svg>'
    }
}

globalCache.prototype.makeDOMDraggable=function(dom,ignoreChildDomType){
    ignoreChildDomType=ignoreChildDomType||["LABEL","TD","B","A","INPUT","PRE"]
    dom.on('mousedown',(e)=>{
        if(ignoreChildDomType.indexOf(e.target.tagName)!=-1) return;
        var domOffset=dom.offset()
        dom.mouseStartDragOffset=[domOffset.left-e.clientX, domOffset.top-e.clientY]
        $('body').on('mouseup',()=>{
            dom.mouseStartDragOffset=null
            $('body').off('mousemove')
            $('body').off('mouseup')
        })
        $('body').on('mousemove',(e)=>{
            e.preventDefault()
            if(dom.mouseStartDragOffset){
                var newLeft= e.clientX+dom.mouseStartDragOffset[0]
                var newTop=e.clientY+dom.mouseStartDragOffset[1]
                dom.css({"left":newLeft+"px","top":newTop+"px","transform":"none"})
            }
        })
    })
}

globalCache.prototype.uuidv4=function() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
    });
}

module.exports = new globalCache();
}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],16:[function(require,module,exports){
const msalHelper=require("../msalHelper")
//This is a singleton class

function modelAnalyzer(){
    this.DTDLModels={}
    this.relationshipTypes={}
}

modelAnalyzer.prototype.clearAllModels=function(){
    //console.log("clear all model info")
    for(var id in this.DTDLModels) delete this.DTDLModels[id]
}

modelAnalyzer.prototype.resetAllModels=function(){
    for(var modelID in this.DTDLModels){
        var jsonStr=this.DTDLModels[modelID]["original"]
        this.DTDLModels[modelID]=JSON.parse(jsonStr)
        this.DTDLModels[modelID]["original"]=jsonStr
    }
}


modelAnalyzer.prototype.addModels=function(arr){
    arr.forEach((ele)=>{
        var modelID= ele["@id"]
        ele["original"]=JSON.stringify(ele)
        this.DTDLModels[modelID]=ele
    })
}


modelAnalyzer.prototype.recordAllBaseClasses= function (parentObj, baseClassID) {
    var baseClass = this.DTDLModels[baseClassID]
    if (baseClass == null) return;

    parentObj[baseClassID]=1

    var furtherBaseClassIDs = baseClass.extends;
    if (furtherBaseClassIDs == null) return;
    if(Array.isArray(furtherBaseClassIDs)) var tmpArr=furtherBaseClassIDs
    else tmpArr=[furtherBaseClassIDs]
    tmpArr.forEach((eachBase) => { this.recordAllBaseClasses(parentObj, eachBase) })
}

modelAnalyzer.prototype.expandEditablePropertiesFromBaseClass = function (parentObj, baseClassID) {
    var baseClass = this.DTDLModels[baseClassID]
    if (baseClass == null) return;
    if (baseClass.editableProperties) {
        for (var ind in baseClass.editableProperties) parentObj[ind] = baseClass.editableProperties[ind]
    }
    var furtherBaseClassIDs = baseClass.extends;
    if (furtherBaseClassIDs == null) return;
    if(Array.isArray(furtherBaseClassIDs)) var tmpArr=furtherBaseClassIDs
    else tmpArr=[furtherBaseClassIDs]
    tmpArr.forEach((eachBase) => { this.expandEditablePropertiesFromBaseClass(parentObj, eachBase) })
}

modelAnalyzer.prototype.expandValidRelationshipTypesFromBaseClass = function (parentObj, baseClassID) {
    var baseClass = this.DTDLModels[baseClassID]
    if (baseClass == null) return;
    if (baseClass.validRelationships) {
        for (var ind in baseClass.validRelationships) {
            if(parentObj[ind]==null) parentObj[ind] = this.relationshipTypes[ind][baseClassID]
        }
    }
    var furtherBaseClassIDs = baseClass.extends;
    if (furtherBaseClassIDs == null) return;
    if(Array.isArray(furtherBaseClassIDs)) var tmpArr=furtherBaseClassIDs
    else tmpArr=[furtherBaseClassIDs]
    tmpArr.forEach((eachBase) => { this.expandValidRelationshipTypesFromBaseClass(parentObj, eachBase) })
}

modelAnalyzer.prototype.expandEditableProperties=function(parentObj,dataInfo,embeddedSchema){
    dataInfo.forEach((oneContent)=>{
        if(oneContent["@type"]=="Relationship") return;
        if(oneContent["@type"]=="Property"
        ||(Array.isArray(oneContent["@type"]) && oneContent["@type"].includes("Property"))
        || oneContent["@type"]==null) {
            if(typeof(oneContent["schema"]) != 'object' && embeddedSchema[oneContent["schema"]]!=null) oneContent["schema"]=embeddedSchema[oneContent["schema"]]

            if(typeof(oneContent["schema"]) === 'object' && oneContent["schema"]["@type"]=="Object"){
                var newParent={}
                parentObj[oneContent["name"]]=newParent
                this.expandEditableProperties(newParent,oneContent["schema"]["fields"],embeddedSchema)
            }else if(typeof(oneContent["schema"]) === 'object' && oneContent["schema"]["@type"]=="Enum"){
                parentObj[oneContent["name"]]=oneContent["schema"]["enumValues"]
            }else{
                parentObj[oneContent["name"]]=oneContent["schema"]
            }           
        }
    })
}


modelAnalyzer.prototype.analyze=function(){
    //console.log("analyze model info")
    //analyze all relationship types
    for (var id in this.relationshipTypes) delete this.relationshipTypes[id]
    for (var modelID in this.DTDLModels) {
        var ele = this.DTDLModels[modelID]
        var embeddedSchema = {}
        if (ele.schemas) {
            var tempArr;
            if (Array.isArray(ele.schemas)) tempArr = ele.schemas
            else tempArr = [ele.schemas]
            tempArr.forEach((ele) => {
                embeddedSchema[ele["@id"]] = ele
            })
        }

        var contentArr = ele.contents
        if (!contentArr) continue;
        contentArr.forEach((oneContent) => {
            if (oneContent["@type"] == "Relationship") {
                if(!this.relationshipTypes[oneContent["name"]]) this.relationshipTypes[oneContent["name"]]= {}
                this.relationshipTypes[oneContent["name"]][modelID] = oneContent
                oneContent.editableRelationshipProperties = {}
                if (Array.isArray(oneContent.properties)) {
                    this.expandEditableProperties(oneContent.editableRelationshipProperties, oneContent.properties, embeddedSchema)
                }
            }
        })
    }

    //analyze each model's property that can be edited
    for(var modelID in this.DTDLModels){ //expand possible embedded schema to editableProperties, also extract possible relationship types for this model
        var ele=this.DTDLModels[modelID]
        var embeddedSchema={}
        if(ele.schemas){
            var tempArr;
            if(Array.isArray(ele.schemas)) tempArr=ele.schemas
            else tempArr=[ele.schemas]
            tempArr.forEach((ele)=>{
                embeddedSchema[ele["@id"]]=ele
            })
        }
        ele.editableProperties={}
        ele.validRelationships={}
        ele.includedComponents=[]
        ele.allBaseClasses={}
        if(Array.isArray(ele.contents)){
            this.expandEditableProperties(ele.editableProperties,ele.contents,embeddedSchema)

            ele.contents.forEach((oneContent)=>{
                if(oneContent["@type"]=="Relationship") {
                    ele.validRelationships[oneContent["name"]]=this.relationshipTypes[oneContent["name"]][modelID]
                }
            })
        }
    }

    for(var modelID in this.DTDLModels){//expand component properties
        var ele=this.DTDLModels[modelID]
        if(Array.isArray(ele.contents)){
            ele.contents.forEach(oneContent=>{
                if(oneContent["@type"]=="Component"){
                    var componentName=oneContent["name"]
                    var componentClass=oneContent["schema"]
                    ele.editableProperties[componentName]={}
                    this.expandEditablePropertiesFromBaseClass(ele.editableProperties[componentName],componentClass)
                    ele.includedComponents.push(componentName)
                } 
            })
        }
    }

    for(var modelID in this.DTDLModels){//expand base class properties to editableProperties and valid relationship types to validRelationships
        var ele=this.DTDLModels[modelID]
        var baseClassIDs=ele.extends;
        if(baseClassIDs==null) continue;
        if(Array.isArray(baseClassIDs)) var tmpArr=baseClassIDs
        else tmpArr=[baseClassIDs]
        tmpArr.forEach((eachBase)=>{
            this.recordAllBaseClasses(ele.allBaseClasses,eachBase)
            this.expandEditablePropertiesFromBaseClass(ele.editableProperties,eachBase)
            this.expandValidRelationshipTypesFromBaseClass(ele.validRelationships,eachBase)
        })
    }

    //console.log(this.DTDLModels)
    //console.log(this.relationshipTypes)
}

modelAnalyzer.prototype.listModelsForDeleteModel=function(modelID){
    var childModelIDs=[]
    for(var aID in this.DTDLModels){
        var aModel=this.DTDLModels[aID]
        if(aModel.allBaseClasses && aModel.allBaseClasses[modelID]) childModelIDs.push(aModel["@id"])
    }
    return childModelIDs
}

modelAnalyzer.prototype.deleteModel=async function(modelID,funcAfterEachSuccessDelete,funcAfterFail,completeFunc){
    var relatedModelIDs=this.listModelsForDeleteModel(modelID)
    var modelLevel=[]
    relatedModelIDs.forEach(oneID=>{
        var checkModel=this.DTDLModels[oneID]
        modelLevel.push({"modelID":oneID,"level":Object.keys(checkModel.allBaseClasses).length})
    })
    modelLevel.push({"modelID":modelID,"level":0})
    modelLevel.sort(function (a, b) {return b["level"]-a["level"] });
    
    for(var i=0;i<modelLevel.length;i++){
        var aModelID=modelLevel[i].modelID
        try{
            await msalHelper.callAPI("digitaltwin/deleteModel", "POST", { "model": aModelID },"withProjectID")
            delete this.DTDLModels[aModelID]
            if(funcAfterEachSuccessDelete) funcAfterEachSuccessDelete(aModelID)
        }catch(e){
            var deletedModels=[]
            var alertStr="Delete model is incomplete. Deleted Model:"
            for(var j=0;j<i;j++){
                alertStr+= modelLevel[j].modelID+" "
                deletedModels.push(modelLevel[j].modelID)
            } 
            alertStr+=". Fail to delete "+aModelID+". Error is "+e
            if(funcAfterFail) funcAfterFail(deletedModels)
            alert(e)
        }
    }
    if(completeFunc) completeFunc()
}


modelAnalyzer.prototype.fetchPropertyPathsOfModel=function(modelID){
    var properties=this.DTDLModels[modelID].editableProperties
    var propertyPaths=[]
    this.analyzePropertyPath(properties,[],propertyPaths)
    return propertyPaths
}

modelAnalyzer.prototype.analyzePropertyPath=function (jsonInfo,pathArr,propertyPaths){
    for(var ind in jsonInfo){
        var newPath=pathArr.concat([ind])
        if(!Array.isArray(jsonInfo[ind]) && typeof(jsonInfo[ind])==="object") {
            this.analyzePropertyPath(jsonInfo[ind],newPath,propertyPaths)
        }else {
            propertyPaths.push(newPath)
        }
    }
}

module.exports = new modelAnalyzer();
},{"../msalHelper":12}],17:[function(require,module,exports){
const modelAnalyzer=require("./modelAnalyzer")
const simpleSelectMenu= require("./simpleSelectMenu")
const msalHelper=require("../msalHelper")
const simpleConfirmDialog=require("./simpleConfirmDialog")
const globalCache=require("./globalCache")

function modelEditorDialog() {
    if(!this.DOM){
        this.DOM = $('<div style="position:absolute;top:50%;background-color:white;left:50%;transform: translateX(-50%) translateY(-50%);z-index:100" class="w3-card-2"></div>')
        $("body").append(this.DOM)
        this.DOM.hide()
        globalCache.makeDOMDraggable(this.DOM)
    }
}

modelEditorDialog.prototype.popup = async function() {
    this.DOM.show()
    this.DOM.empty()
    this.contentDOM = $('<div style="width:665px"></div>')
    this.DOM.append(this.contentDOM)
    this.contentDOM.append($('<div style="height:40px" class="w3-bar w3-red"><div class="w3-bar-item" style="font-size:1.5em">Digital Twin Model Editor</div></div>'))
    var closeButton = $('<button class="w3-bar-item w3-button w3-right" style="font-size:2em;padding-top:4px"></button>')
    this.contentDOM.children(':first').append(closeButton)
    closeButton.on("click", () => { this.DOM.hide() })

    var buttonRow=$('<div  style="height:40px" class="w3-bar"></div>')
    this.contentDOM.append(buttonRow)
    var importButton =$('<button class="w3-button w3-card w3-deep-orange w3-hover-light-green w3-right" style="height:100%">Import</button>')
    this.importButton=importButton
    buttonRow.append(importButton)

    importButton.on("click", async () => {
        var currentModelID=this.dtdlobj["@id"]
        if(modelAnalyzer.DTDLModels[currentModelID]==null) this.importModelArr([this.dtdlobj])
        else this.replaceModel()       
    })

    var lable=$('<div class="w3-bar-item w3-opacity" style="padding-right:5px;font-size:1.2em;">Model Template</div>')
    buttonRow.append(lable)
    var modelTemplateSelector=new simpleSelectMenu(" ",{withBorder:1,fontSize:"1.2em",colorClass:"w3-light-gray",buttonCSS:{"padding":"5px 10px"},"optionListHeight":300})
    buttonRow.append(modelTemplateSelector.DOM)
    modelTemplateSelector.callBack_clickOption=(optionText,optionValue)=>{
        modelTemplateSelector.changeName(optionText)
        this.chooseTemplate(optionValue)
    }
    modelTemplateSelector.addOption("New Model...","New")
    for(var modelName in modelAnalyzer.DTDLModels){
        modelTemplateSelector.addOption(modelName)
    }

    var panelHeight="450px"
    var row2=$('<div class="w3-cell-row" style="margin:2px"></div>')
    this.contentDOM.append(row2)
    var leftSpan=$('<div class="w3-card" style="padding:5px;width:330px;padding-right:5px;height:'+panelHeight+';overflow:auto"></div>')
    row2.append(leftSpan)
    this.leftSpan=leftSpan

    var rightSpan=$('<div class="w3-container w3-cell"></div>')
    row2.append(rightSpan) 
    var dtdlScriptPanel=$('<div class="w3-card-2 w3-white" style="overflow:auto;margin-top:2px;width:310px;height:'+panelHeight+'"></div>')
    rightSpan.append(dtdlScriptPanel)
    this.dtdlScriptPanel=dtdlScriptPanel

    modelTemplateSelector.triggerOptionIndex(0)
}

modelEditorDialog.prototype.replaceModel=function(){
    //delete the old same name model, then create it again
    var currentModelID=this.dtdlobj["@id"]

    var relatedModelIDs=modelAnalyzer.listModelsForDeleteModel(currentModelID)

    var dialogStr = (relatedModelIDs.length == 0) ? ("Twins will be impact under model \"" + currentModelID + "\"") :
        (currentModelID + " is base model of " + relatedModelIDs.join(", ") + ". Twins under these models will be impact.")
    var confirmDialogDiv = new simpleConfirmDialog()
    confirmDialogDiv.show(
        { width: "350px" },
        {
            title: "Warning"
            , content: dialogStr
            , buttons: [
                {
                    colorClass: "w3-red w3-hover-pink", text: "Confirm", "clickFunc": () => {
                        confirmDialogDiv.close();
                        this.confirmReplaceModel(currentModelID)
                    }
                },
                {
                    colorClass: "w3-gray", text: "Cancel", "clickFunc": () => {
                        confirmDialogDiv.close()
                    }
                }
            ]
        }
    )    
}

modelEditorDialog.prototype.importModelArr=async function(modelToBeImported,forReplacing,afterFailure){
    try {
        await msalHelper.callAPI("digitaltwin/importModels", "POST", { "models": JSON.stringify(modelToBeImported) },"withProjectID")
        if(forReplacing) alert("Model " + this.dtdlobj["displayName"] + " is modified successfully!")
        else alert("Model " + this.dtdlobj["displayName"] + " is created!")

        this.broadcastMessage({ "message": "ADTModelEdited" })
        modelAnalyzer.addModels(modelToBeImported) //add so immediatley the list can show the new models
        this.popup() //refresh content
    }catch(e){
        if(afterFailure) afterFailure()
        console.log(e)
        if(e.responseText) alert(e.responseText)
    } 
}

modelEditorDialog.prototype.confirmReplaceModel=function(modelID){
    var relatedModelIDs=modelAnalyzer.listModelsForDeleteModel(modelID)
    var backupModels=[]
    relatedModelIDs.forEach(oneID=>{
        backupModels.push(JSON.parse(modelAnalyzer.DTDLModels[oneID]["original"]))
    })
    backupModels.push(this.dtdlobj)
    var backupModelsStr=encodeURIComponent(JSON.stringify(backupModels))

    var funcAfterFail=(deletedModelIDs)=>{
        var pom = $("<a></a>")
        pom.attr('href', 'data:text/plain;charset=utf-8,' + backupModelsStr);
        pom.attr('download', "exportModelsAfterFailedOperation.json");
        pom[0].click()
    }
    var funcAfterEachSuccessDelete = (eachDeletedModelID,eachModelName) => {}
    
    var completeFunc=()=>{ 
        //import all the models again
        this.importModelArr(backupModels,"forReplacing",funcAfterFail)
    }
    modelAnalyzer.deleteModel(modelID,funcAfterEachSuccessDelete,funcAfterFail,completeFunc)
}



modelEditorDialog.prototype.chooseTemplate=function(tempalteName){
    if(tempalteName!="New"){
        this.dtdlobj=JSON.parse(modelAnalyzer.DTDLModels[tempalteName]["original"])
    }else{
        this.dtdlobj = {
            "@id": "dtmi:aNameSpace:aModelID;1",
            "@context": ["dtmi:dtdl:context;2"],
            "@type": "Interface",
            "displayName": "New Model",
            "contents": [
                {
                    "@type": "Property",
                    "name": "attribute1",
                    "schema": "double"
                },{
                    "@type": "Relationship",
                    "name": "link"
                }
            ]
        }
    }
    this.leftSpan.empty()

    this.refreshDTDL()
    this.leftSpan.append($('<div class="w3-bar"><div class="w3-bar-item w3-tooltip" style="font-size:1.2em;padding-left:2px;font-weight:bold;color:gray">Model ID & Name<p style="position:absolute;text-align:left;font-weight:normal;top:-10px;width:200px" class="w3-text w3-tag w3-tiny">model ID contains namespace, a model string and a version number</p></div></div>'))
    new idRow(this.dtdlobj,this.leftSpan,()=>{this.refreshDTDL()})
    new displayNameRow(this.dtdlobj,this.leftSpan,()=>{this.refreshDTDL()})

    if(!this.dtdlobj["contents"])this.dtdlobj["contents"]=[]
    new parametersRow(this.dtdlobj["contents"],this.leftSpan,()=>{this.refreshDTDL()},this.DOM.offset())
    new relationsRow(this.dtdlobj["contents"],this.leftSpan,()=>{this.refreshDTDL()},this.DOM.offset())
    new componentsRow(this.dtdlobj["contents"],this.leftSpan,()=>{this.refreshDTDL()})

    if(!this.dtdlobj["extends"])this.dtdlobj["extends"]=[]
    new baseClassesRow(this.dtdlobj["extends"],this.leftSpan,()=>{this.refreshDTDL()})
}

modelEditorDialog.prototype.refreshDTDL=function(){
    //it will refresh the generated DTDL sample, it will also change the import button to show "Create" or "Modify"
    var currentModelID=this.dtdlobj["@id"]
    if(modelAnalyzer.DTDLModels[currentModelID]==null) this.importButton.text("Create")
    else this.importButton.text("Modify")

    this.dtdlScriptPanel.empty()
    this.dtdlScriptPanel.append($('<div style="height:20px;width:100px" class="w3-bar w3-gray">Generated DTDL</div>'))
    this.dtdlScriptPanel.append($('<pre style="color:gray">'+JSON.stringify(this.dtdlobj,null,2)+'</pre>'))
}

module.exports = new modelEditorDialog();


function baseClassesRow(dtdlObj,parentDOM,refreshDTDLF){
    var rowDOM=$('<div class="w3-bar"><div class="w3-bar-item  w3-tooltip" style="font-size:1.2em;padding-left:2px;font-weight:bold;color:gray">Base Classes<p style="position:absolute;text-align:left;top:-10px;font-weight:normal;width:200px" class="w3-text w3-tag w3-tiny">Base class model\'s parameters and relationship type are inherited</p></div></div>')

    var addButton = $('<button class="w3-ripple w3-bar-item w3-button w3-red w3-hover-amber" style="margin-top:2px;font-size:1.2em;padding:4px 8px">+</button>')
    rowDOM.append(addButton)
    parentDOM.append(rowDOM)
    var contentDOM=$('<div style="padding-left:10px"></div>')
    rowDOM.append(contentDOM)
    addButton.on("click",()=>{
        var newObj = "unknown"
        dtdlObj.push(newObj)
        new singleBaseclassRow(newObj,contentDOM,refreshDTDLF,dtdlObj)
        refreshDTDLF()
    })
    //check existed content initially from template and trigger their drawing
    dtdlObj.forEach(element => {
        new singleBaseclassRow(element,contentDOM,refreshDTDLF,dtdlObj)
    });
}

function singleBaseclassRow(dtdlObj,parentDOM,refreshDTDLF,parentDtdlObj){
    var DOM = $('<div class="w3-cell-row"></div>')
    var baseClassNameInput=$('<input type="text" style="outline:none;display:inline;width:220px;padding:4px"  placeholder="base model id"/>').addClass("w3-bar-item w3-input w3-border");
    var removeButton = $('<button class="w3-bar-item w3-button w3-hover-amber" style="color:gray;margin-left:3px;margin-top:2px;font-size:1.2em;padding:2px"><i class="fa fa-trash fa-lg"></i></button>')
    DOM.append(baseClassNameInput,removeButton)

    removeButton.on("click",()=>{
        for (var i =0;i< parentDtdlObj.length; i++) {
            if (parentDtdlObj[i] == dtdlObj) {
                parentDtdlObj.splice(i, 1);
                break;
            }
        }
        DOM.remove()
        refreshDTDLF()
    })

    parentDOM.append(DOM)

    baseClassNameInput.val(dtdlObj)
    baseClassNameInput.on("change",()=>{
        for (var i =0;i< parentDtdlObj.length; i++) {
            if (parentDtdlObj[i] == dtdlObj) {
                parentDtdlObj[i]=baseClassNameInput.val()
                break;
            }
        }
        refreshDTDLF()
    })
}

function componentsRow(dtdlObj,parentDOM,refreshDTDLF){
    var rowDOM=$('<div class="w3-bar"><div class="w3-bar-item  w3-tooltip" style="font-size:1.2em;padding-left:2px;font-weight:bold;color:gray">Components<p style="position:absolute;text-align:left;top:-10px;font-weight:normal;width:200px" class="w3-text w3-tag w3-tiny">Component model\'s parameters are embedded under a name</p></div></div>')

    var addButton = $('<button class="w3-ripple w3-bar-item w3-button w3-red w3-hover-amber" style="margin-top:2px;font-size:1.2em;padding:4px 8px">+</button>')
    rowDOM.append(addButton)
    parentDOM.append(rowDOM)
    var contentDOM=$('<div style="padding-left:10px"></div>')
    rowDOM.append(contentDOM)

    addButton.on("click",()=>{
        var newObj = {
            "@type": "Component",
            "name": "SomeComponent",
            "schema":"dtmi:someComponentModel;1"
        }
        dtdlObj.push(newObj)
        new singleComponentRow(newObj,contentDOM,refreshDTDLF,dtdlObj)
        refreshDTDLF()
    })
    //check existed content initially from template and trigger their drawing
    dtdlObj.forEach(element => {
        if(element["@type"]!="Component") return
        new singleComponentRow(element,contentDOM,refreshDTDLF,dtdlObj)
    });
}

function singleComponentRow(dtdlObj,parentDOM,refreshDTDLF,parentDtdlObj){
    var DOM = $('<div class="w3-cell-row"></div>')
    var componentNameInput=$('<input type="text" style="outline:none;display:inline;width:100px;padding:4px"  placeholder="component name"/>').addClass("w3-bar-item w3-input w3-border");
    var schemaInput=$('<input type="text" style="outline:none;display:inline;width:160px;padding:4px"  placeholder="component model id..."/>').addClass("w3-bar-item w3-input w3-border");
    var removeButton = $('<button class="w3-bar-item w3-button w3-hover-amber" style="color:gray;margin-left:3px;margin-top:2px;font-size:1.2em;padding:2px"><i class="fa fa-trash fa-lg"></i></button>')
    DOM.append(componentNameInput,schemaInput,removeButton)

    removeButton.on("click",()=>{
        for (var i =0;i< parentDtdlObj.length; i++) {
            if (parentDtdlObj[i] === dtdlObj) {
                parentDtdlObj.splice(i, 1);
                break;
            }
        }
        DOM.remove()
        refreshDTDLF()
    })

    parentDOM.append(DOM)

    componentNameInput.val(dtdlObj["name"])
    schemaInput.val(dtdlObj["schema"]||"")

    componentNameInput.on("change",()=>{
        dtdlObj["name"]=componentNameInput.val()
        refreshDTDLF()
    })
    schemaInput.on("change",()=>{
        dtdlObj["schema"]=schemaInput.val()
        refreshDTDLF()
    })
}

function relationsRow(dtdlObj,parentDOM,refreshDTDLF,dialogOffset){
    var rowDOM=$('<div class="w3-bar"><div class="w3-bar-item w3-tooltip" style="font-size:1.2em;padding-left:2px;font-weight:bold;color:gray">Relationship Types<p style="position:absolute;text-align:left;top:-10px;font-weight:normal;width:200px" class="w3-text w3-tag w3-tiny">Relationship can have its own parameters</p></div></div>')


    var addButton = $('<button class="w3-ripple w3-bar-item w3-button w3-red w3-hover-amber" style="margin-top:2px;font-size:1.2em;padding:4px 8px">+</button>')
    rowDOM.append(addButton)
    parentDOM.append(rowDOM)
    var contentDOM=$('<div style="padding-left:10px"></div>')
    rowDOM.append(contentDOM)

    addButton.on("click",()=>{
        var newObj = {
            "@type": "Relationship",
            "name": "relation1",
        }
        dtdlObj.push(newObj)
        new singleRelationTypeRow(newObj,contentDOM,refreshDTDLF,dtdlObj,dialogOffset)
        refreshDTDLF()
    })

    //check existed content initially from template and trigger their drawing
    dtdlObj.forEach(element => {
        if(element["@type"]!="Relationship") return
        new singleRelationTypeRow(element,contentDOM,refreshDTDLF,dtdlObj,dialogOffset)
    });
}

function singleRelationTypeRow(dtdlObj,parentDOM,refreshDTDLF,parentDtdlObj,dialogOffset){
    var DOM = $('<div class="w3-cell-row"></div>')
    var relationNameInput=$('<input type="text" style="outline:none;display:inline;width:90px;padding:4px"  placeholder="relation name"/>').addClass("w3-bar-item w3-input w3-border");
    var targetModelID=$('<input type="text" style="outline:none;display:inline;width:140px;padding:4px"  placeholder="(optional)target model"/>').addClass("w3-bar-item w3-input w3-border");
    var addButton = $('<button class="w3-ripple w3-bar-item w3-button w3-hover-amber" style="color:gray;margin-left:3px;margin-top:2px;font-size:1.2em;padding:2px"><i class="fa fa-cog fa-lg"></i></button>')
    var removeButton = $('<button class="w3-bar-item w3-button w3-hover-amber" style="color:gray;margin-left:3px;margin-top:2px;font-size:1.2em;padding:2px"><i class="fa fa-trash fa-lg"></i></button>')
    DOM.append(relationNameInput,targetModelID,addButton,removeButton)

    removeButton.on("click",()=>{
        for (var i =0;i< parentDtdlObj.length; i++) {
            if (parentDtdlObj[i] === dtdlObj) {
                parentDtdlObj.splice(i, 1);
                break;
            }
        }
        DOM.remove()
        refreshDTDLF()
    })

    var contentDOM=$('<div style="padding-left:10px"></div>')
    DOM.append(contentDOM)
    parentDOM.append(DOM)

    relationNameInput.val(dtdlObj["name"])
    targetModelID.val(dtdlObj["target"]||"")

    addButton.on("click",()=>{
        if(! dtdlObj["properties"]) dtdlObj["properties"]=[]
        var newObj = {
            "name": "newP",
            "schema": "double"
        }
        dtdlObj["properties"].push(newObj)
        new singleParameterRow(newObj,contentDOM,refreshDTDLF,dtdlObj["properties"],null,dialogOffset)
        refreshDTDLF()
    })

    relationNameInput.on("change",()=>{
        dtdlObj["name"]=relationNameInput.val()
        refreshDTDLF()
    })
    targetModelID.on("change",()=>{
        if(targetModelID.val()=="") delete dtdlObj["target"]
        else dtdlObj["target"]=targetModelID.val()
        refreshDTDLF()
    })
    if(dtdlObj["properties"] && dtdlObj["properties"].length>0){
        var properties=dtdlObj["properties"]
        properties.forEach(oneProperty=>{
            new singleParameterRow(oneProperty,contentDOM,refreshDTDLF,dtdlObj["properties"],null,dialogOffset)
        })
    }
}

function parametersRow(dtdlObj,parentDOM,refreshDTDLF,dialogOffset){
    var rowDOM=$('<div class="w3-bar"><div class="w3-bar-item" style="font-size:1.2em;padding-left:2px;font-weight:bold;color:gray">Parameters</div></div>')
    var addButton = $('<button class="w3-ripple w3-bar-item w3-button w3-red w3-hover-amber" style="margin-top:2px;font-size:1.2em;padding:4px 8px">+</button>')
    rowDOM.append(addButton)
    parentDOM.append(rowDOM)
    var contentDOM=$('<div style="padding-left:10px"></div>')
    rowDOM.append(contentDOM)
    addButton.on("click",()=>{
        var newObj = {
            "@type": "Property",
            "name": "newP",
            "schema": "double"
        }
        dtdlObj.push(newObj)
        new singleParameterRow(newObj,contentDOM,refreshDTDLF,dtdlObj,"topLevel",dialogOffset)
        refreshDTDLF()
    })

    //check existed content initially from template and trigger their drawing
    dtdlObj.forEach(element => {
        if(element["@type"]!="Property") return
        new singleParameterRow(element,contentDOM,refreshDTDLF,dtdlObj,"topLevel",dialogOffset)
    });
}

function singleParameterRow(dtdlObj,parentDOM,refreshDTDLF,parentDtdlObj,topLevel,dialogOffset){
    var DOM = $('<div class="w3-cell-row"></div>')
    var parameterNameInput=$('<input type="text" style="outline:none;display:inline;width:100px;padding:4px"  placeholder="parameter name"/>').addClass("w3-bar-item w3-input w3-border");
    var enumValueInput=$('<input type="text" style="outline:none;display:inline;width:100px;padding:4px"  placeholder="str1,str2,..."/>').addClass("w3-bar-item w3-input w3-border");
    var addButton = $('<button class="w3-ripple w3-bar-item w3-button w3-hover-amber" style="color:gray;margin-left:3px;margin-top:2px;font-size:1.2em;padding:2px"><i class="fa fa-plus fa-lg"></i></button>')
    var removeButton = $('<button class="w3-bar-item w3-button w3-hover-amber" style="color:gray;margin-left:3px;margin-top:2px;font-size:1.2em;padding:2px"><i class="fa fa-trash fa-lg"></i></button>')
    var ptypeSelector=new simpleSelectMenu(" ",{withBorder:1,fontSize:"1em",colorClass:"w3-light-gray w3-bar-item",buttonCSS:{"padding":"4px 5px"},"optionListHeight":300,"isClickable":1,"optionListMarginTop":-150,"optionListMarginLeft":60,
    "adjustPositionAnchor":dialogOffset})
    ptypeSelector.addOptionArr(["string","float","integer","Enum","Object","double","boolean","date","dateTime","duration","long","time"])
    DOM.append(parameterNameInput,ptypeSelector.DOM,enumValueInput,addButton,removeButton)

    removeButton.on("click",()=>{
        for (var i =0;i< parentDtdlObj.length; i++) {
            if (parentDtdlObj[i] === dtdlObj) {
                parentDtdlObj.splice(i, 1);
                break;
            }
        }
        DOM.remove()
        refreshDTDLF()
    })
    
    var contentDOM=$('<div style="padding-left:10px"></div>')
    DOM.append(contentDOM)
    parentDOM.append(DOM)

    parameterNameInput.val(dtdlObj["name"])
    ptypeSelector.callBack_clickOption=(optionText,optionValue,realMouseClick)=>{
        ptypeSelector.changeName(optionText)
        contentDOM.empty()//clear all content dom content
        if(realMouseClick){
            for(var ind in dtdlObj) delete dtdlObj[ind]    //clear all object content
            if(topLevel) dtdlObj["@type"]="Property"
            dtdlObj["name"]=parameterNameInput.val()
        } 
        if(optionText=="Enum"){
            enumValueInput.val("")
            enumValueInput.show();
            addButton.hide()
            if(realMouseClick) dtdlObj["schema"]={"@type": "Enum","valueSchema": "string"}
        }else if(optionText=="Object"){
            enumValueInput.hide();
            addButton.show()
            if(realMouseClick) dtdlObj["schema"]={"@type": "Object"}
        }else{
            if(realMouseClick) dtdlObj["schema"]=optionText
            enumValueInput.hide();
            addButton.hide()
        }
        refreshDTDLF()
    }
    addButton.on("click",()=>{
        if(! dtdlObj["schema"]["fields"]) dtdlObj["schema"]["fields"]=[]
        var newObj = {
            "name": "newP",
            "schema": "double"
        }
        dtdlObj["schema"]["fields"].push(newObj)
        new singleParameterRow(newObj,contentDOM,refreshDTDLF,dtdlObj["schema"]["fields"],null,dialogOffset)
        refreshDTDLF()
    })

    parameterNameInput.on("change",()=>{
        dtdlObj["name"]=parameterNameInput.val()
        refreshDTDLF()
    })
    enumValueInput.on("change",()=>{
        var valueArr=enumValueInput.val().split(",")
        dtdlObj["schema"]["enumValues"]=[]
        valueArr.forEach(aVal=>{
            dtdlObj["schema"]["enumValues"].push({
                "name": aVal.replace(" ",""), //remove all the space in name
                "enumValue": aVal
              })
        })
        refreshDTDLF()
    })
    if(typeof(dtdlObj["schema"]) != 'object') var schema=dtdlObj["schema"]
    else schema=dtdlObj["schema"]["@type"]
    ptypeSelector.triggerOptionValue(schema)
    if(schema=="Enum"){
        var enumArr=dtdlObj["schema"]["enumValues"]
        if(enumArr!=null){
            var inputStr=""
            enumArr.forEach(oneEnumValue=>{inputStr+=oneEnumValue.enumValue+","})
            inputStr=inputStr.slice(0, -1)//remove the last ","
            enumValueInput.val(inputStr)
        }
    }else if(schema=="Object"){
        var fields=dtdlObj["schema"]["fields"]
        fields.forEach(oneField=>{
            new singleParameterRow(oneField,contentDOM,refreshDTDLF,dtdlObj["schema"]["fields"],null,dialogOffset)
        })
    }
}


function idRow(dtdlObj,parentDOM,refreshDTDLF){
    var DOM = $('<div class="w3-cell-row"></div>')
    var label1=$('<div class="w3-opacity" style="display:inline">dtmi:</div>')
    var domainInput=$('<input type="text" style="outline:none;display:inline;width:88px;padding:4px"  placeholder="Namespace"/>').addClass("w3-input w3-border");
    var modelIDInput=$('<input type="text" style="outline:none;display:inline;width:132px;padding:4px"  placeholder="ModelID"/>').addClass("w3-input w3-border");
    var versionInput=$('<input type="text" style="outline:none;display:inline;width:60px;padding:4px"  placeholder="version"/>').addClass("w3-input w3-border");
    DOM.append(label1,domainInput,$('<div class="w3-opacity" style="display:inline">:</div>'),modelIDInput,$('<div class="w3-opacity" style="display:inline">;</div>'),versionInput)
    parentDOM.append(DOM)

    var valueChange=()=>{
        var str=`dtmi:${domainInput.val()}:${modelIDInput.val()};${versionInput.val()}`
        dtdlObj["@id"]=str
        refreshDTDLF()
    }
    domainInput.on("change",valueChange)
    modelIDInput.on("change",valueChange)
    versionInput.on("change",valueChange)

    var str=dtdlObj["@id"]
    if(str!="" && str!=null){
        var arr1=str.split(";")
        if(arr1.length!=2) return;
        versionInput.val(arr1[1])
        var arr2=arr1[0].split(":")
        domainInput.val(arr2[1])
        arr2.shift(); arr2.shift()
        modelIDInput.val(arr2.join(":"))
    }
}

function displayNameRow(dtdlObj,parentDOM,refreshDTDLF){
    var DOM = $('<div class="w3-cell-row"></div>')
    var label1=$('<div class="w3-opacity" style="display:inline">Display Name:</div>')
    var nameInput=$('<input type="text" style="outline:none;display:inline;width:150px;padding:4px"  placeholder="ModelID"/>').addClass("w3-input w3-border");
    DOM.append(label1,nameInput)
    parentDOM.append(DOM)
    var valueChange=()=>{
        dtdlObj["displayName"]=nameInput.val()
        refreshDTDLF()
    }
    nameInput.on("change",valueChange)
    var str=dtdlObj["displayName"]
    if(str!="" && str!=null) nameInput.val(str)
}
},{"../msalHelper":12,"./globalCache":15,"./modelAnalyzer":16,"./simpleConfirmDialog":23,"./simpleSelectMenu":25}],18:[function(require,module,exports){
const modelAnalyzer=require("./modelAnalyzer")
const simpleTree= require("./simpleTree")
const simpleConfirmDialog = require("./simpleConfirmDialog")
const modelEditorDialog = require("./modelEditorDialog")
const globalCache = require("./globalCache")
const msalHelper=require("../msalHelper")
const simpleExpandableSection= require("../sharedSourceFiles/simpleExpandableSection")

function modelManagerDialog() {
    if(!this.DOM){
        this.DOM = $('<div style="position:absolute;top:50%;background-color:white;left:50%;transform: translateX(-50%) translateY(-50%);z-index:99" class="w3-card-2"></div>')
        this.DOM.css("overflow","hidden")
        $("body").append(this.DOM)
        this.DOM.hide()
        globalCache.makeDOMDraggable(this.DOM)
    }
    this.showRelationVisualizationSettings=true;
}

modelManagerDialog.prototype.popup = async function() {
    this.DOM.show()
    this.DOM.empty()
    this.contentDOM = $('<div style="width:700px"></div>')
    this.DOM.append(this.contentDOM)
    this.contentDOM.append($('<div style="height:40px" class="w3-bar w3-red"><div class="w3-bar-item" style="font-size:1.5em">Digital Twin Models</div></div>'))
    var closeButton = $('<button class="w3-bar-item w3-button w3-right" style="font-size:2em;padding-top:4px"></button>')
    this.contentDOM.children(':first').append(closeButton)
    closeButton.on("click", () => { this.DOM.hide() })

    var importModelsBtn = $('<button class="w3-button w3-card w3-deep-orange w3-hover-light-green" style="height:100%">Import</button>')
    var actualImportModelsBtn =$('<input type="file" name="modelFiles" multiple="multiple" style="display:none"></input>')
    var modelEditorBtn = $('<button class="w3-button w3-card w3-deep-orange w3-hover-light-green" style="height:100%">Create/Modify Model</button>')
    var exportModelBtn = $('<button class="w3-ripple w3-button w3-card w3-deep-orange w3-hover-light-green" style="height:100%">Export All Models</button>')
    this.contentDOM.children(':first').append(importModelsBtn,actualImportModelsBtn, modelEditorBtn,exportModelBtn)
    importModelsBtn.on("click", ()=>{
        actualImportModelsBtn.trigger('click');
    });
    actualImportModelsBtn.change(async (evt)=>{
        var files = evt.target.files; // FileList object
        await this.readModelFilesContentAndImport(files)
        actualImportModelsBtn.val("")
    })
    modelEditorBtn.on("click",()=>{
        modelEditorDialog.popup()
    })
    exportModelBtn.on("click", () => {
        var modelArr=[]
        for(var modelID in modelAnalyzer.DTDLModels) modelArr.push(JSON.parse(modelAnalyzer.DTDLModels[modelID]["original"]))
        var pom = $("<a></a>")
        pom.attr('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(JSON.stringify(modelArr)));
        pom.attr('download', "exportModels.json");
        pom[0].click()
    })

    var row2=$('<div class="w3-cell-row" style="margin-top:2px"></div>')
    this.contentDOM.append(row2)
    var leftSpan=$('<div class="w3-cell" style="width:240px;padding-right:5px"></div>')
    row2.append(leftSpan)
    leftSpan.append($('<div style="height:30px" class="w3-bar w3-red"><div class="w3-bar-item" style="">Models</div></div>'))
    
    var modelList = $('<ul class="w3-ul w3-hoverable">')
    modelList.css({"overflow-x":"hidden","overflow-y":"auto","height":"420px", "border":"solid 1px lightgray"})
    leftSpan.append(modelList)
    this.modelList = modelList;
    
    var rightSpan=$('<div class="w3-container w3-cell" style="padding:0px"></div>')
    row2.append(rightSpan) 
    var panelCardOut=$('<div class="w3-card-2 w3-white" style="margin-top:2px"></div>')

    this.modelButtonBar=$('<div class="w3-bar" style="height:35px"></div>')
    panelCardOut.append(this.modelButtonBar)

    rightSpan.append(panelCardOut)
    var panelCard=$('<div style="width:460px;height:412px;overflow:auto;margin-top:2px"></div>')
    panelCardOut.append(panelCard)
    this.panelCard=panelCard;

    this.modelButtonBar.empty()
    panelCard.html("<a style='display:block;font-style:italic;color:gray;padding-left:5px'>Choose a model to view infomration</a>")

    this.listModels()
}

modelManagerDialog.prototype.resizeImgFile = async function(theFile,max_size) {
    return new Promise((resolve, reject) => {
        try {
            var reader = new FileReader();
            var tmpImg = new Image();
            reader.onload = () => {
                tmpImg.onload =  ()=> {
                    var canvas = document.createElement('canvas')
                    var width = tmpImg.width
                    var height = tmpImg.height;
                    if (width > height) {
                        if (width > max_size) {
                            height *= max_size / width;
                            width = max_size;
                        }
                    } else {
                        if (height > max_size) {
                            width *= max_size / height;
                            height = max_size;
                        }
                    }
                    canvas.width = width;
                    canvas.height = height;
                    canvas.getContext('2d').drawImage(tmpImg, 0, 0, width, height);
                    var dataUrl = canvas.toDataURL('image/png');
                    resolve(dataUrl)
                }
                tmpImg.src = reader.result;
            }
            reader.readAsDataURL(theFile);
        } catch (e) {
            reject(e)
        }
    })
}

modelManagerDialog.prototype.fillRightSpan=async function(modelID){
    this.panelCard.empty()
    this.modelButtonBar.empty()

    var delBtn = $('<button style="margin-bottom:2px" class="w3-ripple w3-button w3-light-gray w3-hover-pink w3-border-right">Delete Model</button>')
    this.modelButtonBar.append(delBtn)


    var importPicBtn = $('<button class="w3-button w3-light-gray w3-hover-amber w3-border-right">Upload Avarta</button>')
    var actualImportPicBtn = $('<input type="file" name="img" style="display:none"></input>')
    var chooseAvartaBtn = $('<button class="w3-ripple w3-button w3-light-gray w3-hover-pink w3-border-right">Choose A Symbol</button>')
    
    var clearAvartaBtn = $('<button class="w3-ripple w3-button w3-light-gray w3-hover-pink w3-border-right">Clear Avarta</button>')
    this.modelButtonBar.append(importPicBtn, actualImportPicBtn,chooseAvartaBtn, clearAvartaBtn)
    importPicBtn.on("click", () => {
        actualImportPicBtn.trigger('click');
    });

    actualImportPicBtn.change(async (evt) => {
        var files = evt.target.files; // FileList object
        var theFile = files[0]

        if (theFile.type == "image/svg+xml") {
            var str = await this.readOneFile(theFile)
            var dataUrl = 'data:image/svg+xml;utf8,' + encodeURIComponent(str);
        } else if (theFile.type.match('image.*')) {
            var dataUrl = await this.resizeImgFile(theFile, 256)
        } else {
            var confirmDialogDiv = new simpleConfirmDialog()
            confirmDialogDiv.show({ width: "200px" },
                {
                    title: "Note"
                    , content: "Please import image file (png,jpg,svg and so on)"
                    , buttons: [{ colorClass: "w3-gray", text: "Ok", "clickFunc": () => { confirmDialogDiv.close() } }]
                }
            )
        }
        this.updateAvartaDataUrl(dataUrl,modelID)
        actualImportPicBtn.val("")
    })

    chooseAvartaBtn.on("click",()=>{this.chooseAvarta(modelID)})

    clearAvartaBtn.on("click", () => {
        this.updateAvartaDataUrl(null,modelID)
    });

    
    delBtn.on("click",()=>{
        var relatedModelIDs =modelAnalyzer.listModelsForDeleteModel(modelID)
        var dialogStr=(relatedModelIDs.length==0)? ("This will DELETE model \"" + modelID + "\"."): 
            (modelID + " is base model of "+relatedModelIDs.join(", ")+".")
        var confirmDialogDiv = new simpleConfirmDialog()

        //check how many twins are under this model ID
        var numberOfTwins=0
        var checkTwinsModelArr=[modelID].concat(relatedModelIDs)
        for(var oneTwinID in globalCache.DBTwins){
            var oneDBTwin = globalCache.DBTwins[oneTwinID]
            var theIndex=checkTwinsModelArr.indexOf(oneDBTwin["modelID"])
            if(theIndex!=-1) numberOfTwins++
        }

        dialogStr+=" (There will be "+((numberOfTwins>1)?(numberOfTwins+" twins"):(numberOfTwins+" twin") ) + " being impacted)"
        confirmDialogDiv.show(
            { width: "350px" },
            {
                title: "Warning"
                , content: dialogStr
                , buttons: [
                    {
                        colorClass: "w3-red w3-hover-pink", text: "Confirm", "clickFunc": async () => {
                            confirmDialogDiv.close();
                            this.confirmDeleteModel(modelID) 
                        }
                    },
                    {
                        colorClass: "w3-gray", text: "Cancel", "clickFunc": () => {
                            confirmDialogDiv.close()
                        }
                    }
                ]
            }
        )
        
    })
    
    var VisualizationDOM=this.addAPartInRightSpan("Visualization",{"marginTop":0}) 
    var editablePropertiesDOM=this.addAPartInRightSpan("Editable Properties And Relationships")
    var baseClassesDOM=this.addAPartInRightSpan("Base Classes")
    var originalDefinitionDOM=this.addAPartInRightSpan("Original Definition")

    var str=JSON.stringify(JSON.parse(modelAnalyzer.DTDLModels[modelID]["original"]),null,2)
    originalDefinitionDOM.append($('<pre id="json">'+str+'</pre>'))

    var edittableProperties=modelAnalyzer.DTDLModels[modelID].editableProperties
    this.fillEditableProperties(edittableProperties,editablePropertiesDOM)
    var validRelationships=modelAnalyzer.DTDLModels[modelID].validRelationships
    this.fillRelationshipInfo(validRelationships,editablePropertiesDOM)

    this.fillVisualization(modelID,VisualizationDOM)

    this.fillBaseClasses(modelAnalyzer.DTDLModels[modelID].allBaseClasses,baseClassesDOM) 
}

modelManagerDialog.prototype.updateAvartaDataUrl = function (dataUrl,modelID) {
    if (!dataUrl){
        var visualJson = globalCache.visualDefinition["default"].detail
        if (visualJson[modelID]){
            delete visualJson[modelID].avarta
            delete visualJson[modelID].avartaWidth
            delete visualJson[modelID].avartaHeight
        } 
        if (this.avartaImg) this.avartaImg.removeAttr('src');
        this.saveVisualDefinition()
        this.broadcastMessage({ "message": "visualDefinitionChange", "modelID": modelID, "noAvarta": true })
        this.refreshModelTreeLabel()
        return;
    } 
    
    //if it is svg, check if the svg set its width and height attribute, as cytoscape js can not handle svg scaling withouth width and heigh attribute
    var dec= decodeURIComponent(dataUrl)
    if(dec.startsWith("data:image/svg+xml")){
        var pos=dec.indexOf("<svg ")
        var svgPart=dec.substr(pos)
        var tmpObj=$(svgPart)
        if(tmpObj.attr('width')==null){
            var ss=tmpObj.attr('viewBox')
            if(ss){
                var arr=ss.split(" ")
                tmpObj.attr("width",arr[2]-arr[0])
                tmpObj.attr("height",arr[3]-arr[1])
                dataUrl=`data:image/svg+xml;utf8,${encodeURIComponent(tmpObj[0].outerHTML)}`
            }
        }
    }

    if (this.avartaImg) this.avartaImg.attr("src", dataUrl)

    var visualJson = globalCache.visualDefinition["default"].detail //currently there is only one visual definition: "default"
    if (!visualJson[modelID]) visualJson[modelID] = {}
    visualJson[modelID].avarta = dataUrl
    
    var testImg = $(`<img src="${dataUrl}"/>`)
    testImg.on('load', ()=>{
        testImg.css({"display":"none"}) //to get the image size, append it to body temporarily
        $('body').append(testImg)
        visualJson[modelID].avartaWidth=testImg.width()
        visualJson[modelID].avartaHeight=testImg.height()
        testImg.remove()
        this.saveVisualDefinition()
        this.broadcastMessage({ "message": "visualDefinitionChange", "modelID": modelID, "avarta": dataUrl })
        this.refreshModelTreeLabel()
    });
}

modelManagerDialog.prototype.chooseAvarta=function(modelID){
    var popWindow=new simpleConfirmDialog()
    popWindow.show({"max-width":"450px","min-width":"300px"},{
        "title":"Choose Symbol as Avarta",
        "customDrawing":(parentDOM)=>{
            for(var ind in globalCache.symbolLibs) var symbolList=globalCache.symbolLibs[ind] //TODO:multiple libs
            for(var symbolName in symbolList){
                this.createSymbolDOM(ind,symbolName,modelID,parentDOM,popWindow)
            }
        }
    })
}

modelManagerDialog.prototype.createSymbolDOM=function(libName,symbolName,modelID,parentDOM,popWindow){
    var symbolSize=80
    var symbolList=globalCache.symbolLibs[libName]
    var aSymbolDOM=$("<div class='w3-button w3-white' style='padding:0px;width:"+symbolSize+"px;height:"+symbolSize+"px;float:left'></div>")
    var svgStr=symbolList[symbolName].replaceAll("'",'"')
    var dataUrl=`data:image/svg+xml;utf8,${encodeURIComponent(svgStr)}`
    var svgImg=$(`<img style='max-width:${symbolSize}px;max-height:${symbolSize}px' src='${dataUrl}'></img>`)
    aSymbolDOM.append(svgImg)
    parentDOM.append(aSymbolDOM)
    aSymbolDOM.on("click",()=>{
        popWindow.close()
        this.updateAvartaDataUrl(dataUrl,modelID)
    })
}

modelManagerDialog.prototype.confirmDeleteModel=function(modelID){
    var funcAfterEachSuccessDelete = (eachDeletedModelID) => {
        this.tree.deleteLeafNode(globalCache.modelIDMapToName[eachDeletedModelID])
        //TODO: clear the visualization setting of this deleted model, but if it is replace, should not, so I comment out first
        /*
        if (globalCache.visualDefinition["default"].detail[modelID]) {
            delete globalCache.visualDefinition["default"].detail[modelID]
            this.saveVisualDefinition()
        }*/
    }
    var completeFunc=()=>{ 
        this.broadcastMessage({ "message": "ADTModelsChange"})
        this.panelCard.empty()
    }

    //even not completely successful deleting, it will still invoke completeFunc
    modelAnalyzer.deleteModel(modelID,funcAfterEachSuccessDelete,completeFunc,completeFunc)
}

modelManagerDialog.prototype.refreshModelTreeLabel=function(){
    if(this.tree.selectedNodes.length>0) this.tree.selectedNodes[0].redrawLabel()
}

modelManagerDialog.prototype.fillBaseClasses=function(baseClasses,parentDom){
    for(var ind in baseClasses){
        var keyDiv= $("<label style='display:block;padding:.1em'>"+ind+"</label>")
        parentDom.append(keyDiv)
    }
}

modelManagerDialog.prototype.fillVisualization=function(modelID,parentDom){
    var modelJson=modelAnalyzer.DTDLModels[modelID];
    var aTable=$("<table style='width:100%'></table>")
    aTable.html('<tr><td></td><td align="center"></td></tr>')
    parentDom.append(aTable) 

    var leftPart=aTable.find("td:first")
    var rightPart=aTable.find("td:nth-child(2)")
    rightPart.css({"width":"50px","height":"50px","border":"solid 1px lightGray"})
    
    var avartaImg=$("<img style='height:45px'></img>")
    rightPart.append(avartaImg)
    var visualJson=globalCache.visualDefinition["default"].detail
    if(visualJson && visualJson[modelID] && visualJson[modelID].avarta) avartaImg.attr('src',visualJson[modelID].avarta)
    this.avartaImg=avartaImg;
    this.addOneVisualizationRow(modelID,leftPart)

    if(this.showRelationVisualizationSettings){
        for(var ind in modelJson.validRelationships){
            this.addOneVisualizationRow(modelID,leftPart,ind)
        }
    }
    this.addLabelVisualizationRow(modelID,leftPart)
}

modelManagerDialog.prototype.addLabelVisualizationRow=function(modelID,parentDom){
    var containerDiv=$("<div style='padding-bottom:8px'></div>")
    parentDom.append(containerDiv)
    var contentDOM=$("<label class='w3-text-gray' style='margin-right:10px;font-style:italic; font-weight:bold;font-size:0.9em'>Position Label</label>")
    containerDiv.append(contentDOM)
    var definedLblX=0
    var definedLblY=0
    var visualJson=globalCache.visualDefinition["default"].detail
    if(visualJson[modelID] && visualJson[modelID].labelX) definedLblX=visualJson[modelID].labelX
    if(visualJson[modelID] && visualJson[modelID].labelY) definedLblY=visualJson[modelID].labelY
    var lblXAdjustSelector = $('<select class="w3-border" style="outline:none;width:110px"></select>')
    for(var f=-25;f<=30;f+=5){
        var val=f.toFixed(0)+""
        lblXAdjustSelector.append($("<option value="+val+">xoff:"+val+"</option>"))
    }
    if(definedLblX!=null) lblXAdjustSelector.val(definedLblX)
    else lblXAdjustSelector.val("0")
    containerDiv.append(lblXAdjustSelector)
    var lblYAdjustSelector = $('<select class="w3-border" style="outline:none;width:110px"></select>')
    for(var f=-25;f<=30;f+=5){
        var val=f.toFixed(0)+""
        lblYAdjustSelector.append($("<option value="+val+">yoff:"+val+"</option>"))
    }
    if(definedLblY!=null) lblYAdjustSelector.val(definedLblY)
    else lblYAdjustSelector.val("0")
    containerDiv.append(lblYAdjustSelector)

    lblXAdjustSelector.change((eve)=>{
        var chooseVal=eve.target.value
        this.modifyLblOffset("labelX",chooseVal,modelID)
    })
    lblYAdjustSelector.change((eve)=>{
        var chooseVal=eve.target.value
        this.modifyLblOffset("labelY",chooseVal,modelID)
    })
}

modelManagerDialog.prototype.modifyLblOffset = function (XY, val,modelID) {
    var visualJson = globalCache.visualDefinition["default"].detail
    if (!visualJson[modelID]) visualJson[modelID] = {}
    visualJson[modelID][XY] = val
    this.broadcastMessage({ "message": "visualDefinitionChange", "modelID": modelID, "labelPosition":true })
    this.saveVisualDefinition()
}

modelManagerDialog.prototype.addOneVisualizationRow=function(modelID,parentDom,relatinshipName){
    if(relatinshipName==null) var nameStr="" //visual for node
    else nameStr=" "+relatinshipName
    var containerDiv=$("<div style='padding-bottom:8px'></div>")
    parentDom.append(containerDiv)
    var contentDOM=$("<label class='w3-text-gray' style='margin-right:10px;font-weight:bold;font-size:0.9em'>"+nameStr+"</label>")
    containerDiv.append(contentDOM)

    var definedColor=null
    var definedColor2=null
    var definedShape=null
    var definedDimensionRatio=null
    var definedEdgeWidth=null
    var visualJson=globalCache.visualDefinition["default"].detail
    if(relatinshipName==null){
        if(visualJson[modelID] && visualJson[modelID].color) definedColor=visualJson[modelID].color
        if(visualJson[modelID] && visualJson[modelID].secondColor) definedColor2=visualJson[modelID].secondColor
        if(visualJson[modelID] && visualJson[modelID].shape) definedShape=visualJson[modelID].shape
        if(visualJson[modelID] && visualJson[modelID].dimensionRatio) definedDimensionRatio=visualJson[modelID].dimensionRatio
    }else{
        if (visualJson[modelID] && visualJson[modelID]["rels"] && visualJson[modelID]["rels"][relatinshipName]) {
            if (visualJson[modelID]["rels"][relatinshipName].color) definedColor = visualJson[modelID]["rels"][relatinshipName].color
            if (visualJson[modelID]["rels"][relatinshipName].shape) definedShape = visualJson[modelID]["rels"][relatinshipName].shape
            if(visualJson[modelID]["rels"][relatinshipName].edgeWidth) definedEdgeWidth=visualJson[modelID]["rels"][relatinshipName].edgeWidth
        }
    }

    var createAColorSelector=(predefinedColor,nameOfColorField)=>{
        var colorSelector=$('<select class="w3-border" style="outline:none;width:75px"></select>')
        containerDiv.append(colorSelector)

        var colorArr=["darkGray","Black","LightGray","Red","Green","Blue","Bisque","Brown","Coral","Crimson","DodgerBlue","Gold"]
        colorArr.forEach((oneColorCode)=>{
            var anOption=$("<option value='"+oneColorCode+"'>"+oneColorCode+"</option>")
            colorSelector.append(anOption)
            anOption.css("color",oneColorCode)
        })

        if(relatinshipName==null){
            var anOption=$("<option value='none'>none</option>")
            anOption.css("color","darkGray")
            colorSelector.append(anOption)
        }

        if(nameOfColorField=="secondColor"){
            if(predefinedColor==null) predefinedColor="none"
        }else{
            if(predefinedColor==null) predefinedColor="darkGray"
        }

        colorSelector.val(predefinedColor)
        if(predefinedColor!="none") {
            colorSelector.css("color",predefinedColor)
        }else{
            colorSelector.css("color","darkGray")
        }
        
        colorSelector.change((eve)=>{
            var selectColorCode=eve.target.value
            if(selectColorCode=="none") colorSelector.css("color","darkGray")
            else colorSelector.css("color",selectColorCode)
            var visualJson=globalCache.visualDefinition["default"].detail
    
            if(!visualJson[modelID]) visualJson[modelID]={}
            if(!relatinshipName) {
                if(selectColorCode=="none" && nameOfColorField=="secondColor") delete visualJson[modelID]["secondColor"]
                else visualJson[modelID][nameOfColorField]=selectColorCode
                this.broadcastMessage({ "message": "visualDefinitionChange", "modelID":modelID
                    ,"color":visualJson[modelID]["color"],"secondColor":visualJson[modelID]["secondColor"] })
                this.refreshModelTreeLabel()
            }else{
                if(!visualJson[modelID]["rels"]) visualJson[modelID]["rels"]={}
                if(!visualJson[modelID]["rels"][relatinshipName]) visualJson[modelID]["rels"][relatinshipName]={}
                visualJson[modelID]["rels"][relatinshipName].color=selectColorCode
                this.broadcastMessage({ "message": "visualDefinitionChange", "srcModelID":modelID,"relationshipName":relatinshipName,"color":selectColorCode })
            }
            this.saveVisualDefinition()
        })
    }

    createAColorSelector(definedColor,"color")
    if(relatinshipName==null) createAColorSelector(definedColor2,"secondColor")


    var shapeSelector = $('<select class="w3-border" style="outline:none"></select>')
    containerDiv.append(shapeSelector)
    if(relatinshipName==null){
        shapeSelector.append($("<option value='ellipse'></option>"))
        shapeSelector.append($("<option value='rectangle' style='font-size:120%'></option>"))
        shapeSelector.append($("<option value='hexagon' style='font-size:130%'></option>"))
    }else{
        shapeSelector.append($("<option value='solid'></option>"))
        shapeSelector.append($("<option value='dotted'></option>"))
    }
    if(definedShape!=null) {
        shapeSelector.val(definedShape)
    }
    shapeSelector.change((eve)=>{
        var selectShape=eve.target.value
        var visualJson = globalCache.visualDefinition["default"].detail

        if(!visualJson[modelID]) visualJson[modelID]={}
        if(!relatinshipName) {
            visualJson[modelID].shape=selectShape
            this.broadcastMessage({ "message": "visualDefinitionChange", "modelID":modelID,"shape":selectShape })
            this.refreshModelTreeLabel()
        }else{
            if(!visualJson[modelID]["rels"]) visualJson[modelID]["rels"]={}
            if(!visualJson[modelID]["rels"][relatinshipName]) visualJson[modelID]["rels"][relatinshipName]={}
            visualJson[modelID]["rels"][relatinshipName].shape=selectShape
            this.broadcastMessage({ "message": "visualDefinitionChange", "srcModelID":modelID,"relationshipName":relatinshipName,"shape":selectShape })
        }
        this.saveVisualDefinition()
    })

    var sizeAdjustSelector = $('<select class="w3-border" style="outline:none;width:110px"></select>')
    if(relatinshipName==null){
        for(var f=0.2;f<=3;f+=0.4){
            var val=f.toFixed(1)+""
            sizeAdjustSelector.append($("<option value="+val+">dimension*"+val+"</option>"))
        }
        if(definedDimensionRatio!=null) sizeAdjustSelector.val(definedDimensionRatio)
        else sizeAdjustSelector.val("1.0")
    }else{
        sizeAdjustSelector.css("width","80px")
        for(var f=0.5;f<=4;f+=0.5){
            var val=f.toFixed(1)+""
            sizeAdjustSelector.append($("<option value="+val+">width *"+val+"</option>"))
        }
        if(definedEdgeWidth!=null) sizeAdjustSelector.val(definedEdgeWidth)
        else sizeAdjustSelector.val("2.0")
    }
    containerDiv.append(sizeAdjustSelector)

    
    sizeAdjustSelector.change((eve)=>{
        var chooseVal=eve.target.value
        var visualJson = globalCache.visualDefinition["default"].detail

        if(!relatinshipName) {
            if(!visualJson[modelID]) visualJson[modelID]={}
            visualJson[modelID].dimensionRatio=chooseVal
            this.broadcastMessage({ "message": "visualDefinitionChange", "modelID":modelID,"dimensionRatio":chooseVal })
        }else{
            if(!visualJson[modelID]["rels"]) visualJson[modelID]["rels"]={}
            if(!visualJson[modelID]["rels"][relatinshipName]) visualJson[modelID]["rels"][relatinshipName]={}
            visualJson[modelID]["rels"][relatinshipName].edgeWidth=chooseVal
            this.broadcastMessage({ "message": "visualDefinitionChange", "srcModelID":modelID,"relationshipName":relatinshipName,"edgeWidth":chooseVal })
        }
        this.saveVisualDefinition()
    })
    
}

modelManagerDialog.prototype.saveVisualDefinition=async function(){
    try{
        await msalHelper.callAPI("digitaltwin/saveVisualDefinition", "POST", {"visualDefinitionJson":JSON.stringify(globalCache.visualDefinition["default"].detail)},"withProjectID")
    }catch(e){
        console.log(e)
        if(e.responseText) alert(e.responseText)
    }
}

modelManagerDialog.prototype.fillRelationshipInfo=function(validRelationships,parentDom){
    for(var ind in validRelationships){
        var keyDiv= $("<label style='display:inline;padding:.1em .3em .1em .3em;margin-right:.3em'>"+ind+"</label>")
        parentDom.append(keyDiv)
        keyDiv.css("padding-top",".1em")
        var label=$("<label class='w3-lime' style='display:inline;font-size:9px;padding:2px'></label>")
        label.text("Relationship")
        parentDom.append(label)
        if(validRelationships[ind].target){
            var label1=$("<label class='w3-lime' style='display:inline;font-size:9px;padding:2px;margin-left:2px'></label>")
            label1.text(validRelationships[ind].target)
            parentDom.append(label1)
        }
        var contentDOM=$("<label></label>")
        contentDOM.css("display","block")
        contentDOM.css("padding-left","1em")
        parentDom.append(contentDOM)
        this.fillEditableProperties(validRelationships[ind].editableRelationshipProperties, contentDOM)
    }
}

modelManagerDialog.prototype.fillEditableProperties=function(jsonInfo,parentDom){
    for(var ind in jsonInfo){
        var keyDiv= $("<label style='display:block'><label style='display:inline;padding:.1em .3em .1em .3em;margin-right:.3em'>"+ind+"</label></label>")
        parentDom.append(keyDiv)
        keyDiv.css("padding-top",".1em")

        if(Array.isArray(jsonInfo[ind])){
            var contentDOM=$("<label class='w3-dark-gray' ></label>")
            contentDOM.text("enum")
            contentDOM.css({"fontSize":"9px","padding":'2px'})
            keyDiv.append(contentDOM)

            var valueArr=[]
            jsonInfo[ind].forEach(ele=>{valueArr.push(ele.enumValue)})
            var label1=$("<label class='w3-dark-gray' ></label>")
            label1.css({"fontSize":"9px","padding":'2px',"margin-left":"2px"})
            label1.text(valueArr.join())
            keyDiv.append(label1)
        }else if(typeof(jsonInfo[ind])==="object") {
            var contentDOM=$("<label></label>")
            contentDOM.css("display","block")
            contentDOM.css("padding-left","1em")
            this.fillEditableProperties(jsonInfo[ind],contentDOM)
            keyDiv.append(contentDOM)
        }else {
            var contentDOM=$("<label class='w3-dark-gray' ></label>")
            contentDOM.text(jsonInfo[ind])
            contentDOM.css({"fontSize":"9px","padding":'2px'})
            keyDiv.append(contentDOM)
        }
    }
}


modelManagerDialog.prototype.addAPartInRightSpan=function(partName,options){
    options=options||{}
    var section= new simpleExpandableSection(partName,this.panelCard,options)
    section.expand()
    return section.listDOM;
}

modelManagerDialog.prototype.readModelFilesContentAndImport=async function(files){
    // files is a FileList of File objects. List some properties.
    var fileContentArr=[]
    for (var i = 0;i< files.length; i++) {
        var f=files[i]
        // Only process json files.
        if (f.type!="application/json") continue;
        try{
            var str= await this.readOneFile(f)
            var obj=JSON.parse(str)
            if(Array.isArray(obj)) fileContentArr=fileContentArr.concat(obj)
            else fileContentArr.push(obj)
        }catch(err){
            alert(err)
        }
    }
    if(fileContentArr.length==0) return;
    try {
        await msalHelper.callAPI("digitaltwin/importModels", "POST", {"models":JSON.stringify(fileContentArr)},"withProjectID")
        this.listModels("shouldBroadCast")
    }catch(e){
        console.log(e)
        if(e.responseText) alert(e.responseText)
    }  
}

modelManagerDialog.prototype.readOneFile= async function(aFile){
    return new Promise((resolve, reject) => {
        try{
            var reader = new FileReader();
            reader.onload = ()=> {
                resolve(reader.result)
            };
            reader.readAsText(aFile);
        }catch(e){
            reject(e)
        }
    })
}


modelManagerDialog.prototype.listModels=async function(shouldBroadcast){
    this.modelList.empty()
    this.panelCard.empty()
    try{
        var res=await msalHelper.callAPI("digitaltwin/fetchProjectModelsData","POST",null,"withProjectID")
        globalCache.storeProjectModelsData(res.DBModels,res.adtModels)
        modelAnalyzer.clearAllModels();
        modelAnalyzer.addModels(res.adtModels)
        modelAnalyzer.analyze();
    }catch(e){
        console.log(e)
        if(e.responseText) alert(e.responseText)
        return
    }

    if($.isEmptyObject(modelAnalyzer.DTDLModels)){
        var zeroModelItem=$('<li style="font-size:0.9em">zero model record. Please import...</li>')
        this.modelList.append(zeroModelItem)
        zeroModelItem.css("cursor","default")
    }else{
        this.tree = new simpleTree(this.modelList, {
            "leafNameProperty": "displayName"
            , "noMultipleSelectAllowed": true, "hideEmptyGroup": true
        })

        this.tree.options.leafNodeIconFunc = (ln) => {
            var modelClass = ln.leafInfo["@id"]
            var dbModelInfo=globalCache.getSingleDBModelByID(modelClass)
            
            var colorCode = "darkGray"
            var shape = "ellipse"
            var avarta = null
            var dimension=20;
            if (globalCache.visualDefinition["default"].detail[modelClass]) {
                var visualJson = globalCache.visualDefinition["default"].detail[modelClass]
                var colorCode = visualJson.color || "darkGray"
                var secondColor = visualJson.secondColor
                var shape = visualJson.shape || "ellipse"
                var avarta = visualJson.avarta
                if(visualJson.dimensionRatio) dimension*=parseFloat(visualJson.dimensionRatio)
            }

            var iconDOM=$("<div style='width:"+dimension+"px;height:"+dimension+"px;float:left;position:relative'></div>")
            if(dbModelInfo.isIoTDeviceModel){
                var iotDiv=$("<div class='w3-border' style='position:absolute;right:-5px;padding:0px 2px;top:-9px;border-radius: 3px;font-size:7px'>IoT</div>")
                iconDOM.append(iotDiv)
            }


            var imgSrc=encodeURIComponent(globalCache.shapeSvg(shape,colorCode,secondColor))
            iconDOM.append($("<img src='data:image/svg+xml;utf8,"+imgSrc+"'></img>"))
            if(avarta){
                var avartaimg=$(`<img style='max-width:${dimension*0.75}px;max-height:${dimension*0.75}px;position:absolute;left:50%;top:50%;transform:translateX(-50%) translateY(-50%)' src='${avarta}'></img>`)
                iconDOM.append(avartaimg)
            }
            return iconDOM
        }

        this.tree.callback_afterSelectNodes = (nodesArr, mouseClickDetail) => {
            var theNode = nodesArr[0]
            this.fillRightSpan(theNode.leafInfo["@id"])
        }

        var groupNameList = {}
        for (var modelID in modelAnalyzer.DTDLModels) groupNameList[this.modelNameToGroupName(modelID)] = 1
        var modelgroupSortArr = Object.keys(groupNameList)
        modelgroupSortArr.sort(function (a, b) { return a.toLowerCase().localeCompare(b.toLowerCase()) });
        modelgroupSortArr.forEach(oneGroupName => {
            var gn=this.tree.addGroupNode({ displayName: oneGroupName })
            gn.expand()
        })

        for (var modelID in modelAnalyzer.DTDLModels) {
            var gn = this.modelNameToGroupName(modelID)
            this.tree.addLeafnodeToGroup(gn, JSON.parse(modelAnalyzer.DTDLModels[modelID]["original"]))
        }

        this.tree.sortAllLeaves()
    }
    
    if(shouldBroadcast) this.broadcastMessage({ "message": "ADTModelsChange"})
}

modelManagerDialog.prototype.modelNameToGroupName=function(modelName){
    var nameParts=modelName.split(":")
    if(nameParts.length>=2)  return nameParts[1]
    else return "Others"
}

modelManagerDialog.prototype.rxMessage=function(msgPayload){
    if(msgPayload.message=="ADTModelEdited") this.listModels("shouldBroadcast")
}


module.exports = new modelManagerDialog();
},{"../msalHelper":12,"../sharedSourceFiles/simpleExpandableSection":24,"./globalCache":15,"./modelAnalyzer":16,"./modelEditorDialog":17,"./simpleConfirmDialog":23,"./simpleTree":26}],19:[function(require,module,exports){
const globalAppSettings=require("../globalAppSettings")

function moduleSwitchDialog(){
    this.modulesSidebar=$('<div class="w3-sidebar w3-bar-block w3-white w3-animate-left w3-card-4" style="display:none;height:195px;width:240px;overflow:hidden"><div style="height:40px" class="w3-bar w3-red"><button class="w3-bar-item w3-button w3-left w3-hover-amber" style="font-size:2em;padding-top:4px;width:55px"></button><div class="w3-bar-item" style="font-size:1.5em;width:70px;float:left;cursor:default">Open</div></div><a href="#" class="w3-bar-item w3-button w3-medium"><img src="faviconiothub.ico" style="width:25px;margin-right:10px"></img>Device Management</a><a href="#" class="w3-bar-item w3-button w3-medium"><img src="favicondigitaltwin.ico" style="width:25px;margin-right:10px"></img>Digital Twin</a><a href="#" class="w3-bar-item w3-button w3-medium"><img src="faviconeventlog.ico" style="width:25px;margin-right:10px"></img>Event Log</a><a href="#" class="w3-bar-item w3-button w3-medium">Log out</a></div>')
    
    this.modulesSwitchButton=$('<a class="w3-bar-item w3-button" href="#"></a>')
    
    this.modulesSwitchButton.on("click",()=>{ this.modulesSidebar.css("display","block") })
    this.modulesSidebar.children(':first').on("click",()=>{this.modulesSidebar.css("display","none")})
    
    var allModeuls=this.modulesSidebar.children("a")
    $(allModeuls[0]).on("click",()=>{
        window.open("devicemanagement.html", "_blank")
        this.modulesSidebar.css("display","none")
    })
    $(allModeuls[1]).on("click",()=>{
        window.open("digitaltwinmodule.html", "_blank")
        this.modulesSidebar.css("display","none")
    })
    $(allModeuls[2]).on("click",()=>{
        window.open("eventlogmodule.html", "_blank")
        this.modulesSidebar.css("display","none")
    })
    $(allModeuls[3]).on("click",()=>{
        const logoutRequest = {
            postLogoutRedirectUri: globalAppSettings.logoutRedirectUri,
            mainWindowRedirectUri: globalAppSettings.logoutRedirectUri
        };
        var myMSALObj = new msal.PublicClientApplication(globalAppSettings.msalConfig);
        myMSALObj.logoutPopup(logoutRequest);
    })
}

module.exports = new moduleSwitchDialog();
},{"../globalAppSettings":11}],20:[function(require,module,exports){
const modelAnalyzer=require("./modelAnalyzer")
const simpleSelectMenu= require("./simpleSelectMenu")
const msalHelper=require("../msalHelper")
const globalCache=require("./globalCache")

function newTwinDialog() {
    if(!this.DOM){
        this.DOM = $('<div style="position:absolute;top:50%;background-color:white;left:50%;transform: translateX(-50%) translateY(-50%);z-index:99" class="w3-card-2"></div>')
        $("body").append(this.DOM)
        this.DOM.hide()
        globalCache.makeDOMDraggable(this.DOM)
    }
}

newTwinDialog.prototype.popup = async function(twinInfo) {
    this.originalTwinInfo=JSON.parse(JSON.stringify(twinInfo))
    this.twinInfo=twinInfo
    this.DOM.show()
    this.DOM.empty()
    this.contentDOM = $('<div style="width:520px"></div>')
    this.DOM.append(this.contentDOM)
    this.contentDOM.append($('<div style="height:40px" class="w3-bar w3-red"><div class="w3-bar-item" style="font-size:1.5em">Digital Twin Editor</div></div>'))
    var closeButton = $('<button class="w3-bar-item w3-button w3-right" style="font-size:2em;padding-top:4px"></button>')
    this.contentDOM.children(':first').append(closeButton)
    closeButton.on("click", () => { this.DOM.hide() })

    var addButton = $('<button class="w3-ripple w3-button w3-card w3-green w3-hover-light-green" style="height:100%">Add</button>')
    this.contentDOM.children(':first').append(addButton)
    addButton.on("click", async () => { this.addNewTwin() })
    
    var addAndCloseButton = $('<button class="w3-button w3-card w3-green w3-hover-light-green" style="height:100%;margin-left:5px">Add & Close</button>')    
    this.contentDOM.children(':first').append(addAndCloseButton)
    addAndCloseButton.on("click", async () => {this.addNewTwin("CloseDialog")})
        
    var IDLableDiv= $("<div class='w3-padding' style='display:inline;font-weight:bold;color:black'>Twin ID</div>")
    var IDInput=$('<input type="text" style="margin:8px 0;padding:2px;width:150px;outline:none;display:inline" placeholder="ID"/>').addClass("w3-input w3-border");
    this.IDInput=IDInput 
    var modelID=twinInfo["$metadata"]["$model"]
    var modelLableDiv= $("<div class='w3-padding' style='display:inline;font-weight:bold;color:black'>Model</div>")
    var modelInput=$('<label type="text" style="margin:8px 0;padding:2px;display:inline"/>').text(modelID);  
    this.contentDOM.append($("<div/>").append(IDLableDiv,IDInput))
    this.contentDOM.append($("<div style='padding:8px 0px'/>").append(modelLableDiv,modelInput))
    IDInput.change((e)=>{
        this.twinInfo["$dtId"]=$(e.target).val()
    })

    var dialogDOM=$('<div />')
    this.contentDOM.append(dialogDOM)    
    var titleTable=$('<table style="width:100%" cellspacing="0px" cellpadding="0px"></table>')
    titleTable.append($('<tr><td style="font-weight:bold">Properties Tree</td></tr>'))
    dialogDOM.append($("<div class='w3-container'/>").append(titleTable))

    var settingsDiv=$("<div class='w3-container w3-border' style='width:100%;max-height:310px;overflow:auto'></div>")
    this.settingsDiv=settingsDiv
    dialogDOM.append(settingsDiv)
    this.drawModelSettings()
}

newTwinDialog.prototype.addNewTwin = async function(closeDialog) {
    var modelID=this.twinInfo["$metadata"]["$model"]
    var DBModelInfo=globalCache.getSingleDBModelByID(modelID)

    if(!this.twinInfo["$dtId"]||this.twinInfo["$dtId"]==""){
        alert("Please fill in name for the new digital twin")
        return;
    }
    var componentsNameArr=modelAnalyzer.DTDLModels[modelID].includedComponents
    componentsNameArr.forEach(oneComponentName=>{ //adt service requesting all component appear by mandatory
        if(this.twinInfo[oneComponentName]==null)this.twinInfo[oneComponentName]={}
        this.twinInfo[oneComponentName]["$metadata"]= {}
    })

    //ask taskmaster to add the twin
    try{
        var postBody= {"newTwinJson":JSON.stringify(this.twinInfo)}
        var data = await msalHelper.callAPI("digitaltwin/upsertDigitalTwin", "POST", postBody,"withProjectID" )
    }catch(e){
        console.log(e)
        if(e.responseText) alert(e.responseText)
    }

    globalCache.storeSingleDBTwin(data.DBTwin)    
    globalCache.storeSingleADTTwin(data.ADTTwin)


    //ask taskmaster to provision the twin to iot hub if the model is a iot device model
    if(DBModelInfo.isIoTDeviceModel){
        try{
            var postBody= {"DBTwin":data.DBTwin,"desiredInDeviceTwin":{}}
            DBModelInfo.desiredProperties.forEach(ele=>{
                var propertyName=ele.path[ele.path.length-1]
                var propertySampleV= ""
                postBody.desiredInDeviceTwin[propertyName]=propertySampleV
            })
            var provisionedDocument = await msalHelper.callAPI("devicemanagement/provisionIoTDeviceTwin", "POST", postBody,"withProjectID" )
        }catch(e){
            console.log(e)
            if(e.responseText) alert(e.responseText)
        }
        data.DBTwin=provisionedDocument
        globalCache.storeSingleDBTwin(provisionedDocument)   
    }

    //it should select the new node in the tree, and move topology view to show the new node (note pan to a place that is not blocked by the dialog itself)
    this.broadcastMessage({ "message": "addNewTwin", "twinInfo": data.ADTTwin, "DBTwinInfo":data.DBTwin})

    if(closeDialog)this.DOM.hide()
    else{
        //clear the input editbox
        this.popup(this.originalTwinInfo)
    }
}

newTwinDialog.prototype.drawModelSettings = async function() {
    var modelID=this.twinInfo["$metadata"]["$model"]
    var modelDetail= modelAnalyzer.DTDLModels[modelID]
    var copyModelEditableProperty=JSON.parse(JSON.stringify(modelDetail.editableProperties))
    
    if($.isEmptyObject(copyModelEditableProperty)){
        this.settingsDiv.text("There is no editable property")
        this.settingsDiv.addClass("w3-text-gray")
        return;
    }   

    var settingsTable=$('<table style="width:100%" cellspacing="0px" cellpadding="0px"></table>')
    this.settingsDiv.append(settingsTable)

    var initialPathArr=[]
    var lastRootNodeRecord=[]
    this.drawEditable(settingsTable,copyModelEditableProperty,initialPathArr,lastRootNodeRecord)
}


newTwinDialog.prototype.drawEditable = async function(parentTable,jsonInfo,pathArr,lastRootNodeRecord) {
    if(jsonInfo==null) return;
    var arr=[]
    for(var ind in jsonInfo) arr.push(ind)

    for(var theIndex=0;theIndex<arr.length;theIndex++){
        if(theIndex==arr.length-1) lastRootNodeRecord[pathArr.length] =true;
        
        var ind = arr[theIndex]
        var tr=$("<tr/>")
        var rightTD=$("<td style='height:30px'/>")
        tr.append(rightTD)
        parentTable.append(tr)
        
        for(var i=0;i<pathArr.length;i++){
            if(!lastRootNodeRecord[i]) rightTD.append(this.treeLineDiv(2))
            else rightTD.append(this.treeLineDiv(4))
        }

        if(theIndex==arr.length-1) rightTD.append(this.treeLineDiv(3))
        else rightTD.append(this.treeLineDiv(1))

        var pNameDiv=$("<div style='float:left;line-height:28px;margin-left:3px'>"+ind+"</div>")
        rightTD.append(pNameDiv)
        var newPath=pathArr.concat([ind])

        if (Array.isArray(jsonInfo[ind])) { //it is a enumerator
            this.drawDropDownBox(rightTD,newPath,jsonInfo[ind])
        } else if (typeof (jsonInfo[ind])==="object") {
            this.drawEditable(parentTable,jsonInfo[ind],newPath,lastRootNodeRecord)
        }else {
            var aInput=$('<input type="text" style="margin-left:5px;padding:2px;width:200px;outline:none;display:inline" placeholder="type: '+jsonInfo[ind]+'"/>').addClass("w3-input w3-border");  
            rightTD.append(aInput)
            aInput.data("path", newPath)
            aInput.data("dataType", jsonInfo[ind])
            aInput.change((e)=>{
                this.updateOriginObjectValue($(e.target).data("path"),$(e.target).val(),$(e.target).data("dataType"))
            })
        } 
    }
}

newTwinDialog.prototype.drawDropDownBox=function(rightTD,newPath,valueArr){
    var aSelectMenu = new simpleSelectMenu(""
        , { width: "200" 
            ,buttonCSS: { "padding": "4px 16px"}
            , "optionListMarginTop": 25//,"optionListMarginLeft":210
            , "adjustPositionAnchor": this.DOM.offset()
        })


    rightTD.append(aSelectMenu.rowDOM)  //use rowDOM instead of DOM to allow select option window float above dialog
    aSelectMenu.DOM.data("path", newPath)
    valueArr.forEach((oneOption) => {
        var str = oneOption["displayName"] || oneOption["enumValue"]
        aSelectMenu.addOption(str)
    })
    aSelectMenu.callBack_clickOption = (optionText, optionValue, realMouseClick) => {
        aSelectMenu.changeName(optionText)
        if (realMouseClick) this.updateOriginObjectValue(aSelectMenu.DOM.data("path"), optionValue, "string")
    }
}

newTwinDialog.prototype.updateOriginObjectValue=function(pathArr,newVal,dataType){
    if(["double","boolean","float","integer","long"].includes(dataType)) newVal=Number(newVal)
    if(pathArr.length==0) return;
    var theJson=this.twinInfo
    for(var i=0;i<pathArr.length;i++){
        var key=pathArr[i]

        if(i==pathArr.length-1){
            theJson[key]=newVal
            break
        }
        if(theJson[key]==null) theJson[key]={}
        theJson=theJson[key]
    }
}

newTwinDialog.prototype.treeLineDiv = function(typeNumber) {
    var reDiv=$('<div style="margin-left:10px;width:15px;height: 100%;float: left"></div>')
    if(typeNumber==1){
        reDiv.append($('<div class="w3-border-bottom w3-border-left" style="width:100%;height:50%;"></div><div class="w3-border-left" style="width:100%;height:50%;"></div>'))
    }else if(typeNumber==2){
        reDiv.append($('<div class="w3-border-left" style="width:100%;height:50%;"></div><div class="w3-border-left" style="width:100%;height:50%;"></div>'))
    }else if(typeNumber==3){
        reDiv.append($('<div class="w3-border-bottom w3-border-left" style="width:100%;height:50%;">'))
    }else if(typeNumber==4){
        
    }
    return reDiv
}

module.exports = new newTwinDialog();
},{"../msalHelper":12,"./globalCache":15,"./modelAnalyzer":16,"./simpleSelectMenu":25}],21:[function(require,module,exports){
const msalHelper=require("../msalHelper")
const globalCache = require("../sharedSourceFiles/globalCache");

function serviceWorkerHelper(){
    this.projectID=null
    this.allLiveMonitor={}
    setInterval(()=>{
        if(this.projectID==null) return;
        this.subscribeImportantEvent(this.projectID)

        for(var ind in this.allLiveMonitor){
            var aLiveProperty=this.allLiveMonitor[ind]
            this.subscribeLiveProperty(aLiveProperty.twinID,aLiveProperty.propertyPath)
        }

    },8*60*1000) //every 8 minute renew the service worker subscription
}

serviceWorkerHelper.prototype.subscribeImportantEvent = async function (projectID) {    
    var subscription=await this.createSubscription()
    if(subscription==null) return;
    try {
        var payload={
            type:'events',
            serviceWorkerSubscription:JSON.stringify(subscription)
        }
        msalHelper.callAPI("digitaltwin/serviceWorkerSubscription", "POST", payload, "withProjectID")
    } catch (e) {
        console.log(e)
    }
}

serviceWorkerHelper.prototype.subscribeLiveProperty = async function (twinID,propertyPath) {    
    var subscription=await this.createSubscription()
    if(subscription==null) return;
    try {
        var payload={
            type:'propertyValue',
            serviceWorkerSubscription:JSON.stringify(subscription),
            twinID:twinID,
            propertyPath:propertyPath
        }
        msalHelper.callAPI("digitaltwin/serviceWorkerSubscription", "POST", payload, "withProjectID")
    } catch (e) {
        console.log(e) 
    }
}

serviceWorkerHelper.prototype.unsubscribeLiveProperty = async function (twinID,propertyPath) {    
    try {
        msalHelper.callAPI("digitaltwin/serviceWorkerUnsubscription", "POST", {twinID:twinID,propertyPath:propertyPath}, "withProjectID")
    } catch (e) {
        console.log(e)
    }
}

serviceWorkerHelper.prototype.createSubscription = async function () {
    if (!('serviceWorker' in navigator)) return null;
    //this public key should be the one used in backend server side for pushing message (in azureiotrocksfunction)
    const publicVapidKey = 'BCxvFqk0czIkCTblAMy80fMWTj2WaAkeXCyp98-S2MiVrTL59u046eLRrTBImo9ZCWAQ3Yqj_7PwEOuyhDmC-WY';
    var subscription = null
    try {
        const registration = await navigator.serviceWorker.register('/worker.js', { scope: '/' });
        subscription = await registration.pushManager.subscribe({
            userVisibleOnly: true,
            applicationServerKey: publicVapidKey
        });
        navigator.serviceWorker.onmessage = (e)=> {
            this.processLiveMessage(e.data)
            this.broadcastMessage({ "message": "liveData","body":e.data })
        };
    } catch (e) {
        console.log(e)
    }
    return subscription;
}

serviceWorkerHelper.prototype.processLiveMessage=function(msgBody){
    //console.log(msgBody)
    if(msgBody.connectionState && msgBody.projectID==globalCache.currentProjectID){
        var twinID=msgBody.twinID
        var twinDBInfo=globalCache.DBTwins[twinID]
        if(msgBody.connectionState=="deviceConnected") twinDBInfo.connectState=true
        else twinDBInfo.connectState=false
        //console.log(msgBody)
    }else if(msgBody.propertyPath){
        var twinInfo=globalCache.storedTwins[msgBody.twinID]
        this.updateOriginObjectValue(twinInfo,msgBody.propertyPath,msgBody.value)
    }
}

serviceWorkerHelper.prototype.updateOriginObjectValue=function(nodeInfo, pathArr, newVal) {
    if (pathArr.length == 0) return;
    var theJson = nodeInfo
    for (var i = 0; i < pathArr.length; i++) {
        var key = pathArr[i]

        if (i == pathArr.length - 1) {
            theJson[key] = newVal
            break
        }
        if (theJson[key] == null) theJson[key] = {}
        theJson = theJson[key]
    }
}

serviceWorkerHelper.prototype.rxMessage=function(msgPayload){
    if(msgPayload.message=="projectIsChanged"){
        for(var ind in this.allLiveMonitor) delete this.allLiveMonitor[ind]
        this.projectID=msgPayload.projectID
        this.subscribeImportantEvent(msgPayload.projectID)
    }else if(msgPayload.message=="addLiveMonitor"){
        var str=this.generateID(msgPayload.twinID,msgPayload.propertyPath)
        this.allLiveMonitor[str]=msgPayload
        this.subscribeLiveProperty(msgPayload.twinID,msgPayload.propertyPath)
    }else if(msgPayload.message=="removeLiveMonitor"){
        var str=this.generateID(msgPayload.twinID,msgPayload.propertyPath)
        delete this.allLiveMonitor[str]
        this.unsubscribeLiveProperty(msgPayload.twinID,msgPayload.propertyPath)
    }
}

serviceWorkerHelper.prototype.generateID=function(twinID,propertyPath){
    return twinID+"."+propertyPath.join(".")
}


module.exports = new serviceWorkerHelper();
},{"../msalHelper":12,"../sharedSourceFiles/globalCache":15}],22:[function(require,module,exports){
function simpleChart(parentDom,xLength,cssOptions,customDrawing){
    this.chartDOM=$("<div/>")
    parentDom.append(this.chartDOM)
    if(customDrawing){
        customDrawing(this.chartDOM)
    }
    this.canvas = $('<canvas></canvas>')
    this.canvas.css(cssOptions)
    this.chartDOM.append(this.canvas)
    
    this.chart=new Chart(this.canvas, {
        type: "line",
        data: {
            labels: [],
            datasets: [{stepped:true, data: []}]
        },
        options: {
            animation: false,
            datasets: {
                line: {
                    spanGaps:true,
                    borderColor: "rgba(0,0,255,0.7)",
                    borderWidth:1,
                    pointRadius:0
                }
            },
            plugins:{
                legend: { display: false },
                tooltip:{enabled:false}
            },
            scales: {
                x:{grid:{display:false},ticks:{display:false}}
                ,y:{grid:{tickLength:0},ticks:{font:{size:9}}}
                ,x2: {position:'top',grid:{display:false},ticks:{display:false}}
                ,y2: {position:'right',grid:{display:false},ticks:{display:false}}     
            }
            
        }
    });
    this.setXLength(xLength)
}

simpleChart.prototype.setDataArr=function(dataArr){
    this.chart.data.datasets[0].data=dataArr
    this.chart.update()
}

simpleChart.prototype.addDataValue=function(dataIndex,value){
    var dataArr=this.chart.data.datasets[0].data

    var totalPoints=dataArr.length

    if(this.lastDataIndex==null) this.lastDataIndex=dataIndex-1
    if(dataIndex<this.lastDataIndex){
        if(this.lastDataIndex-dataIndex>=totalPoints) return; //ignore receiving too old points
        var diff=this.lastDataIndex - dataIndex
        dataArr[totalPoints-1-diff]=value
    }else{
        var numOfPassedPoints=dataIndex-this.lastDataIndex
        dataArr=dataArr.slice(numOfPassedPoints)
        dataArr[totalPoints-1]=value
    }
    this.setDataArr(dataArr)
    this.lastDataIndex=dataIndex
}

simpleChart.prototype.setXLength=function(xlen){
    var labels=this.chart.data.labels
    labels.length=0
    for(var i=0;i<xlen;i++) labels.push(i)
    //shorten or expand the length of data array
    var dataArr=this.chart.data.datasets[0].data
    if(dataArr.length>xlen) dataArr=dataArr.slice(dataArr.length-xlen)
    else if(dataArr.length<xlen){
        var numberToAdd=xlen-dataArr.length
        var tmpArr=[]
        tmpArr[numberToAdd-1]=null
        dataArr=tmpArr.concat(dataArr)
    }
    this.chart.data.datasets[0].data=dataArr
    this.chart.update()
}

simpleChart.prototype.destroy=function(){
    this.chartDOM.remove()
}

module.exports = simpleChart;
},{}],23:[function(require,module,exports){
const globalCache=require('./globalCache')
function simpleConfirmDialog(){
    this.DOM = $('<div style="position:absolute;top:50%;background-color:white;left:50%;transform: translateX(-50%) translateY(-50%);z-index:102" class="w3-card-4"></div>')
    globalCache.makeDOMDraggable(this.DOM)
    //this.DOM.css("overflow","hidden")
}

simpleConfirmDialog.prototype.show=function(cssOptions,otherOptions){
    this.DOM.css(cssOptions)
    this.DOM.append($('<div style="height:40px" class="w3-bar w3-red"><div class="w3-bar-item" style="font-size:1.2em">' + otherOptions.title + '</div></div>'))
    var closeButton = $('<button class="w3-bar-item w3-button w3-right" style="font-size:2em;padding-top:4px"></button>')
    this.DOM.children(':first').append(closeButton)
    closeButton.on("click", () => { this.close() })

    var dialogDiv=$('<div class="w3-container" style="margin-top:10px;margin-bottom:10px"></div>')
    if(otherOptions.customDrawing){
        otherOptions.customDrawing(dialogDiv)
    }else{
        dialogDiv.text(otherOptions.content)
    }
    this.DOM.append(dialogDiv)
    this.dialogDiv=dialogDiv

    this.bottomBar=$('<div class="w3-bar"></div>')
    this.DOM.append(this.bottomBar)

    if(!otherOptions.buttons) otherOptions.buttons=[]
    otherOptions.buttons.forEach(btn=>{
        var aButton=$('<button class="w3-ripple w3-button w3-right '+(btn.colorClass||"")+'" style="margin-right:2px;margin-left:2px">'+btn.text+'</button>')
        aButton.on("click",()=> { btn.clickFunc()  }  )
        this.bottomBar.append(aButton)    
    })
    $("body").append(this.DOM)
}

simpleConfirmDialog.prototype.close=function(){
    this.DOM.remove()
}

module.exports = simpleConfirmDialog;
},{"./globalCache":15}],24:[function(require,module,exports){
function simpleExpandableSection(titleStr,parentDOM,options) {
    this.expandStatus=false
    options=options||{}
    var marginTop=10
    if(options.marginTop!=null) marginTop=options.marginTop
    this.headerDOM = $(`<button class="w3-button w3-block w3-light-grey w3-left-align w3-border-bottom w3-hover-amber w3-text-gray" style="margin-top:${marginTop}px;font-weight:bold"><a>${titleStr}</a><i class="w3-margin-left fas fa-caret-up"></i></button>`)
    this.listDOM = $('<div class="w3-container w3-hide" style="padding-top:2px"></div>')

    this.headerTextDOM=this.headerDOM.children(":first")

    this.triangle=this.headerDOM.children('i').eq(0)
    parentDOM.append(this.headerDOM, this.listDOM)
    this.headerDOM.on("click", (evt) => {
        if(this.expandStatus) this.shrink()
        else this.expand()
        this.callBack_change(this.expandStatus)
        return false;
    });
    this.callBack_change=(status)=>{}
}

simpleExpandableSection.prototype.expand=function(){
    this.listDOM.addClass("w3-show")
    this.triangle.addClass("fa-caret-down")
    this.triangle.removeClass("fa-caret-up")
    this.expandStatus = true
}

simpleExpandableSection.prototype.shrink=function(){
    this.listDOM.removeClass("w3-show")
    this.triangle.removeClass("fa-caret-down")
    this.triangle.addClass("fa-caret-up")
    this.expandStatus = false
}

module.exports = simpleExpandableSection;
},{}],25:[function(require,module,exports){
function simpleSelectMenu(buttonName,options){
    options=options||{} //{isClickable:1,withBorder:1,fontSize:"",colorClass:"",buttonCSS:""}
    if(options.isClickable){
        this.isClickable=true
        this.DOM=$('<div class="w3-dropdown-click"></div>')
    }else{
        this.DOM=$('<div class="w3-dropdown-hover "></div>')
        this.DOM.on("mouseover",(e)=>{
            this.adjustDropDownPosition()
        })
    }


    //it seems that the select menu only can show outside of a parent scrollable dom when it is inside a w3-bar item... not very sure about why 
    var rowDOM=$('<div class="w3-bar" style="display:inline-block;margin-left:5px"></div>')
    rowDOM.css("width",(options.width||100)+"px")
    this.rowDOM=rowDOM
    this.rowDOM.append(this.DOM)
    
    this.button=$('<button class="w3-button" style="outline: none;"><a>'+buttonName+'</a><a style="font-weight:bold;padding-left:2px"></a><i class="fa fa-caret-down" style="padding-left:3px"></i></button>')
    if(options.withBorder) this.button.addClass("w3-border")
    if(options.fontSize) this.DOM.css("font-size",options.fontSize)
    if(options.colorClass) this.button.addClass(options.colorClass)
    if(options.width) this.button.css("width",options.width)
    if(options.buttonCSS) this.button.css(options.buttonCSS)
    if(options.adjustPositionAnchor) this.adjustPositionAnchor=options.adjustPositionAnchor

    this.optionContentDOM=$('<div class="w3-dropdown-content w3-bar-block w3-card-4"></div>')
    if(options.optionListHeight) this.optionContentDOM.css({"max-height":options.optionListHeight+"px","overflow-y":"auto","overflow-x":"visible"})
    if(options.optionListMarginTop) this.optionContentDOM.css({"margin-top":options.optionListMarginTop+"px"})
    if(options.optionListMarginLeft) this.optionContentDOM.css({"margin-left":options.optionListMarginLeft+"px"})
    
    this.DOM.append(this.button,this.optionContentDOM)
    this.curSelectVal=null;

    if(options.isClickable){
        this.button.on("click",(e)=>{
            this.adjustDropDownPosition()
            if(this.optionContentDOM.hasClass("w3-show"))  this.optionContentDOM.removeClass("w3-show")
            else{
                this.callBack_beforeClickExpand()
                this.optionContentDOM.addClass("w3-show")
            } 
            return false;
        })    
    }
}

simpleSelectMenu.prototype.shrink=function(){
    if(this.optionContentDOM.hasClass("w3-show"))  this.optionContentDOM.removeClass("w3-show")
}

simpleSelectMenu.prototype.adjustDropDownPosition=function(){
    if(!this.adjustPositionAnchor) return;
    var offset=this.DOM.offset()
    var newTop=offset.top-this.adjustPositionAnchor.top
    var newLeft=offset.left-this.adjustPositionAnchor.left
    this.optionContentDOM.css({"top":newTop+"px","left":newLeft+"px"})
}

simpleSelectMenu.prototype.findOption=function(optionValue){
    var options=this.optionContentDOM.children()
    for(var i=0;i<options.length;i++){
        var anOption=$(options[i])
        if(optionValue==anOption.data("optionValue")){
            return {"text":anOption.text(),"value":anOption.data("optionValue"),"colorClass":anOption.data("optionColorClass")}
        }
    }
}

simpleSelectMenu.prototype.findOptionByText=function(optionText){
    var options=this.optionContentDOM.children()
    for(var i=0;i<options.length;i++){
        var anOption=$(options[i])
        if(optionText==anOption.text()){
            return {"text":anOption.text(),"value":anOption.data("optionValue"),"colorClass":anOption.data("optionColorClass")}
        }
    }
}

simpleSelectMenu.prototype.addOptionArr=function(arr){
    arr.forEach(element => {
        this.addOption(element)
    });
}

simpleSelectMenu.prototype.addOption=function(optionText,optionValue,colorClass){
    var optionItem=$('<a href="#" class="w3-bar-item w3-button" style="white-space:nowrap">'+optionText+'</a>')
    if(colorClass) optionItem.addClass(colorClass)
    this.optionContentDOM.append(optionItem)
    optionItem.data("optionValue",optionValue||optionText)
    optionItem.data("optionColorClass",colorClass)
    optionItem.on('click',(e)=>{
        this.curSelectVal=optionItem.data("optionValue")
        if(this.isClickable){
            this.optionContentDOM.removeClass("w3-show")
        }else{
            this.DOM.removeClass('w3-dropdown-hover')
            this.DOM.addClass('w3-dropdown-click')
            setTimeout(() => { //this is to hide the drop down menu after click
                this.DOM.addClass('w3-dropdown-hover')
                this.DOM.removeClass('w3-dropdown-click')
            }, 100);
        }
        this.callBack_clickOption(optionText,optionItem.data("optionValue"),"realMouseClick",optionItem.data("optionColorClass"))
        return false
    })
}

simpleSelectMenu.prototype.changeName=function(nameStr1,nameStr2){
    this.button.children(":first").text(nameStr1)
    this.button.children().eq(1).text(nameStr2)
}

simpleSelectMenu.prototype.triggerOptionIndex=function(optionIndex){
    var theOption=this.optionContentDOM.children().eq(optionIndex)
    if(theOption.length==0) {
        this.curSelectVal=null;
        this.callBack_clickOption(null,null)
        return;
    }
    this.curSelectVal=theOption.data("optionValue")
    this.callBack_clickOption(theOption.text(),theOption.data("optionValue"),null,theOption.data("optionColorClass"))
}

simpleSelectMenu.prototype.triggerOptionValue=function(optionValue){
    var re=this.findOption(optionValue)
    if(re==null){
        this.curSelectVal=null
        this.callBack_clickOption(null,null)
    }else{
        this.curSelectVal=re.value
        this.callBack_clickOption(re.text,re.value,null,re.colorClass)
    }
}

simpleSelectMenu.prototype.triggerOptionText=function(optionText){
    var re=this.findOptionByText(optionText)
    if(re==null){
        this.curSelectVal=null
        this.callBack_clickOption(null,null)
    }else{
        this.curSelectVal=re.value
        this.callBack_clickOption(re.text,re.value,null,re.colorClass)
    }
}


simpleSelectMenu.prototype.clearOptions=function(optionText,optionValue){
    this.optionContentDOM.empty()
    this.curSelectVal=null;
}

simpleSelectMenu.prototype.callBack_clickOption=function(optiontext,optionValue,realMouseClick){
}

simpleSelectMenu.prototype.callBack_beforeClickExpand=function(optiontext,optionValue,realMouseClick){
}


module.exports = simpleSelectMenu;
},{}],26:[function(require,module,exports){
'use strict';

function simpleTree(DOM,options){
    this.DOM=DOM
    this.groupNodes=[] //each group header is one node
    this.selectedNodes=[];
    this.options=options || {}

    this.lastClickedNode=null;
}

simpleTree.prototype.scrollToLeafNode=function(aNode){
    var scrollTop=this.DOM.scrollTop()
    var treeHeight=this.DOM.height()
    var nodePosition=aNode.DOM.position().top //which does not consider parent DOM's scroll height
    //console.log(scrollTop,treeHeight,nodePosition)
    if(treeHeight-50<nodePosition){
        this.DOM.scrollTop(scrollTop + nodePosition-(treeHeight-50)) 
    }else if(nodePosition<50){
        this.DOM.scrollTop(scrollTop + (nodePosition-50)) 
    }
}

simpleTree.prototype.clearAllLeafNodes=function(){
    this.lastClickedNode=null
    this.groupNodes.forEach((gNode)=>{
        gNode.listDOM.empty()
        gNode.childLeafNodes.length=0
        gNode.refreshName()
    })
}

simpleTree.prototype.firstLeafNode=function(){
    if(this.groupNodes.length==0) return null;
    var firstLeafNode=null;
    this.groupNodes.forEach(aGroupNode=>{
        if(firstLeafNode!=null) return;
        if(aGroupNode.childLeafNodes.length>0) firstLeafNode=aGroupNode.childLeafNodes[0]
    })

    return firstLeafNode
}

simpleTree.prototype.nextGroupNode=function(aGroupNode){
    if(aGroupNode==null) return;
    var index=this.groupNodes.indexOf(aGroupNode)
    if(this.groupNodes.length-1>index){
        return this.groupNodes[index+1]
    }else{ //rotate backward to first group node
        return this.groupNodes[0] 
    }
}

simpleTree.prototype.nextLeafNode=function(aLeafNode){
    if(aLeafNode==null) return;
    var aGroupNode=aLeafNode.parentGroupNode
    var index=aGroupNode.childLeafNodes.indexOf(aLeafNode)
    if(aGroupNode.childLeafNodes.length-1>index){
        //next node is in same group
        return aGroupNode.childLeafNodes[index+1]
    }else{
        //find next group first node
        while(true){
            var nextGroupNode = this.nextGroupNode(aGroupNode)
            if(nextGroupNode.childLeafNodes.length==0){
                aGroupNode=nextGroupNode
            }else{
                return nextGroupNode.childLeafNodes[0]
            }
        }
    }
}

simpleTree.prototype.searchText=function(str){
    if(str=="") return null;
    //search from current select item the next leaf item contains the text
    var regex = new RegExp(str, 'i');
    var startNode
    if(this.selectedNodes.length==0) {
        startNode=this.firstLeafNode()
        if(startNode==null) return;
        var theStr=startNode.name;
        if(theStr.match(regex)!=null){
            //find target node 
            return startNode
        }
    }else startNode=this.selectedNodes[0]

    if(startNode==null) return null;
    
    var fromNode=startNode;
    while(true){
        var nextNode=this.nextLeafNode(fromNode)
        if(nextNode==startNode) return null;
        var nextNodeStr=nextNode.name;
        if(nextNodeStr.match(regex)!=null){
            //find target node
            return nextNode
        }else{
            fromNode=nextNode;
        }
    }    
}

simpleTree.prototype.getAllLeafNodeArr=function(){
    var allLeaf=[]
    this.groupNodes.forEach(gn=>{
        allLeaf=allLeaf.concat(gn.childLeafNodes)
    })
    return allLeaf;
}


simpleTree.prototype.addLeafnodeToGroup=function(groupName,obj,skipRepeat){
    var aGroupNode=this.findGroupNode(groupName)
    if(aGroupNode == null) return;
    aGroupNode.addNode(obj,skipRepeat)
}

simpleTree.prototype.removeAllNodes=function(){
    this.lastClickedNode=null
    this.groupNodes.length=0;
    this.selectedNodes.length=0;
    this.DOM.empty()
}

simpleTree.prototype.findGroupNode=function(groupName){
    var foundGroupNode=null
    this.groupNodes.forEach(aGroupNode=>{
        if(aGroupNode.name==groupName){
            foundGroupNode=aGroupNode
            return;
        }
    })
    return foundGroupNode;
}

simpleTree.prototype.delGroupNode=function(gnode){
    this.lastClickedNode=null
    gnode.deleteSelf()
}

simpleTree.prototype.deleteLeafNode=function(nodeName){
    this.lastClickedNode=null
    var findLeafNode=null
    this.groupNodes.forEach((gNode)=>{
        if(findLeafNode!=null) return;
        gNode.childLeafNodes.forEach((aLeaf)=>{
            if(aLeaf.name==nodeName){
                findLeafNode=aLeaf
                return;
            }
        })
    })
    if(findLeafNode==null) return;
    findLeafNode.deleteSelf()
}


simpleTree.prototype.insertGroupNode=function(obj,index){
    var aNewGroupNode = new simpleTreeGroupNode(this,obj)
    var existGroupNode= this.findGroupNode(aNewGroupNode.name)
    if(existGroupNode!=null) return;
    this.groupNodes.splice(index, 0, aNewGroupNode);

    if(index==0){
        this.DOM.append(aNewGroupNode.headerDOM)
        this.DOM.append(aNewGroupNode.listDOM)
    }else{
        var prevGroupNode=this.groupNodes[index-1]
        aNewGroupNode.headerDOM.insertAfter(prevGroupNode.listDOM)
        aNewGroupNode.listDOM.insertAfter(aNewGroupNode.headerDOM)
    }

    return aNewGroupNode;
}

simpleTree.prototype.addGroupNode=function(obj){
    var aNewGroupNode = new simpleTreeGroupNode(this,obj)
    var existGroupNode= this.findGroupNode(aNewGroupNode.name)
    if(existGroupNode!=null) return existGroupNode;
    this.groupNodes.push(aNewGroupNode);
    this.DOM.append(aNewGroupNode.headerDOM)
    this.DOM.append(aNewGroupNode.listDOM)
    return aNewGroupNode;
}

simpleTree.prototype.selectLeafNode=function(leafNode,mouseClickDetail){
    this.selectLeafNodeArr([leafNode],mouseClickDetail)
}
simpleTree.prototype.appendLeafNodeToSelection=function(leafNode){
    var newArr=[].concat(this.selectedNodes)
    newArr.push(leafNode)
    this.selectLeafNodeArr(newArr)
}

simpleTree.prototype.addNodeArrayToSelection=function(arr){
    var newArr = this.selectedNodes
    var filterArr=arr.filter((item) => newArr.indexOf(item) < 0)
    newArr = newArr.concat(filterArr)
    this.selectLeafNodeArr(newArr)
}

simpleTree.prototype.selectGroupNode=function(groupNode){
    if(this.callback_afterSelectGroupNode) this.callback_afterSelectGroupNode(groupNode.info)
}

simpleTree.prototype.selectLeafNodeArr=function(leafNodeArr,mouseClickDetail){
    for(var i=0;i<this.selectedNodes.length;i++){
        this.selectedNodes[i].dim()
    }
    this.selectedNodes.length=0;
    this.selectedNodes=this.selectedNodes.concat(leafNodeArr)
    for(var i=0;i<this.selectedNodes.length;i++){
        this.selectedNodes[i].highlight()
    }

    if(this.callback_afterSelectNodes) this.callback_afterSelectNodes(this.selectedNodes,mouseClickDetail)
}

simpleTree.prototype.dblClickNode=function(theNode){
    if(this.callback_afterDblclickNode) this.callback_afterDblclickNode(theNode)
}

simpleTree.prototype.sortAllLeaves=function(){
    this.groupNodes.forEach(oneGroupNode=>{oneGroupNode.sortNodesByName()})
}

//----------------------------------tree group node---------------
function simpleTreeGroupNode(parentTree,obj){
    this.parentTree=parentTree
    this.info=obj
    this.childLeafNodes=[] //it's child leaf nodes array
    this.name=obj.displayName;
    this.createDOM()
}

simpleTreeGroupNode.prototype.refreshName=function(){
    this.headerDOM.empty()
    var nameDiv=$("<div style='display:inline;padding-left:5px;padding-right:3px;vertical-align:middle'></div>")
    nameDiv.text(this.name)
    
    if(this.childLeafNodes.length>0) lblColor="w3-lime"
    else var lblColor="w3-gray" 
    this.headerDOM.css("font-weight","bold")

    
    if(this.parentTree.options.groupNodeIconFunc){
        var iconLabel=this.parentTree.options.groupNodeIconFunc(this)
        if(iconLabel){
            this.headerDOM.append(iconLabel)
            var rowHeight=iconLabel.height()
            nameDiv.css("line-height",rowHeight+"px")    
        }
    }
    
    var numberlabel=$("<label class='"+lblColor+"' style='display:inline;font-size:9px;padding:2px 4px;font-weight:normal;border-radius: 2px;'>"+this.childLeafNodes.length+"</label>")
    this.headerDOM.append(nameDiv,numberlabel)


    if(this.parentTree.options.groupNodeTailButtonFunc){
        var tailButton=this.parentTree.options.groupNodeTailButtonFunc(this)
        this.headerDOM.append(tailButton)
    }

    this.checkOptionHideEmptyGroup()

}
simpleTreeGroupNode.prototype.checkOptionHideEmptyGroup=function(){
    if (this.parentTree.options.hideEmptyGroup && this.childLeafNodes.length == 0) {
        this.shrink()
        this.headerDOM.hide()
        if (this.listDOM) this.listDOM.hide()
    } else {
        this.headerDOM.show()
        if (this.listDOM) this.listDOM.show()
    }

}
simpleTreeGroupNode.prototype.deleteSelf = function () {
    this.headerDOM.remove()
    this.listDOM.remove()
    var parentArr = this.parentTree.groupNodes
    const index = parentArr.indexOf(this);
    if (index > -1) parentArr.splice(index, 1);
}

simpleTreeGroupNode.prototype.createDOM=function(){
    this.headerDOM=$('<button class="w3-button w3-block w3-light-grey w3-left-align w3-border-bottom" style="position:relative"></button>')
    this.refreshName()
    this.listDOM=$('<div class="w3-container w3-hide w3-border" style="padding:8px"></div>')

    this.headerDOM.on("click",(evt)=> {
        if(this.listDOM.hasClass("w3-show")) this.listDOM.removeClass("w3-show")
        else this.listDOM.addClass("w3-show")

        this.parentTree.selectGroupNode(this)    
        return false;
    });
}

simpleTreeGroupNode.prototype.isOpen=function(){
    return  this.listDOM.hasClass("w3-show")
}


simpleTreeGroupNode.prototype.expand=function(){
    if(this.listDOM) this.listDOM.addClass("w3-show")
}

simpleTreeGroupNode.prototype.shrink=function(){
    if(this.listDOM) this.listDOM.removeClass("w3-show")
}

simpleTreeGroupNode.prototype.sortNodesByName=function(){
    var treeOptions=this.parentTree.options
    if(treeOptions.leafNameProperty) var leafNameProperty=treeOptions.leafNameProperty
    else leafNameProperty="$dtId"
    this.childLeafNodes.sort(function (a, b) { 
        var aName=a.name.toLowerCase()
        var bName=b.name.toLowerCase()
        return aName.localeCompare(bName) 
    });
    //this.listDOM.empty() //NOTE: Can not delete those leaf node otherwise the event handle is lost
    this.childLeafNodes.forEach(oneLeaf=>{this.listDOM.append(oneLeaf.DOM)})
}

simpleTreeGroupNode.prototype.addNode=function(obj,skipRepeat){
    var treeOptions=this.parentTree.options
    if(treeOptions.leafNameProperty) var leafNameProperty=treeOptions.leafNameProperty
    else leafNameProperty="$dtId"

    if(skipRepeat){
        var foundRepeat=false;
        this.childLeafNodes.forEach(aNode=>{
            if(aNode.name==obj[leafNameProperty]) {
                foundRepeat=true
                return;
            }
        })
        if(foundRepeat) return;
    }

    var aNewNode = new simpleTreeLeafNode(this,obj)
    this.childLeafNodes.push(aNewNode)
    this.refreshName()
    this.listDOM.append(aNewNode.DOM)
}

//----------------------------------tree leaf node------------------
function simpleTreeLeafNode(parentGroupNode,obj){
    this.parentGroupNode=parentGroupNode
    this.leafInfo=obj;

    var treeOptions=this.parentGroupNode.parentTree.options
    if(treeOptions.leafNameProperty) this.name=this.leafInfo[treeOptions.leafNameProperty]
    else this.name=this.leafInfo["$dtId"]

    this.createLeafNodeDOM()
}

simpleTreeLeafNode.prototype.deleteSelf = function () {
    this.DOM.remove()
    var gNode = this.parentGroupNode
    const index = gNode.childLeafNodes.indexOf(this);
    if (index > -1) gNode.childLeafNodes.splice(index, 1);
    gNode.refreshName()
}

simpleTreeLeafNode.prototype.clickSelf=function(mouseClickDetail){
    this.parentGroupNode.parentTree.lastClickedNode=this;
    this.parentGroupNode.parentTree.selectLeafNode(this,mouseClickDetail)
}

simpleTreeLeafNode.prototype.createLeafNodeDOM=function(){
    this.DOM=$('<button class="w3-button w3-white" style="display:block;text-align:left;width:98%"></button>')
    this.redrawLabel()


    var clickF=(e)=>{
        this.highlight();
        var clickDetail=e.detail
        if (e.ctrlKey) {
            if(this.parentGroupNode.parentTree.options.noMultipleSelectAllowed){
                this.clickSelf()
                return;
            }
            this.parentGroupNode.parentTree.appendLeafNodeToSelection(this)
            this.parentGroupNode.parentTree.lastClickedNode=this;
        }else if(e.shiftKey){
            if(this.parentGroupNode.parentTree.options.noMultipleSelectAllowed){
                this.clickSelf()
                return;
            }
            if(this.parentGroupNode.parentTree.lastClickedNode==null){
                this.clickSelf()
            }else{
                var allLeafNodeArr=this.parentGroupNode.parentTree.getAllLeafNodeArr()
                var index1 = allLeafNodeArr.indexOf(this.parentGroupNode.parentTree.lastClickedNode)
                var index2 = allLeafNodeArr.indexOf(this)
                if(index1==-1 || index2==-1){
                    this.clickSelf()
                }else{
                    //select all leaf between
                    var lowerI= Math.min(index1,index2)
                    var higherI= Math.max(index1,index2)
                    
                    var middleArr=allLeafNodeArr.slice(lowerI,higherI)                  
                    middleArr.push(allLeafNodeArr[higherI])
                    this.parentGroupNode.parentTree.addNodeArrayToSelection(middleArr)
                }
            }
        }else{
            this.clickSelf(clickDetail)
        }
    }
    this.DOM.on("click",(e)=>{clickF(e)})

    this.DOM.on("dblclick",(e)=>{
        this.parentGroupNode.parentTree.dblClickNode(this)
    })
}

simpleTreeLeafNode.prototype.redrawLabel=function(){
    this.DOM.empty()

    var nameDiv=$("<label style='display:inline;padding-left:5px;padding-right:3px;vertical-align:middle'></label>")
    nameDiv.text(this.name)

    if(this.parentGroupNode.parentTree.options.leafNodeIconFunc){
        var iconLabel=this.parentGroupNode.parentTree.options.leafNodeIconFunc(this)
        this.DOM.append(iconLabel)
        var rowHeight=iconLabel.height()
        nameDiv.css("line-height",rowHeight+"px")
    }
    
    this.DOM.append(nameDiv)
}
simpleTreeLeafNode.prototype.highlight=function(){
    this.DOM.addClass("w3-orange")
    this.DOM.addClass("w3-hover-amber")
    this.DOM.removeClass("w3-white")
}
simpleTreeLeafNode.prototype.dim=function(){
    this.DOM.removeClass("w3-orange")
    this.DOM.removeClass("w3-hover-amber")
    this.DOM.addClass("w3-white")
}


module.exports = simpleTree;
},{}]},{},[5])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL0FwcERhdGEvUm9hbWluZy9ucG0vbm9kZV9tb2R1bGVzL3dhdGNoaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIuLi8uLi8uLi8uLi8uLi8uLi9BcHBEYXRhL1JvYW1pbmcvbnBtL25vZGVfbW9kdWxlcy93YXRjaGlmeS9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwiLi4vLi4vLi4vLi4vLi4vLi4vQXBwRGF0YS9Sb2FtaW5nL25wbS9ub2RlX21vZHVsZXMvd2F0Y2hpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIi4uLy4uLy4uLy4uLy4uLy4uL0FwcERhdGEvUm9hbWluZy9ucG0vbm9kZV9tb2R1bGVzL3dhdGNoaWZ5L25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwiLi4vc3BhU291cmNlQ29kZS9kZXZpY2VtYW5hZ2VtZW50bW9kdWxlL2RldmljZU1hbmFnZW1lbnRNYWluVG9vbGJhci5qcyIsIi4uL3NwYVNvdXJjZUNvZGUvZGV2aWNlbWFuYWdlbWVudG1vZHVsZS9kZXZpY2VNYW5hZ2VtZW50VUkuanMiLCIuLi9zcGFTb3VyY2VDb2RlL2RldmljZW1hbmFnZW1lbnRtb2R1bGUvbW9kZWxJb1RTZXR0aW5nRGlhbG9nLmpzIiwiLi4vc3BhU291cmNlQ29kZS9kZXZpY2VtYW5hZ2VtZW50bW9kdWxlL3Byb2plY3RTZWxlY3Rpb25EaWFsb2cuanMiLCIuLi9zcGFTb3VyY2VDb2RlL2RldmljZW1hbmFnZW1lbnRtb2R1bGUvc2luZ2xlTW9kZWxUd2luc0xpc3QuanMiLCIuLi9zcGFTb3VyY2VDb2RlL2RldmljZW1hbmFnZW1lbnRtb2R1bGUvdHdpbkluZm9QYW5lbC5qcyIsIi4uL3NwYVNvdXJjZUNvZGUvZGV2aWNlbWFuYWdlbWVudG1vZHVsZS90d2luc0xpc3QuanMiLCIuLi9zcGFTb3VyY2VDb2RlL2dsb2JhbEFwcFNldHRpbmdzLmpzIiwiLi4vc3BhU291cmNlQ29kZS9tc2FsSGVscGVyLmpzIiwiLi4vc3BhU291cmNlQ29kZS9zaGFyZWRTb3VyY2VGaWxlcy9iYXNlSW5mb1BhbmVsLmpzIiwiLi4vc3BhU291cmNlQ29kZS9zaGFyZWRTb3VyY2VGaWxlcy9lZGl0UHJvamVjdERpYWxvZy5qcyIsIi4uL3NwYVNvdXJjZUNvZGUvc2hhcmVkU291cmNlRmlsZXMvZ2xvYmFsQ2FjaGUuanMiLCIuLi9zcGFTb3VyY2VDb2RlL3NoYXJlZFNvdXJjZUZpbGVzL21vZGVsQW5hbHl6ZXIuanMiLCIuLi9zcGFTb3VyY2VDb2RlL3NoYXJlZFNvdXJjZUZpbGVzL21vZGVsRWRpdG9yRGlhbG9nLmpzIiwiLi4vc3BhU291cmNlQ29kZS9zaGFyZWRTb3VyY2VGaWxlcy9tb2RlbE1hbmFnZXJEaWFsb2cuanMiLCIuLi9zcGFTb3VyY2VDb2RlL3NoYXJlZFNvdXJjZUZpbGVzL21vZHVsZVN3aXRjaERpYWxvZy5qcyIsIi4uL3NwYVNvdXJjZUNvZGUvc2hhcmVkU291cmNlRmlsZXMvbmV3VHdpbkRpYWxvZy5qcyIsIi4uL3NwYVNvdXJjZUNvZGUvc2hhcmVkU291cmNlRmlsZXMvc2VydmljZVdvcmtlckhlbHBlci5qcyIsIi4uL3NwYVNvdXJjZUNvZGUvc2hhcmVkU291cmNlRmlsZXMvc2ltcGxlQ2hhcnQuanMiLCIuLi9zcGFTb3VyY2VDb2RlL3NoYXJlZFNvdXJjZUZpbGVzL3NpbXBsZUNvbmZpcm1EaWFsb2cuanMiLCIuLi9zcGFTb3VyY2VDb2RlL3NoYXJlZFNvdXJjZUZpbGVzL3NpbXBsZUV4cGFuZGFibGVTZWN0aW9uLmpzIiwiLi4vc3BhU291cmNlQ29kZS9zaGFyZWRTb3VyY2VGaWxlcy9zaW1wbGVTZWxlY3RNZW51LmpzIiwiLi4vc3BhU291cmNlQ29kZS9zaGFyZWRTb3VyY2VGaWxlcy9zaW1wbGVUcmVlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3RKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDanZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDamFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbk9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzdLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN2SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbmFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbGlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcbmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXlcblxudmFyIGxvb2t1cCA9IFtdXG52YXIgcmV2TG9va3VwID0gW11cbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXlcblxudmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbmZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gIGxvb2t1cFtpXSA9IGNvZGVbaV1cbiAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXG59XG5cbi8vIFN1cHBvcnQgZGVjb2RpbmcgVVJMLXNhZmUgYmFzZTY0IHN0cmluZ3MsIGFzIE5vZGUuanMgZG9lcy5cbi8vIFNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFzZTY0I1VSTF9hcHBsaWNhdGlvbnNcbnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxucmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzXG5cbmZ1bmN0aW9uIGdldExlbnMgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyBUcmltIG9mZiBleHRyYSBieXRlcyBhZnRlciBwbGFjZWhvbGRlciBieXRlcyBhcmUgZm91bmRcbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vYmVhdGdhbW1pdC9iYXNlNjQtanMvaXNzdWVzLzQyXG4gIHZhciB2YWxpZExlbiA9IGI2NC5pbmRleE9mKCc9JylcbiAgaWYgKHZhbGlkTGVuID09PSAtMSkgdmFsaWRMZW4gPSBsZW5cblxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gdmFsaWRMZW4gPT09IGxlblxuICAgID8gMFxuICAgIDogNCAtICh2YWxpZExlbiAlIDQpXG5cbiAgcmV0dXJuIFt2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuXVxufVxuXG4vLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkge1xuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiBfYnl0ZUxlbmd0aCAoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSB7XG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuXG4gIHZhciBhcnIgPSBuZXcgQXJyKF9ieXRlTGVuZ3RoKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikpXG5cbiAgdmFyIGN1ckJ5dGUgPSAwXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICB2YXIgbGVuID0gcGxhY2VIb2xkZXJzTGVuID4gMFxuICAgID8gdmFsaWRMZW4gLSA0XG4gICAgOiB2YWxpZExlblxuXG4gIHZhciBpXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfFxuICAgICAgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDIpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAxKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID1cbiAgICAgICgodWludDhbaV0gPDwgMTYpICYgMHhGRjAwMDApICtcbiAgICAgICgodWludDhbaSArIDFdIDw8IDgpICYgMHhGRjAwKSArXG4gICAgICAodWludDhbaSArIDJdICYgMHhGRilcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDJdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl0gK1xuICAgICAgJz09J1xuICAgIClcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAxMF0gK1xuICAgICAgbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdICtcbiAgICAgICc9J1xuICAgIClcbiAgfVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbnZhciBLX01BWF9MRU5HVEggPSAweDdmZmZmZmZmXG5leHBvcnRzLmtNYXhMZW5ndGggPSBLX01BWF9MRU5HVEhcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgUHJpbnQgd2FybmluZyBhbmQgcmVjb21tZW5kIHVzaW5nIGBidWZmZXJgIHY0Lnggd2hpY2ggaGFzIGFuIE9iamVjdFxuICogICAgICAgICAgICAgICBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogV2UgcmVwb3J0IHRoYXQgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0eXBlZCBhcnJheXMgaWYgdGhlIGFyZSBub3Qgc3ViY2xhc3NhYmxlXG4gKiB1c2luZyBfX3Byb3RvX18uIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgXG4gKiAoU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzgpLiBJRSAxMCBsYWNrcyBzdXBwb3J0XG4gKiBmb3IgX19wcm90b19fIGFuZCBoYXMgYSBidWdneSB0eXBlZCBhcnJheSBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbmlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgY29uc29sZS5lcnJvcihcbiAgICAnVGhpcyBicm93c2VyIGxhY2tzIHR5cGVkIGFycmF5IChVaW50OEFycmF5KSBzdXBwb3J0IHdoaWNoIGlzIHJlcXVpcmVkIGJ5ICcgK1xuICAgICdgYnVmZmVyYCB2NS54LiBVc2UgYGJ1ZmZlcmAgdjQueCBpZiB5b3UgcmVxdWlyZSBvbGQgYnJvd3NlciBzdXBwb3J0LidcbiAgKVxufVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIC8vIENhbiB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZD9cbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuX19wcm90b19fID0geyBfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLCBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH0gfVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ3BhcmVudCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5idWZmZXJcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdvZmZzZXQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMuYnl0ZU9mZnNldFxuICB9XG59KVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAobGVuZ3RoID4gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBsZW5ndGggKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICBidWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYnVmXG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBzdHJpbmcuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUoYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICE9IG51bGwgJiZcbiAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHtcbiAgICB2YWx1ZTogbnVsbCxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG5mdW5jdGlvbiBmcm9tICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHZhbHVlKVxuICB9XG5cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gICAgKVxuICB9XG5cbiAgaWYgKGlzSW5zdGFuY2UodmFsdWUsIEFycmF5QnVmZmVyKSB8fFxuICAgICAgKHZhbHVlICYmIGlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLCBBcnJheUJ1ZmZlcikpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgIClcbiAgfVxuXG4gIHZhciB2YWx1ZU9mID0gdmFsdWUudmFsdWVPZiAmJiB2YWx1ZS52YWx1ZU9mKClcbiAgaWYgKHZhbHVlT2YgIT0gbnVsbCAmJiB2YWx1ZU9mICE9PSB2YWx1ZSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZU9mLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICB2YXIgYiA9IGZyb21PYmplY3QodmFsdWUpXG4gIGlmIChiKSByZXR1cm4gYlxuXG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9QcmltaXRpdmUgIT0gbnVsbCAmJlxuICAgICAgdHlwZW9mIHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oXG4gICAgICB2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdKCdzdHJpbmcnKSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoXG4gICAgKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuICApXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gTm90ZTogQ2hhbmdlIHByb3RvdHlwZSAqYWZ0ZXIqIEJ1ZmZlci5mcm9tIGlzIGRlZmluZWQgdG8gd29ya2Fyb3VuZCBDaHJvbWUgYnVnOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC8xNDhcbkJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbkJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBzaXplICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAoc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IGJ1Zi53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgYnVmID0gYnVmLnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIGJ1ZltpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wib2Zmc2V0XCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJsZW5ndGhcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgdmFyIGJ1ZlxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgYnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0IChvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW4pXG5cbiAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJ1ZlxuICAgIH1cblxuICAgIG9iai5jb3B5KGJ1ZiwgMCwgMCwgbGVuKVxuICAgIHJldHVybiBidWZcbiAgfVxuXG4gIGlmIChvYmoubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IG51bWJlcklzTmFOKG9iai5sZW5ndGgpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKDApXG4gICAgfVxuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iailcbiAgfVxuXG4gIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgQXJyYXkuaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmouZGF0YSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwgS19NQVhfTEVOR1RIYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBLX01BWF9MRU5HVEgudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiBiICE9IG51bGwgJiYgYi5faXNCdWZmZXIgPT09IHRydWUgJiZcbiAgICBiICE9PSBCdWZmZXIucHJvdG90eXBlIC8vIHNvIEJ1ZmZlci5pc0J1ZmZlcihCdWZmZXIucHJvdG90eXBlKSB3aWxsIGJlIGZhbHNlXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoaXNJbnN0YW5jZShhLCBVaW50OEFycmF5KSkgYSA9IEJ1ZmZlci5mcm9tKGEsIGEub2Zmc2V0LCBhLmJ5dGVMZW5ndGgpXG4gIGlmIChpc0luc3RhbmNlKGIsIFVpbnQ4QXJyYXkpKSBiID0gQnVmZmVyLmZyb20oYiwgYi5vZmZzZXQsIGIuYnl0ZUxlbmd0aClcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwiYnVmMVwiLCBcImJ1ZjJcIiBhcmd1bWVudHMgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheSdcbiAgICApXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoaXNJbnN0YW5jZShidWYsIFVpbnQ4QXJyYXkpKSB7XG4gICAgICBidWYgPSBCdWZmZXIuZnJvbShidWYpXG4gICAgfVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IGlzSW5zdGFuY2Uoc3RyaW5nLCBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIG9yIEFycmF5QnVmZmVyLiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2Ygc3RyaW5nXG4gICAgKVxuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIG11c3RNYXRjaCA9IChhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gPT09IHRydWUpXG4gIGlmICghbXVzdE1hdGNoICYmIGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkge1xuICAgICAgICAgIHJldHVybiBtdXN0TWF0Y2ggPyAtMSA6IHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIH1cbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGlzIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgKGFuZCB0aGUgYGlzLWJ1ZmZlcmAgbnBtIHBhY2thZ2UpXG4vLyB0byBkZXRlY3QgYSBCdWZmZXIgaW5zdGFuY2UuIEl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBgaW5zdGFuY2VvZiBCdWZmZXJgXG4vLyByZWxpYWJseSBpbiBhIGJyb3dzZXJpZnkgY29udGV4dCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG11bHRpcGxlIGRpZmZlcmVudFxuLy8gY29waWVzIG9mIHRoZSAnYnVmZmVyJyBwYWNrYWdlIGluIHVzZS4gVGhpcyBtZXRob2Qgd29ya3MgZXZlbiBmb3IgQnVmZmVyXG4vLyBpbnN0YW5jZXMgdGhhdCB3ZXJlIGNyZWF0ZWQgZnJvbSBhbm90aGVyIGNvcHkgb2YgdGhlIGBidWZmZXJgIHBhY2thZ2UuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNTRcbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcgPSBCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nXG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkucmVwbGFjZSgvKC57Mn0pL2csICckMSAnKS50cmltKClcbiAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoaXNJbnN0YW5jZSh0YXJnZXQsIFVpbnQ4QXJyYXkpKSB7XG4gICAgdGFyZ2V0ID0gQnVmZmVyLmZyb20odGFyZ2V0LCB0YXJnZXQub2Zmc2V0LCB0YXJnZXQuYnl0ZUxlbmd0aClcbiAgfVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ0YXJnZXRcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5LiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHRhcmdldClcbiAgICApXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0IC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChudW1iZXJJc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChudW1iZXJJc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCA+Pj4gMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIChieXRlc1tpICsgMV0gKiAyNTYpKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBzaG91bGQgYmUgYSBCdWZmZXInKVxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFVzZSBidWlsdC1pbiB3aGVuIGF2YWlsYWJsZSwgbWlzc2luZyBmcm9tIElFMTFcbiAgICB0aGlzLmNvcHlXaXRoaW4odGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpXG4gIH0gZWxzZSBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKHZhciBpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmICgoZW5jb2RpbmcgPT09ICd1dGY4JyAmJiBjb2RlIDwgMTI4KSB8fFxuICAgICAgICAgIGVuY29kaW5nID09PSAnbGF0aW4xJykge1xuICAgICAgICAvLyBGYXN0IHBhdGg6IElmIGB2YWxgIGZpdHMgaW50byBhIHNpbmdsZSBieXRlLCB1c2UgdGhhdCBudW1lcmljIHZhbHVlLlxuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHZhbHVlIFwiJyArIHZhbCArXG4gICAgICAgICdcIiBpcyBpbnZhbGlkIGZvciBhcmd1bWVudCBcInZhbHVlXCInKVxuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXisvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHRha2VzIGVxdWFsIHNpZ25zIGFzIGVuZCBvZiB0aGUgQmFzZTY0IGVuY29kaW5nXG4gIHN0ciA9IHN0ci5zcGxpdCgnPScpWzBdXG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHIudHJpbSgpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuLy8gQXJyYXlCdWZmZXIgb3IgVWludDhBcnJheSBvYmplY3RzIGZyb20gb3RoZXIgY29udGV4dHMgKGkuZS4gaWZyYW1lcykgZG8gbm90IHBhc3Ncbi8vIHRoZSBgaW5zdGFuY2VvZmAgY2hlY2sgYnV0IHRoZXkgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgb2YgdGhhdCB0eXBlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTY2XG5mdW5jdGlvbiBpc0luc3RhbmNlIChvYmosIHR5cGUpIHtcbiAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIHR5cGUgfHxcbiAgICAob2JqICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yLm5hbWUgIT0gbnVsbCAmJlxuICAgICAgb2JqLmNvbnN0cnVjdG9yLm5hbWUgPT09IHR5cGUubmFtZSlcbn1cbmZ1bmN0aW9uIG51bWJlcklzTmFOIChvYmopIHtcbiAgLy8gRm9yIElFMTEgc3VwcG9ydFxuICByZXR1cm4gb2JqICE9PSBvYmogLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cbiIsIi8qISBpZWVlNzU0LiBCU0QtMy1DbGF1c2UgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG5leHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IChlICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IChtICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKCh2YWx1ZSAqIGMpIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iLCJjb25zdCBtb2R1bGVTd2l0Y2hEaWFsb2c9cmVxdWlyZShcIi4uL3NoYXJlZFNvdXJjZUZpbGVzL21vZHVsZVN3aXRjaERpYWxvZ1wiKVxyXG5jb25zdCBtb2RlbE1hbmFnZXJEaWFsb2cgPSByZXF1aXJlKFwiLi4vc2hhcmVkU291cmNlRmlsZXMvbW9kZWxNYW5hZ2VyRGlhbG9nXCIpXHJcbmNvbnN0IHByb2plY3RTZWxlY3Rpb25EaWFsb2cgPSByZXF1aXJlKFwiLi9wcm9qZWN0U2VsZWN0aW9uRGlhbG9nXCIpXHJcblxyXG5mdW5jdGlvbiBkZXZpY2VNYW5hZ2VtZW50TWFpblRvb2xiYXIoKSB7XHJcbn1cclxuXHJcbmRldmljZU1hbmFnZW1lbnRNYWluVG9vbGJhci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5zd2l0Y2hQcm9qZWN0QnRuPSQoJzxhIGNsYXNzPVwidzMtYmFyLWl0ZW0gdzMtYnV0dG9uXCIgaHJlZj1cIiNcIj5Qcm9qZWN0PC9hPicpXHJcbiAgICB0aGlzLm1vZGVsSU9CdG49JCgnPGEgY2xhc3M9XCJ3My1iYXItaXRlbSB3My1idXR0b25cIiBocmVmPVwiI1wiPk1vZGVsczwvYT4nKVxyXG5cclxuICAgICQoXCIjTWFpblRvb2xiYXJcIikuZW1wdHkoKVxyXG4gICAgJChcIiNNYWluVG9vbGJhclwiKS5hcHBlbmQobW9kdWxlU3dpdGNoRGlhbG9nLm1vZHVsZXNTaWRlYmFyKVxyXG4gICAgJChcIiNNYWluVG9vbGJhclwiKS5hcHBlbmQobW9kdWxlU3dpdGNoRGlhbG9nLm1vZHVsZXNTd2l0Y2hCdXR0b24sdGhpcy5zd2l0Y2hQcm9qZWN0QnRuLHRoaXMubW9kZWxJT0J0bilcclxuXHJcbiAgICBtb2RlbE1hbmFnZXJEaWFsb2cuc2hvd1JlbGF0aW9uVmlzdWFsaXphdGlvblNldHRpbmdzPWZhbHNlXHJcbiAgICB0aGlzLnN3aXRjaFByb2plY3RCdG4ub24oXCJjbGlja1wiLCgpPT57IHByb2plY3RTZWxlY3Rpb25EaWFsb2cucG9wdXAoKSB9KVxyXG4gICAgdGhpcy5tb2RlbElPQnRuLm9uKFwiY2xpY2tcIiwoKT0+eyBtb2RlbE1hbmFnZXJEaWFsb2cucG9wdXAoKSB9KVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBkZXZpY2VNYW5hZ2VtZW50TWFpblRvb2xiYXIoKTsiLCIndXNlIHN0cmljdCc7XHJcbmNvbnN0IGdsb2JhbEFwcFNldHRpbmdzID0gcmVxdWlyZShcIi4uL2dsb2JhbEFwcFNldHRpbmdzLmpzXCIpO1xyXG5jb25zdCBtc2FsSGVscGVyPXJlcXVpcmUoXCIuLi9tc2FsSGVscGVyXCIpXHJcbmNvbnN0IGRldmljZU1hbmFnZW1lbnRNYWluVG9vbGJhciA9IHJlcXVpcmUoXCIuL2RldmljZU1hbmFnZW1lbnRNYWluVG9vbGJhclwiKVxyXG5jb25zdCBtb2RlbEVkaXRvckRpYWxvZyA9IHJlcXVpcmUoXCIuLi9zaGFyZWRTb3VyY2VGaWxlcy9tb2RlbEVkaXRvckRpYWxvZ1wiKVxyXG5jb25zdCBtb2RlbElvVFNldHRpbmdEaWFsb2c9IHJlcXVpcmUoXCIuL21vZGVsSW9UU2V0dGluZ0RpYWxvZ1wiKVxyXG5jb25zdCB0d2luSW5mb1BhbmVsPSByZXF1aXJlKFwiLi90d2luSW5mb1BhbmVsXCIpO1xyXG5jb25zdCBtb2RlbE1hbmFnZXJEaWFsb2cgPSByZXF1aXJlKFwiLi4vc2hhcmVkU291cmNlRmlsZXMvbW9kZWxNYW5hZ2VyRGlhbG9nXCIpXHJcbmNvbnN0IHR3aW5zTGlzdD1yZXF1aXJlKFwiLi90d2luc0xpc3RcIilcclxuY29uc3QgbmV3VHdpbkRpYWxvZz1yZXF1aXJlKFwiLi4vc2hhcmVkU291cmNlRmlsZXMvbmV3VHdpbkRpYWxvZ1wiKTtcclxuY29uc3QgcHJvamVjdFNlbGVjdGlvbkRpYWxvZz1yZXF1aXJlKFwiLi9wcm9qZWN0U2VsZWN0aW9uRGlhbG9nXCIpXHJcbmNvbnN0IHNlcnZpY2VXb3JrZXJIZWxwZXI9cmVxdWlyZShcIi4uL3NoYXJlZFNvdXJjZUZpbGVzL3NlcnZpY2VXb3JrZXJIZWxwZXJcIilcclxuY29uc3QgZ2xvYmFsQ2FjaGUgPSByZXF1aXJlKFwiLi4vc2hhcmVkU291cmNlRmlsZXMvZ2xvYmFsQ2FjaGVcIilcclxuXHJcbmZ1bmN0aW9uIGRldmljZU1hbmFnZW1lbnRVSSgpIHsgICAgXHJcbiAgICBnbG9iYWxDYWNoZS5jaGVja1Rvb0xvbmdJZGxlKClcclxuICAgIGRldmljZU1hbmFnZW1lbnRNYWluVG9vbGJhci5yZW5kZXIoKVxyXG5cclxuICAgIHRoaXMubXlNU0FMT2JqID0gbmV3IG1zYWwuUHVibGljQ2xpZW50QXBwbGljYXRpb24oZ2xvYmFsQXBwU2V0dGluZ3MubXNhbENvbmZpZyk7XHJcblxyXG4gICAgdGhpcy5icm9hZGNhc3RNZXNzYWdlKClcclxuXHJcbiAgICB2YXIgdGhlQWNjb3VudD1tc2FsSGVscGVyLmZldGNoQWNjb3VudCgpO1xyXG4gICAgaWYodGhlQWNjb3VudD09bnVsbCAmJiAhZ2xvYmFsQXBwU2V0dGluZ3MuaXNMb2NhbFRlc3QpIHdpbmRvdy5vcGVuKGdsb2JhbEFwcFNldHRpbmdzLmxvZ291dFJlZGlyZWN0VXJpLFwiX3NlbGZcIilcclxuXHJcbiAgICB0aGlzLmluaXREYXRhKClcclxufVxyXG5cclxuZGV2aWNlTWFuYWdlbWVudFVJLnByb3RvdHlwZS5pbml0RGF0YT1hc3luYyBmdW5jdGlvbigpe1xyXG4gICAgdHJ5e1xyXG4gICAgICAgIGF3YWl0IG1zYWxIZWxwZXIucmVsb2FkVXNlckFjY291bnREYXRhKClcclxuICAgIH1jYXRjaChlKXtcclxuICAgICAgICBjb25zb2xlLmxvZyhlKVxyXG4gICAgICAgIGlmKGUucmVzcG9uc2VUZXh0KSBhbGVydChlLnJlc3BvbnNlVGV4dClcclxuICAgICAgICByZXR1cm5cclxuICAgIH1cclxuICAgIHByb2plY3RTZWxlY3Rpb25EaWFsb2cucG9wdXAoKVxyXG59XHJcblxyXG5kZXZpY2VNYW5hZ2VtZW50VUkucHJvdG90eXBlLmJyb2FkY2FzdE1lc3NhZ2U9ZnVuY3Rpb24oc291cmNlLG1zZ1BheWxvYWQpe1xyXG4gICAgdmFyIGNvbXBvbmVudHNBcnI9W21vZGVsTWFuYWdlckRpYWxvZyxtb2RlbEVkaXRvckRpYWxvZyxkZXZpY2VNYW5hZ2VtZW50TWFpblRvb2xiYXIsdHdpbnNMaXN0LG5ld1R3aW5EaWFsb2csbW9kZWxJb1RTZXR0aW5nRGlhbG9nLHR3aW5JbmZvUGFuZWwscHJvamVjdFNlbGVjdGlvbkRpYWxvZyxzZXJ2aWNlV29ya2VySGVscGVyLGdsb2JhbENhY2hlXVxyXG5cclxuICAgIGlmKHNvdXJjZT09bnVsbCl7XHJcbiAgICAgICAgZm9yKHZhciBpPTA7aTxjb21wb25lbnRzQXJyLmxlbmd0aDtpKyspe1xyXG4gICAgICAgICAgICB2YXIgdGhlQ29tcG9uZW50PWNvbXBvbmVudHNBcnJbaV1cclxuICAgICAgICAgICAgdGhpcy5hc3NpZ25Ccm9hZGNhc3RNZXNzYWdlKHRoZUNvbXBvbmVudClcclxuICAgICAgICB9XHJcbiAgICB9ZWxzZXtcclxuICAgICAgICBmb3IodmFyIGk9MDtpPGNvbXBvbmVudHNBcnIubGVuZ3RoO2krKyl7XHJcbiAgICAgICAgICAgIHZhciB0aGVDb21wb25lbnQ9Y29tcG9uZW50c0FycltpXVxyXG4gICAgICAgICAgICBpZih0aGVDb21wb25lbnQucnhNZXNzYWdlICYmIHRoZUNvbXBvbmVudCE9c291cmNlKSB0aGVDb21wb25lbnQucnhNZXNzYWdlKG1zZ1BheWxvYWQpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmRldmljZU1hbmFnZW1lbnRVSS5wcm90b3R5cGUuYXNzaWduQnJvYWRjYXN0TWVzc2FnZT1mdW5jdGlvbih1aUNvbXBvbmVudCl7XHJcbiAgICB1aUNvbXBvbmVudC5icm9hZGNhc3RNZXNzYWdlPShtc2dPYmopPT57dGhpcy5icm9hZGNhc3RNZXNzYWdlKHVpQ29tcG9uZW50LG1zZ09iail9XHJcbn1cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBkZXZpY2VNYW5hZ2VtZW50VUkoKTsiLCJjb25zdCBtb2RlbEFuYWx5emVyPXJlcXVpcmUoXCIuLi9zaGFyZWRTb3VyY2VGaWxlcy9tb2RlbEFuYWx5emVyXCIpXHJcbmNvbnN0IHNpbXBsZVNlbGVjdE1lbnU9IHJlcXVpcmUoXCIuLi9zaGFyZWRTb3VyY2VGaWxlcy9zaW1wbGVTZWxlY3RNZW51XCIpXHJcbmNvbnN0IG1zYWxIZWxwZXI9cmVxdWlyZShcIi4uL21zYWxIZWxwZXJcIilcclxuY29uc3QgZ2xvYmFsQ2FjaGU9cmVxdWlyZShcIi4uL3NoYXJlZFNvdXJjZUZpbGVzL2dsb2JhbENhY2hlXCIpXHJcbmNvbnN0IHNpbXBsZUNvbmZpcm1EaWFsb2cgPSByZXF1aXJlKFwiLi4vc2hhcmVkU291cmNlRmlsZXMvc2ltcGxlQ29uZmlybURpYWxvZ1wiKVxyXG5cclxuZnVuY3Rpb24gbW9kZWxJb1RTZXR0aW5nRGlhbG9nKCkge1xyXG4gICAgaWYoIXRoaXMuRE9NKXtcclxuICAgICAgICB0aGlzLkRPTSA9ICQoJzxkaXYgc3R5bGU9XCJwb3NpdGlvbjphYnNvbHV0ZTt0b3A6NTAlO2JhY2tncm91bmQtY29sb3I6d2hpdGU7bGVmdDo1MCU7dHJhbnNmb3JtOiB0cmFuc2xhdGVYKC01MCUpIHRyYW5zbGF0ZVkoLTUwJSk7ei1pbmRleDo5OVwiIGNsYXNzPVwidzMtY2FyZC0yXCI+PC9kaXY+JylcclxuICAgICAgICAkKFwiYm9keVwiKS5hcHBlbmQodGhpcy5ET00pXHJcbiAgICAgICAgdGhpcy5ET00uaGlkZSgpXHJcbiAgICAgICAgZ2xvYmFsQ2FjaGUubWFrZURPTURyYWdnYWJsZSh0aGlzLkRPTSlcclxuICAgIH1cclxufVxyXG5cclxubW9kZWxJb1RTZXR0aW5nRGlhbG9nLnByb3RvdHlwZS5wb3B1cCA9IGFzeW5jIGZ1bmN0aW9uKG1vZGVsSUQpIHtcclxuICAgIHRoaXMuRE9NLnNob3coKVxyXG4gICAgdGhpcy5ET00uZW1wdHkoKVxyXG4gICAgdGhpcy5jb250ZW50RE9NID0gJCgnPGRpdiBzdHlsZT1cIndpZHRoOjYyMHB4XCI+PC9kaXY+JylcclxuICAgIHRoaXMuRE9NLmFwcGVuZCh0aGlzLmNvbnRlbnRET00pXHJcbiAgICB0aGlzLmNvbnRlbnRET00uYXBwZW5kKCQoJzxkaXYgc3R5bGU9XCJoZWlnaHQ6NDBweFwiIGNsYXNzPVwidzMtYmFyIHczLXJlZFwiPjxkaXYgY2xhc3M9XCJ3My1iYXItaXRlbVwiIHN0eWxlPVwiZm9udC1zaXplOjEuNWVtXCI+SW9UIFNldHRpbmdzPC9kaXY+PC9kaXY+JykpXHJcbiAgICB2YXIgY2xvc2VCdXR0b24gPSAkKCc8YnV0dG9uIGNsYXNzPVwidzMtYmFyLWl0ZW0gdzMtYnV0dG9uIHczLXJpZ2h0XCIgc3R5bGU9XCJmb250LXNpemU6MmVtO3BhZGRpbmctdG9wOjRweFwiPsOXPC9idXR0b24+JylcclxuICAgIHRoaXMuY29udGVudERPTS5jaGlsZHJlbignOmZpcnN0JykuYXBwZW5kKGNsb3NlQnV0dG9uKVxyXG4gICAgY2xvc2VCdXR0b24ub24oXCJjbGlja1wiLCAoKSA9PiB7IHRoaXMuRE9NLmhpZGUoKSB9KVxyXG5cclxuICAgIHZhciBva0J1dHRvbiA9ICQoJzxidXR0b24gY2xhc3M9XCJ3My1idXR0b24gdzMtY2FyZCB3My1ncmVlbiB3My1ob3Zlci1saWdodC1ncmVlblwiIHN0eWxlPVwiaGVpZ2h0OjEwMCVcIj5BY2NlcHQ8L2J1dHRvbj4nKVxyXG4gICAgdGhpcy5jb250ZW50RE9NLmNoaWxkcmVuKCc6Zmlyc3QnKS5hcHBlbmQob2tCdXR0b24pXHJcbiAgICBva0J1dHRvbi5vbihcImNsaWNrXCIsIGFzeW5jICgpID0+IHsgXHJcbiAgICAgICAgdGhpcy5jaGVja01vZGVsSW9UU2V0dGluZ0NoYW5nZSgpICAgIFxyXG4gICAgfSlcclxuXHJcbiAgICB2YXIgZmlyc3RSb3c9JCgnPGRpdiBjbGFzcz1cInczLWNlbGwtcm93XCIgc3R5bGU9XCJwYWRkaW5nLWJvdHRvbToxMHB4XCI+PC9kaXY+JylcclxuICAgIHRoaXMuY29udGVudERPTS5hcHBlbmQoZmlyc3RSb3cpXHJcbiAgICB2YXIgdG9wTGVmdERvbT0kKCc8ZGl2IGNsYXNzPVwidzMtY29udGFpbmVyIHczLWNlbGxcIiBzdHlsZT1cIlwiPjwvZGl2PicpXHJcbiAgICB2YXIgdG9wUmlnaHREb209JCgnPGRpdiBjbGFzcz1cInczLWNvbnRhaW5lciB3My1jZWxsXCIgc3R5bGU9XCJ3aWR0aDozMjBweDtwYWRkaW5nLWxlZnQ6MHB4O3BhZGRpbmctcmlnaHQ6MHB4XCIgLz4nKVxyXG4gICAgZmlyc3RSb3cuYXBwZW5kKHRvcExlZnREb20sdG9wUmlnaHREb20pXHJcblxyXG4gICAgdGhpcy5zYW1wbGVUZWxlbWV0cnlEaXY9JCgnPGRpdiBjbGFzcz1cInczLWJvcmRlclwiIHN0eWxlPVwibWFyZ2luOjVweDtoZWlnaHQ6MTAwcHg7cG9zaXRpb246cmVsYXRpdmU7b3ZlcmZsb3c6YXV0b1wiIC8+JylcclxuICAgIHRoaXMuc2FtcGxlVGVsZW1ldHJ5RGl2LmFwcGVuZCgkKCc8ZGl2IHN0eWxlPVwicGFkZGluZzoycHg7cmlnaHQ6MHB4O3Bvc2l0aW9uOmFic29sdXRlO2ZvbnQtc2l6ZTo5cHhcIiBjbGFzcz1cInczLWRhcmstZ3JheVwiPlRlbGVtZXRyeSBGb3JtYXQgU2FtcGxlPC9kaXY+JykpXHJcbiAgICB0b3BSaWdodERvbS5hcHBlbmQodGhpcy5zYW1wbGVUZWxlbWV0cnlEaXYpXHJcbiAgICB0aGlzLnNhbXBsZVRlbGVtZXRyeURpdi5oaWRlKClcclxuICAgIFxyXG4gICAgdmFyIG1vZGVsSW5mbz1tb2RlbEFuYWx5emVyLkRURExNb2RlbHNbbW9kZWxJRF1cclxuICAgIHRoaXMubW9kZWxJRD1tb2RlbElEXHJcbiAgICB2YXIgREJNb2RlbEluZm89Z2xvYmFsQ2FjaGUuZ2V0U2luZ2xlREJNb2RlbEJ5SUQobW9kZWxJRClcclxuICAgIHRoaXMuREJNb2RlbEluZm89REJNb2RlbEluZm9cclxuICAgIGlmKERCTW9kZWxJbmZvICYmIERCTW9kZWxJbmZvLmlzSW9URGV2aWNlTW9kZWwpe1xyXG4gICAgICAgIHRoaXMuaW90SW5mbz10aGlzLkRCTW9kZWxJbmZvXHJcbiAgICB9ZWxzZXtcclxuICAgICAgICB0aGlzLmlvdEluZm89bnVsbFxyXG4gICAgfVxyXG4gICAgdGhpcy5vcmlnaW5hbERlc2lyZWRQcm9wZXJ0aWVzU3RyPUpTT04uc3RyaW5naWZ5KERCTW9kZWxJbmZvLmRlc2lyZWRQcm9wZXJ0aWVzKVxyXG5cclxuICAgIHRvcExlZnREb20uYXBwZW5kKCQoXCI8ZGl2IHN0eWxlPSdwYWRkaW5nLXRvcDoxMHB4Jy8+XCIpLmFwcGVuZChcclxuICAgICAgICAkKFwiPGRpdiBjbGFzcz0ndzMtcGFkZGluZycgc3R5bGU9J2Rpc3BsYXk6aW5saW5lO2ZvbnQtd2VpZ2h0OmJvbGQ7Y29sb3I6YmxhY2snPk1vZGVsPC9kaXY+XCIpXHJcbiAgICAgICAgLCAkKCc8bGFiZWwgdHlwZT1cInRleHRcIiBzdHlsZT1cIm1hcmdpbjo4cHggMDtwYWRkaW5nOjJweDtkaXNwbGF5OmlubGluZVwiLz4nKS50ZXh0KG1vZGVsSUQpKSlcclxuICAgIHRvcExlZnREb20uYXBwZW5kKCQoXCI8ZGl2IGNsYXNzPSd3My1wYWRkaW5nLTE2Jy8+XCIpLmFwcGVuZChcclxuICAgICAgICAkKFwiPGRpdiBjbGFzcz0ndzMtcGFkZGluZycgc3R5bGU9J2Rpc3BsYXk6aW5saW5lO2ZvbnQtd2VpZ2h0OmJvbGQ7Y29sb3I6YmxhY2snPk5hbWU8L2Rpdj5cIilcclxuICAgICAgICAsICQoJzxsYWJlbCB0eXBlPVwidGV4dFwiIHN0eWxlPVwibWFyZ2luOjhweCAwO3BhZGRpbmc6MnB4O2Rpc3BsYXk6aW5saW5lXCIvPicpLnRleHQobW9kZWxJbmZvW1wiZGlzcGxheU5hbWVcIl0pKSlcclxuXHJcbiAgICB2YXIgaXNJb1RDaGVjayA9ICQoJzxpbnB1dCBjbGFzcz1cInczLWNoZWNrXCIgc3R5bGU9XCJ3aWR0aDoyMHB4O21hcmdpbi1sZWZ0OjE2cHg7bWFyZ2luLXJpZ2h0OjEwcHhcIiB0eXBlPVwiY2hlY2tib3hcIj4nKVxyXG4gICAgdmFyIGlzSW9UVGV4dCA9ICQoJzxsYWJlbCBjbGFzcz1cInczLWRhcmstZ3JheVwiIHN0eWxlPVwicGFkZGluZzoycHggOHB4O2ZvbnQtc2l6ZToxLjJlbTtib3JkZXItcmFkaXVzOiAzcHg7XCI+IFRoaXMgaXMgTk9UIGEgSW9UIE1vZGVsPC9sYWJlbD4nKVxyXG4gICAgdGhpcy5pc0lvVENoZWNrID0gaXNJb1RDaGVja1xyXG4gICAgdG9wTGVmdERvbS5hcHBlbmQoaXNJb1RDaGVjaywgaXNJb1RUZXh0KVxyXG5cclxuXHJcbiAgICB2YXIgZGlhbG9nRE9NID0gJCgnPGRpdiAvPicpXHJcbiAgICB0aGlzLmNvbnRlbnRET00uYXBwZW5kKGRpYWxvZ0RPTSlcclxuXHJcbiAgICB2YXIgZWRpdGFibGVQcm9wZXJ0aWVzPW1vZGVsSW5mby5lZGl0YWJsZVByb3BlcnRpZXNcclxuICAgIGlmKCQuaXNFbXB0eU9iamVjdChlZGl0YWJsZVByb3BlcnRpZXMpKXtcclxuICAgICAgICB2YXIgdGl0bGVUYWJsZT0kKCc8ZGl2Pldhcm5pbmc6IFRoZXJlIGlzIG5vIHByb3BlcnRpZSBpbiB0aGlzIG1vZGVsIHRvIG1hcCB3aXRoIGEgSW9UIGRldmljZTwvZGl2PicpXHJcbiAgICB9ZWxzZXtcclxuICAgICAgICB2YXIgdGl0bGVUYWJsZT0kKCc8dGFibGUgc3R5bGU9XCJ3aWR0aDoxMDAlXCIgY2VsbHNwYWNpbmc9XCIwcHhcIiBjZWxscGFkZGluZz1cIjBweFwiPjwvdGFibGU+JylcclxuICAgICAgICB0aXRsZVRhYmxlLmFwcGVuZCgkKCc8dHI+PHRkIHN0eWxlPVwiZm9udC13ZWlnaHQ6Ym9sZDsgd2lkdGg6MjIwcHhcIj5Jb1QgU2V0dGluZzwvdGQ+PHRkIHN0eWxlPVwiZm9udC13ZWlnaHQ6Ym9sZFwiPlBhcmFtZXRlciBUcmVlPC90ZD48L3RyPicpKVxyXG4gICAgICAgIHRpdGxlVGFibGUuaGlkZSgpIFxyXG4gICAgfVxyXG5cclxuICAgIGRpYWxvZ0RPTS5hcHBlbmQoJChcIjxkaXYgY2xhc3M9J3czLWNvbnRhaW5lcicvPlwiKS5hcHBlbmQodGl0bGVUYWJsZSkpXHJcblxyXG4gICAgdmFyIElvVFNldHRpbmdEaXY9JChcIjxkaXYgY2xhc3M9J3czLWNvbnRhaW5lciB3My1ib3JkZXInIHN0eWxlPSd3aWR0aDoxMDAlO21heC1oZWlnaHQ6MzAwcHg7b3ZlcmZsb3c6YXV0byc+PC9kaXY+XCIpXHJcbiAgICB0aGlzLklvVFNldHRpbmdEaXY9SW9UU2V0dGluZ0RpdlxyXG4gICAgSW9UU2V0dGluZ0Rpdi5oaWRlKClcclxuICAgIGRpYWxvZ0RPTS5hcHBlbmQoSW9UU2V0dGluZ0RpdilcclxuICAgIHRoaXMuaW90U2V0dGluZ3NBcnI9W11cclxuICAgIHRoaXMuZHJhd0lvVFNldHRpbmdzKClcclxuXHJcbiAgICBpc0lvVENoZWNrLm9uKFwiY2hhbmdlXCIsKGUpPT57XHJcbiAgICAgICAgaWYoaXNJb1RDaGVjay5wcm9wKCdjaGVja2VkJykpIHtcclxuICAgICAgICAgICAgdmFyIHRoZUhlaWdodD0gSW9UU2V0dGluZ0Rpdi5oZWlnaHQoKVxyXG4gICAgICAgICAgICBpc0lvVFRleHQucmVtb3ZlQ2xhc3MoXCJ3My1kYXJrLWdyYXlcIikuYWRkQ2xhc3MoXCJ3My1saW1lXCIpXHJcbiAgICAgICAgICAgIGlzSW9UVGV4dC50ZXh0KFwiVGhpcyBpcyBhIElvVCBNb2RlbFwiKVxyXG5cclxuICAgICAgICAgICAgaWYoIXRoaXMuaW90SW5mbykgdGhpcy5pb3RJbmZvPXRoaXMuREJNb2RlbEluZm9cclxuICAgICAgICAgICAgaWYoZS5pc1RyaWdnZXIpeyAvLyBpdCBpcyBmcm9tIHByb2dyYW1tYXRpY2FsdHJpZ2dlclxyXG4gICAgICAgICAgICAgICAgSW9UU2V0dGluZ0Rpdi5jc3MoXCJoZWlnaHRcIix0aGVIZWlnaHQrMTArXCJweFwiKVxyXG4gICAgICAgICAgICAgICAgdGl0bGVUYWJsZS5zaG93KClcclxuICAgICAgICAgICAgICAgIElvVFNldHRpbmdEaXYuc2hvdygpICAgIFxyXG4gICAgICAgICAgICAgICAgdGhpcy5zYW1wbGVUZWxlbWV0cnlEaXYuc2hvdygpXHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgSW9UU2V0dGluZ0Rpdi5jc3MoXCJoZWlnaHRcIixcIjBweFwiKVxyXG4gICAgICAgICAgICAgICAgdGl0bGVUYWJsZS5zaG93KClcclxuICAgICAgICAgICAgICAgIElvVFNldHRpbmdEaXYuc2hvdygpXHJcbiAgICAgICAgICAgICAgICBJb1RTZXR0aW5nRGl2LmFuaW1hdGUoe1wiaGVpZ2h0XCI6dGhlSGVpZ2h0KzEwK1wicHhcIn0pXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNhbXBsZVRlbGVtZXRyeURpdi5mYWRlSW4oKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfWVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmlvdEluZm89bnVsbDtcclxuICAgICAgICAgICAgaXNJb1RUZXh0LnJlbW92ZUNsYXNzKFwidzMtbGltZVwiKS5hZGRDbGFzcyhcInczLWRhcmstZ3JheVwiKVxyXG4gICAgICAgICAgICBpc0lvVFRleHQudGV4dChcIlRoaXMgaXMgTk9UIGEgSW9UIE1vZGVsXCIpXHJcbiAgICAgICAgICAgIGlmKGUuaXNUcmlnZ2VyKXsgLy8gaXQgaXMgZnJvbSBwcm9ncmFtbWF0aWNhbHRyaWdnZXJcclxuICAgICAgICAgICAgICAgIElvVFNldHRpbmdEaXYuY3NzKFwiaGVpZ2h0XCIsXCJcIik7XHJcbiAgICAgICAgICAgICAgICBJb1RTZXR0aW5nRGl2LmhpZGUoKTtcclxuICAgICAgICAgICAgICAgIHRpdGxlVGFibGUuaGlkZSgpXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNhbXBsZVRlbGVtZXRyeURpdi5oaWRlKCkgICAgXHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgSW9UU2V0dGluZ0Rpdi5hbmltYXRlKHtcImhlaWdodFwiOlwiMHB4XCJ9LCgpPT57SW9UU2V0dGluZ0Rpdi5jc3MoXCJoZWlnaHRcIixcIlwiKTtJb1RTZXR0aW5nRGl2LmhpZGUoKTt0aXRsZVRhYmxlLmhpZGUoKX0pXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNhbXBsZVRlbGVtZXRyeURpdi5mYWRlT3V0KCkgICAgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KVxyXG5cclxuICAgIGlmKHRoaXMuaW90SW5mbyl7XHJcbiAgICAgICAgaXNJb1RDaGVjay5wcm9wKCBcImNoZWNrZWRcIiwgdHJ1ZSApO1xyXG4gICAgICAgIGlzSW9UQ2hlY2sudHJpZ2dlcihcImNoYW5nZVwiKSAgICBcclxuICAgIH1cclxuXHJcbiAgICBcclxufVxyXG5cclxubW9kZWxJb1RTZXR0aW5nRGlhbG9nLnByb3RvdHlwZS5jaGVja01vZGVsSW9UU2V0dGluZ0NoYW5nZT0gZnVuY3Rpb24oKXtcclxuICAgIC8vaWYgaXQgaXMgdG8gcmVtb3ZlIHRoZSBpb3Qgc2V0dGluZyBhbmQgdGhlcmUgYXJlIHR3aW5zIHVuZGVyIHRoaXMgbW9kZWwgdGhhdCBoYXZlIGJlZW4gcHJvdmlzaW9uZWRcclxuICAgIC8vZ2l2ZSBhIHdhcm5pbmcgZGlhbG9nIHRvIGNvbmZpcm0gdGhlIGNoYW5nZVxyXG4gICAgaWYodGhpcy5pb3RJbmZvKSB7XHJcbiAgICAgICAgdGhpcy5jb21taXRDaGFuZ2UoKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgYWZmZWN0VHdpbnM9IGdsb2JhbENhY2hlLmdldERCVHdpbnNCeU1vZGVsSUQodGhpcy5tb2RlbElEKVxyXG5cclxuICAgIHZhciBwcm92aXNpb25lZFR3aW5zPVtdXHJcbiAgICBmb3IodmFyIGk9MDtpPGFmZmVjdFR3aW5zLmxlbmd0aDtpKyspe1xyXG4gICAgICAgIHZhciBvbmVUd2luPWFmZmVjdFR3aW5zW2ldXHJcbiAgICAgICAgaWYob25lVHdpbi5Jb1REZXZpY2VJRCE9bnVsbCAmJiBvbmVUd2luLklvVERldmljZUlEIT1cIlwiKXtcclxuICAgICAgICAgICAgcHJvdmlzaW9uZWRUd2lucy5wdXNoKGdsb2JhbENhY2hlLnR3aW5JRE1hcFRvRGlzcGxheU5hbWVbb25lVHdpbi5pZF0pXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmKHByb3Zpc2lvbmVkVHdpbnMubGVuZ3RoPT0wKXtcclxuICAgICAgICB0aGlzLmNvbW1pdENoYW5nZSgpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBkaWFsb2dTdHI9XCJUdXJuaW5nIG9mZiBtb2RlbCBJb1Qgc2V0dGluZyB3aWxsIGRlYWN0aXZlIFwiXHJcbiAgICBpZihwcm92aXNpb25lZFR3aW5zLmxlbmd0aD4xMCkgZGlhbG9nU3RyKz0gcHJvdmlzaW9uZWRUd2lucy5sZW5ndGggK1wiIElvVCBkZXZpY2VzIG9mIHRoaXMgbW9kZWwgdHlwZVwiXHJcbiAgICBlbHNlIGRpYWxvZ1N0cis9XCJJb1QgZGV2aWNlczogXCIrcHJvdmlzaW9uZWRUd2lucy5qb2luKClcclxuICAgIGRpYWxvZ1N0cis9XCIuIEFyZSB5b3Ugc3VyZT9cIlxyXG5cclxuICAgIHZhciBjb25maXJtRGlhbG9nRGl2PW5ldyBzaW1wbGVDb25maXJtRGlhbG9nKClcclxuXHJcbiAgICBjb25maXJtRGlhbG9nRGl2LnNob3coXHJcbiAgICAgICAgeyB3aWR0aDogXCIyNTBweFwiIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aXRsZTogXCJXYXJuaW5nXCJcclxuICAgICAgICAgICAgLCBjb250ZW50OiBkaWFsb2dTdHJcclxuICAgICAgICAgICAgLCBidXR0b25zOltcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBjb2xvckNsYXNzOiBcInczLXJlZCB3My1ob3Zlci1waW5rXCIsIHRleHQ6IFwiQ29uZmlybVwiLCBcImNsaWNrRnVuY1wiOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpcm1EaWFsb2dEaXYuY2xvc2UoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbW1pdENoYW5nZSgpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBjb2xvckNsYXNzOiBcInczLWdyYXlcIix0ZXh0OiBcIkNhbmNlbFwiLCBcImNsaWNrRnVuY1wiOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpcm1EaWFsb2dEaXYuY2xvc2UoKVxyXG4gICAgICAgICAgICAgICAgfX1cclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIH1cclxuICAgIClcclxuXHJcbn1cclxuXHJcbm1vZGVsSW9UU2V0dGluZ0RpYWxvZy5wcm90b3R5cGUuY29tbWl0Q2hhbmdlID0gYXN5bmMgZnVuY3Rpb24oKSB7XHJcbiAgICAvL2FzayB0YXNrbWFzdGVyIHRvIHVwZGF0ZSBtb2RlbCBcclxuICAgIC8vaW4gY2FzZSBvZiBpb3Qgc2V0dGluZyBlbmFibGVkLCBwcm92aXNpb24gYWxsIHR3aW5zIHRvIGlvdCBodWJcclxuICAgIC8vb3RoZXJ3aXNlLCBkZXByb3Zpc2lvbiBhbGwgdHdpbnNcclxuICAgIHZhciBwb3N0Qm9keT0ge1wibW9kZWxJRFwiOnRoaXMubW9kZWxJRH1cclxuICAgIHBvc3RCb2R5LnVwZGF0ZUluZm89e31cclxuICAgIGlmKHRoaXMuaW90SW5mbyl7XHJcbiAgICAgICAgcG9zdEJvZHkudXBkYXRlSW5mby5pc0lvVERldmljZU1vZGVsPXRydWVcclxuICAgICAgICBwb3N0Qm9keS51cGRhdGVJbmZvLnRlbGVtZXRyeVByb3BlcnRpZXM9W11cclxuICAgICAgICBwb3N0Qm9keS51cGRhdGVJbmZvLmRlc2lyZWRQcm9wZXJ0aWVzPVtdXHJcbiAgICAgICAgcG9zdEJvZHkuZGVzaXJlZEluRGV2aWNlVHdpbj17fVxyXG4gICAgICAgIHBvc3RCb2R5LnVwZGF0ZUluZm8ucmVwb3J0UHJvcGVydGllcz1bXVxyXG4gICAgICAgIHRoaXMuaW90U2V0dGluZ3NBcnIuZm9yRWFjaChlbGU9PntcclxuICAgICAgICAgICAgaWYoZWxlLnR5cGU9PVwidGVsZW1ldHJ5XCIpIHBvc3RCb2R5LnVwZGF0ZUluZm8udGVsZW1ldHJ5UHJvcGVydGllcy5wdXNoKGVsZSlcclxuICAgICAgICAgICAgZWxzZSBpZihlbGUudHlwZT09XCJkZXNpcmVkXCIpe1xyXG4gICAgICAgICAgICAgICAgcG9zdEJvZHkudXBkYXRlSW5mby5kZXNpcmVkUHJvcGVydGllcy5wdXNoKGVsZSlcclxuICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eU5hbWU9ZWxlLnBhdGhbZWxlLnBhdGgubGVuZ3RoLTFdXHJcbiAgICAgICAgICAgICAgICBwb3N0Qm9keS5kZXNpcmVkSW5EZXZpY2VUd2luW3Byb3BlcnR5TmFtZV09XCJcIlxyXG4gICAgICAgICAgICB9ZWxzZSBpZihlbGUudHlwZT09XCJyZXBvcnRcIikgcG9zdEJvZHkudXBkYXRlSW5mby5yZXBvcnRQcm9wZXJ0aWVzLnB1c2goZWxlKVxyXG4gICAgICAgIH0pXHJcbiAgICB9ZWxzZXtcclxuICAgICAgICBwb3N0Qm9keS51cGRhdGVJbmZvLmlzSW9URGV2aWNlTW9kZWw9ZmFsc2VcclxuICAgIH1cclxuXHJcbiAgICBpZih0aGlzLmlvdEluZm8pe1xyXG4gICAgICAgIHZhciBjdXJEZXNpcmVkUHJvcGVydHlTdHI9SlNPTi5zdHJpbmdpZnkocG9zdEJvZHkudXBkYXRlSW5mby5kZXNpcmVkUHJvcGVydGllcylcclxuICAgICAgICBpZihjdXJEZXNpcmVkUHJvcGVydHlTdHIhPXRoaXMub3JpZ2luYWxEZXNpcmVkUHJvcGVydGllc1N0cikge1xyXG4gICAgICAgICAgICBwb3N0Qm9keS5mb3JjZVJlZnJlc2hEZXZpY2VEZXNpcmVkPXRydWVcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcG9zdEJvZHkudXBkYXRlSW5mbyA9IEpTT04uc3RyaW5naWZ5KHBvc3RCb2R5LnVwZGF0ZUluZm8pXHJcbiAgICB0cnkge1xyXG4gICAgICAgIHZhciByZXNwb25zZSA9IGF3YWl0IG1zYWxIZWxwZXIuY2FsbEFQSShcImRldmljZW1hbmFnZW1lbnQvY2hhbmdlTW9kZWxJb1RTZXR0aW5nc1wiLCBcIlBPU1RcIiwgcG9zdEJvZHksXCJ3aXRoUHJvamVjdElEXCIpXHJcbiAgICAgICAgZ2xvYmFsQ2FjaGUuc3RvcmVTaW5nbGVEQk1vZGVsKHJlc3BvbnNlLnVwZGF0ZWRNb2RlbERvYylcclxuICAgICAgICBnbG9iYWxDYWNoZS5tZXJnZURCVHdpbnNBcnIocmVzcG9uc2UuREJUd2lucylcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhlKVxyXG4gICAgICAgIGlmIChlLnJlc3BvbnNlVGV4dCkgYWxlcnQoZS5yZXNwb25zZVRleHQpXHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5icm9hZGNhc3RNZXNzYWdlKHsgXCJtZXNzYWdlXCI6IFwiTW9kZWxJb1RTZXR0aW5nRWRpdGVkXCIsXCJtb2RlbElEXCI6cmVzcG9uc2UudXBkYXRlZE1vZGVsRG9jLmlkIH0pXHJcbiAgICB0aGlzLkRPTS5oaWRlKClcclxufVxyXG5cclxubW9kZWxJb1RTZXR0aW5nRGlhbG9nLnByb3RvdHlwZS5kcmF3SW9UU2V0dGluZ3MgPSBhc3luYyBmdW5jdGlvbigpIHtcclxuICAgIHZhciBtb2RlbERldGFpbD0gbW9kZWxBbmFseXplci5EVERMTW9kZWxzW3RoaXMubW9kZWxJRF1cclxuICAgIHZhciBjb3B5TW9kZWxFZGl0YWJsZVByb3BlcnR5PUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobW9kZWxEZXRhaWwuZWRpdGFibGVQcm9wZXJ0aWVzKSlcclxuICAgIHZhciBpb3RUYWJsZT0kKCc8dGFibGUgc3R5bGU9XCJ3aWR0aDoxMDAlXCIgY2VsbHNwYWNpbmc9XCIwcHhcIiBjZWxscGFkZGluZz1cIjBweFwiPjwvdGFibGU+JylcclxuICAgIHRoaXMuSW9UU2V0dGluZ0Rpdi5hcHBlbmQoaW90VGFibGUpXHJcblxyXG4gICAgdmFyIGluaXRpYWxQYXRoQXJyPVtdXHJcbiAgICB0aGlzLmFsbFNlbGVjdE1lbnU9W11cclxuICAgIHZhciBsYXN0Um9vdE5vZGVSZWNvcmQ9W11cclxuICAgIHRoaXMuZHJhd0VkaXRhYmxlKGlvdFRhYmxlLGNvcHlNb2RlbEVkaXRhYmxlUHJvcGVydHksaW5pdGlhbFBhdGhBcnIsbGFzdFJvb3ROb2RlUmVjb3JkKVxyXG5cclxuICAgIHRoaXMuSW9UU2V0dGluZ0Rpdi5vbihcImNsaWNrXCIsKCk9Pnt0aGlzLnNocmlua0FsbFNlbGVjdE1lbnUoKX0pXHJcbiAgICB0aGlzLklvVFNldHRpbmdEaXYub24oXCJzY3JvbGxcIiwoKT0+e3RoaXMuc2hyaW5rQWxsU2VsZWN0TWVudSgpfSlcclxufVxyXG5cclxubW9kZWxJb1RTZXR0aW5nRGlhbG9nLnByb3RvdHlwZS5zaHJpbmtBbGxTZWxlY3RNZW51ID0gYXN5bmMgZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLmFsbFNlbGVjdE1lbnUuZm9yRWFjaChzZWxlY3RtZW51PT57XHJcbiAgICAgICAgc2VsZWN0bWVudS5zaHJpbmsoKVxyXG4gICAgfSlcclxufVxyXG5cclxubW9kZWxJb1RTZXR0aW5nRGlhbG9nLnByb3RvdHlwZS5kcmF3RWRpdGFibGUgPSBhc3luYyBmdW5jdGlvbihwYXJlbnRUYWJsZSxqc29uSW5mbyxwYXRoQXJyLGxhc3RSb290Tm9kZVJlY29yZCkge1xyXG4gICAgaWYoanNvbkluZm89PW51bGwpIHJldHVybjtcclxuICAgIHZhciBhcnI9W11cclxuICAgIGZvcih2YXIgaW5kIGluIGpzb25JbmZvKSBhcnIucHVzaChpbmQpXHJcblxyXG4gICAgZm9yKHZhciB0aGVJbmRleD0wO3RoZUluZGV4PGFyci5sZW5ndGg7dGhlSW5kZXgrKyl7XHJcbiAgICAgICAgaWYodGhlSW5kZXg9PWFyci5sZW5ndGgtMSkgbGFzdFJvb3ROb2RlUmVjb3JkW3BhdGhBcnIubGVuZ3RoXSA9dHJ1ZTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgaW5kID0gYXJyW3RoZUluZGV4XVxyXG4gICAgICAgIHZhciB0cj0kKFwiPHRyLz5cIilcclxuICAgICAgICB2YXIgbGVmdFREPSQoXCI8dGQgc3R5bGU9J3dpZHRoOjIyMHB4Jy8+XCIpXHJcbiAgICAgICAgdmFyIHJpZ2h0VEQ9JChcIjx0ZCBzdHlsZT0naGVpZ2h0OjMwcHgnLz5cIilcclxuICAgICAgICB0ci5hcHBlbmQobGVmdFRELHJpZ2h0VEQpXHJcbiAgICAgICAgcGFyZW50VGFibGUuYXBwZW5kKHRyKVxyXG4gICAgICAgIFxyXG4gICAgICAgIFxyXG4gICAgICAgIGZvcih2YXIgaT0wO2k8cGF0aEFyci5sZW5ndGg7aSsrKXtcclxuICAgICAgICAgICAgaWYoIWxhc3RSb290Tm9kZVJlY29yZFtpXSkgcmlnaHRURC5hcHBlbmQodGhpcy50cmVlTGluZURpdigyKSlcclxuICAgICAgICAgICAgZWxzZSByaWdodFRELmFwcGVuZCh0aGlzLnRyZWVMaW5lRGl2KDQpKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYodGhlSW5kZXg9PWFyci5sZW5ndGgtMSkgcmlnaHRURC5hcHBlbmQodGhpcy50cmVlTGluZURpdigzKSlcclxuICAgICAgICBlbHNlIHJpZ2h0VEQuYXBwZW5kKHRoaXMudHJlZUxpbmVEaXYoMSkpXHJcblxyXG4gICAgICAgIHZhciBwTmFtZURpdj0kKFwiPGxhYmVsIHN0eWxlPSdkaXNwbGF5OmlubGluZTtsaW5lLWhlaWdodDoyOHB4O21hcmdpbi1sZWZ0OjNweCc+XCIraW5kK1wiPC9sYWJlbD5cIilcclxuICAgICAgICByaWdodFRELmFwcGVuZChwTmFtZURpdilcclxuICAgICAgICB2YXIgbmV3UGF0aD1wYXRoQXJyLmNvbmNhdChbaW5kXSlcclxuXHJcbiAgICAgICAgaWYoQXJyYXkuaXNBcnJheShqc29uSW5mb1tpbmRdKSl7IC8vaXQgaXMgYSBlbnVtZXJhdG9yXHJcbiAgICAgICAgICAgIHZhciB0eXBlRE9NPSQoXCI8bGFiZWwgY2xhc3M9J3czLWRhcmstZ3JheScgc3R5bGU9J2ZvbnQtc2l6ZTo5cHg7cGFkZGluZzoycHg7bWFyZ2luLWxlZnQ6NXB4Jz5lbnVtPC9sYWJlbD5cIilcclxuICAgICAgICAgICAgcmlnaHRURC5hcHBlbmQodHlwZURPTSlcclxuICAgICAgICAgICAgdmFyIHZhbHVlQXJyPVtdXHJcbiAgICAgICAgICAgIGpzb25JbmZvW2luZF0uZm9yRWFjaChlbGU9Pnt2YWx1ZUFyci5wdXNoKGVsZS5lbnVtVmFsdWUpfSlcclxuICAgICAgICAgICAgdmFyIGxhYmVsMT0kKFwiPGxhYmVsIGNsYXNzPSd3My1kYXJrLWdyYXknIHN0eWxlPSdmb250LXNpemU6OXB4O3BhZGRpbmc6MnB4O21hcmdpbi1sZWZ0OjJweCc+XCIrdmFsdWVBcnIuam9pbigpK1wiPC9sYWJlbD5cIilcclxuICAgICAgICAgICAgcmlnaHRURC5hcHBlbmQobGFiZWwxKVxyXG5cclxuICAgICAgICAgICAgdmFyIElvVHNldHRpbmdPYmo9e1widHlwZVwiOlwiXCIsXCJwYXRoXCI6bmV3UGF0aCxcInB0eXBlXCI6XCJlbnVtZXJhdG9yXCJ9XHJcbiAgICAgICAgICAgIHRoaXMuaW90U2V0dGluZ3NBcnIucHVzaChJb1RzZXR0aW5nT2JqKVxyXG4gICAgICAgICAgICBJb1RzZXR0aW5nT2JqLnR5cGU9dGhpcy5jaGVja1Byb3BlcnR5UGF0aElvVFR5cGUobmV3UGF0aClcclxuICAgICAgICAgICAgdGhpcy5kcmF3SW9UU2VsZWN0RHJvcGRvd24obGVmdFRELElvVHNldHRpbmdPYmoscE5hbWVEaXYpXHJcbiAgICAgICAgfWVsc2UgaWYodHlwZW9mKGpzb25JbmZvW2luZF0pPT09XCJvYmplY3RcIikge1xyXG4gICAgICAgICAgICB0aGlzLmRyYXdFZGl0YWJsZShwYXJlbnRUYWJsZSxqc29uSW5mb1tpbmRdLG5ld1BhdGgsbGFzdFJvb3ROb2RlUmVjb3JkKVxyXG4gICAgICAgIH1lbHNlIHtcclxuICAgICAgICAgICAgdmFyIElvVHNldHRpbmdPYmo9e1widHlwZVwiOlwiXCIsXCJwYXRoXCI6bmV3UGF0aCxcInB0eXBlXCI6anNvbkluZm9baW5kXX1cclxuICAgICAgICAgICAgdGhpcy5pb3RTZXR0aW5nc0Fyci5wdXNoKElvVHNldHRpbmdPYmopXHJcbiAgICAgICAgICAgIElvVHNldHRpbmdPYmoudHlwZT10aGlzLmNoZWNrUHJvcGVydHlQYXRoSW9UVHlwZShuZXdQYXRoKVxyXG4gICAgICAgICAgICB0aGlzLmRyYXdJb1RTZWxlY3REcm9wZG93bihsZWZ0VEQsSW9Uc2V0dGluZ09iaixwTmFtZURpdilcclxuICAgICAgICAgICAgdmFyIHR5cGVET009JChcIjxsYWJlbCBjbGFzcz0ndzMtZGFyay1ncmF5JyBzdHlsZT0nZm9udC1zaXplOjlweDtwYWRkaW5nOjJweDttYXJnaW4tbGVmdDo1cHgnPlwiK2pzb25JbmZvW2luZF0rXCI8L2xhYmVsPlwiKVxyXG4gICAgICAgICAgICByaWdodFRELmFwcGVuZCh0eXBlRE9NKVxyXG4gICAgICAgIH0gXHJcbiAgICB9XHJcbn1cclxuXHJcbm1vZGVsSW9UU2V0dGluZ0RpYWxvZy5wcm90b3R5cGUuY2hlY2tQcm9wZXJ0eVBhdGhJb1RUeXBlPWZ1bmN0aW9uKHBhdGhBcnIpe1xyXG4gICAgaWYoIXRoaXMuaW90SW5mbykgcmV0dXJuIFwiXCJcclxuICAgIHZhciBkZXNpcmVkUHJvcGVydGllcz10aGlzLmlvdEluZm9bXCJkZXNpcmVkUHJvcGVydGllc1wiXVxyXG4gICAgdmFyIHJlcG9ydFByb3BlcnRpZXM9dGhpcy5pb3RJbmZvW1wicmVwb3J0UHJvcGVydGllc1wiXVxyXG4gICAgdmFyIHRlbGVtZXRyeVByb3BlcnRpZXM9dGhpcy5pb3RJbmZvW1widGVsZW1ldHJ5UHJvcGVydGllc1wiXVxyXG4gICAgdmFyIGNoZWNrUGF0aFN0cj1KU09OLnN0cmluZ2lmeShwYXRoQXJyKVxyXG4gICAgdmFyIHRtcEZ1bmM9KGFycixyZVN0cik9PntcclxuICAgICAgICBmb3IodmFyIGk9MDtpPGFyci5sZW5ndGg7aSsrKXtcclxuICAgICAgICAgICAgdmFyIGVsZVBhdGg9SlNPTi5zdHJpbmdpZnkoYXJyW2ldLnBhdGgpXHJcbiAgICAgICAgICAgIGlmKGVsZVBhdGg9PWNoZWNrUGF0aFN0cikgcmV0dXJuIHJlU3RyXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBcIlwiXHJcbiAgICB9XHJcbiAgICB2YXIgcmU9dG1wRnVuYyhkZXNpcmVkUHJvcGVydGllcyxcImRlc2lyZWRcIilcclxuICAgIGlmKHJlPT1cIlwiKSByZT10bXBGdW5jKHJlcG9ydFByb3BlcnRpZXMsXCJyZXBvcnRcIilcclxuICAgIGlmKHJlPT1cIlwiKSByZT10bXBGdW5jKHRlbGVtZXRyeVByb3BlcnRpZXMsXCJ0ZWxlbWV0cnlcIilcclxuICAgIHJldHVybiByZTtcclxufVxyXG5cclxubW9kZWxJb1RTZXR0aW5nRGlhbG9nLnByb3RvdHlwZS5kcmF3SW9UU2VsZWN0RHJvcGRvd249ZnVuY3Rpb24odGQsSW9Uc2V0dGluZ09iaixwTmFtZURpdil7XHJcbiAgICB2YXIgYVNlbGVjdE1lbnUgPSBuZXcgc2ltcGxlU2VsZWN0TWVudShcIlwiXHJcbiAgICAgICAgLCB7XHJcbiAgICAgICAgICAgIHdpZHRoOiBcIjIxMHB4XCIsXCJpc0NsaWNrYWJsZVwiOiB0cnVlLCBcIndpdGhCb3JkZXJcIjogdHJ1ZVxyXG4gICAgICAgICAgICAsIGJ1dHRvbkNTUzogeyBcInBhZGRpbmdcIjogXCI0cHggMTZweFwiIH1cclxuICAgICAgICAgICAgLFwib3B0aW9uTGlzdE1hcmdpblRvcFwiOjUwLFwib3B0aW9uTGlzdE1hcmdpbkxlZnRcIjoyMTBcclxuICAgICAgICAgICAgLFwiYWRqdXN0UG9zaXRpb25BbmNob3JcIjp0aGlzLkRPTS5vZmZzZXQoKVxyXG4gICAgICAgIH1cclxuICAgIClcclxuICAgIGFTZWxlY3RNZW51LmNhbGxCYWNrX2JlZm9yZUNsaWNrRXhwYW5kPSgpPT57XHJcbiAgICAgICAgdGhpcy5zaHJpbmtBbGxTZWxlY3RNZW51KClcclxuICAgIH1cclxuICAgIHRoaXMuYWxsU2VsZWN0TWVudS5wdXNoKGFTZWxlY3RNZW51KVxyXG4gICAgdGQuYXBwZW5kKGFTZWxlY3RNZW51LnJvd0RPTSlcclxuICAgIGFTZWxlY3RNZW51LmFkZE9wdGlvbihcIk5PVCBJb1QgRGV2aWNlIHBhcmFtZXRlclwiLFwiTk9ORVwiKVxyXG4gICAgYVNlbGVjdE1lbnUuYWRkT3B0aW9uKFwiSW9UIERldmljZSBUZWxlbWV0cnlcIixcInRlbGVtZXRyeVwiLFwidzMtbGltZVwiKVxyXG4gICAgYVNlbGVjdE1lbnUuYWRkT3B0aW9uKFwiSW9UIERldmljZSBEZXNpcmVkIFByb3BlcnR5XCIsXCJkZXNpcmVkXCIsXCJ3My1hbWJlclwiKVxyXG4gICAgYVNlbGVjdE1lbnUuYWRkT3B0aW9uKFwiSW9UIERldmljZSBSZXBvcnQgUHJvcGVydHlcIixcInJlcG9ydFwiLFwidzMtYmx1ZVwiKVxyXG5cclxuICAgIGFTZWxlY3RNZW51LmNhbGxCYWNrX2NsaWNrT3B0aW9uPShvcHRpb25UZXh0LG9wdGlvblZhbHVlLHJlYWxNb3VzZUNsaWNrLGNvbG9yQ2xhc3MpPT57XHJcbiAgICAgICAgYVNlbGVjdE1lbnUuY2hhbmdlTmFtZShvcHRpb25UZXh0KVxyXG4gICAgICAgIGlmKGNvbG9yQ2xhc3Mpe1xyXG4gICAgICAgICAgICBhU2VsZWN0TWVudS5idXR0b24uYXR0cignY2xhc3MnLCAndzMtYnV0dG9uIHczLWJvcmRlciAnK2NvbG9yQ2xhc3MpO1xyXG4gICAgICAgICAgICBwTmFtZURpdi5hdHRyKCdjbGFzcycsIGNvbG9yQ2xhc3MpO1xyXG4gICAgICAgIH0gZWxzZXtcclxuICAgICAgICAgICAgYVNlbGVjdE1lbnUuYnV0dG9uLmF0dHIoJ2NsYXNzJywgJ3czLWJ1dHRvbiB3My1ib3JkZXInKSAgIFxyXG4gICAgICAgICAgICBwTmFtZURpdi5hdHRyKCdjbGFzcycsICcnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYocmVhbE1vdXNlQ2xpY2spIHtcclxuICAgICAgICAgICAgSW9Uc2V0dGluZ09ialtcInR5cGVcIl09b3B0aW9uVmFsdWVcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yZWZyZXNoSW9UVGVsZW1ldHJ5U2FtcGxlKClcclxuICAgIH1cclxuICAgIGlmKElvVHNldHRpbmdPYmoudHlwZSE9XCJcIikgYVNlbGVjdE1lbnUudHJpZ2dlck9wdGlvblZhbHVlKElvVHNldHRpbmdPYmoudHlwZSlcclxuICAgIGVsc2UgYVNlbGVjdE1lbnUudHJpZ2dlck9wdGlvbkluZGV4KDApXHJcbn1cclxuXHJcblxyXG5cclxubW9kZWxJb1RTZXR0aW5nRGlhbG9nLnByb3RvdHlwZS5wcm9wZXJ0eVR5cGVTYW1wbGVWYWx1ZSA9IGZ1bmN0aW9uKHB0eXBlKXtcclxuICAgIC8vW1wiRW51bVwiLFwiT2JqZWN0XCIsXCJib29sZWFuXCIsXCJkYXRlXCIsXCJkYXRlVGltZVwiLFwiZG91YmxlXCIsXCJkdXJhdGlvblwiLFwiZmxvYXRcIixcImludGVnZXJcIixcImxvbmdcIixcInN0cmluZ1wiLFwidGltZVwiXVxyXG4gICAgdmFyIG1hcHBpbmc9e1xyXG4gICAgICAgIFwiZW51bWVyYXRvclwiOlwic3RyaW5nVmFsdWVcIlxyXG4gICAgICAgICxcInN0cmluZ1wiOlwic3RyaW5nVmFsdWVcIlxyXG4gICAgICAgICxcImJvb2xlYW5cIjp0cnVlXHJcbiAgICAgICAgLFwiZGF0ZVRpbWVcIjpuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcclxuICAgICAgICAsXCJkYXRlXCI6IChuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkpLnNwbGl0KFwiVFwiKVswXVxyXG4gICAgICAgICxcImRvdWJsZVwiOjAuMVxyXG4gICAgICAgICxcImZsb2F0XCI6MC4xXHJcbiAgICAgICAgLFwiZHVyYXRpb25cIjpcIlBUMTZIMzBNXCJcclxuICAgICAgICAsXCJpbnRlZ2VyXCI6MFxyXG4gICAgICAgICxcImxvbmdcIjowXHJcbiAgICAgICAgLFwidGltZVwiOiBcIlRcIisoKG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSkuc3BsaXQoXCJUXCIpWzFdKVxyXG4gICAgfVxyXG4gICAgaWYobWFwcGluZ1twdHlwZV0hPW51bGwpIHJldHVybiBtYXBwaW5nW3B0eXBlXVxyXG4gICAgZWxzZSByZXR1cm4gXCJ1bmtub3duXCJcclxufVxyXG5cclxubW9kZWxJb1RTZXR0aW5nRGlhbG9nLnByb3RvdHlwZS5yZWZyZXNoSW9UVGVsZW1ldHJ5U2FtcGxlID0gZnVuY3Rpb24oKXtcclxuICAgIHZhciBzYW1wbGVPYmo9e31cclxuICAgIHRoaXMuaW90U2V0dGluZ3NBcnIuZm9yRWFjaChvbmVwPT57XHJcbiAgICAgICAgaWYob25lcC50eXBlIT1cInRlbGVtZXRyeVwiKSByZXR1cm47XHJcbiAgICAgICAgdmFyIHBhdGhBcnI9b25lcC5wYXRoXHJcbiAgICAgICAgdmFyIHB0eXBlPW9uZXAucHR5cGVcclxuICAgICAgICBcclxuICAgICAgICB2YXIgdGhlUm9vdD1zYW1wbGVPYmpcclxuICAgICAgICBmb3IodmFyIGk9MDtpPHBhdGhBcnIubGVuZ3RoO2krKyl7XHJcbiAgICAgICAgICAgIHZhciBzdHI9cGF0aEFycltpXVxyXG4gICAgICAgICAgICBpZihpPT1wYXRoQXJyLmxlbmd0aC0xKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWVTYW1wbGU9dGhpcy5wcm9wZXJ0eVR5cGVTYW1wbGVWYWx1ZShwdHlwZSlcclxuICAgICAgICAgICAgICAgIHRoZVJvb3Rbc3RyXT12YWx1ZVNhbXBsZVxyXG4gICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgIGlmKCF0aGVSb290W3N0cl0pdGhlUm9vdFtzdHJdPXt9XHJcbiAgICAgICAgICAgICAgICB0aGVSb290PXRoZVJvb3Rbc3RyXVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSlcclxuXHJcbiAgICB2YXIgbGFiZWw9dGhpcy5zYW1wbGVUZWxlbWV0cnlEaXYuZmluZCgnOmZpcnN0LWNoaWxkJyk7XHJcbiAgICB2YXIgc2NyaXB0PSAkKCc8cHJlIHN0eWxlPVwiY29sb3I6Z3JheTttYXJnaW46MHB4XCI+JytKU09OLnN0cmluZ2lmeShzYW1wbGVPYmosbnVsbCwyKSsnPC9wcmU+JylcclxuICAgIHRoaXMuc2FtcGxlVGVsZW1ldHJ5RGl2LmVtcHR5KCkuYXBwZW5kKGxhYmVsLHNjcmlwdClcclxufVxyXG5cclxubW9kZWxJb1RTZXR0aW5nRGlhbG9nLnByb3RvdHlwZS50cmVlTGluZURpdiA9IGZ1bmN0aW9uKHR5cGVOdW1iZXIpIHtcclxuICAgIHZhciByZURpdj0kKCc8ZGl2IHN0eWxlPVwibWFyZ2luLWxlZnQ6MTBweDt3aWR0aDoxNXB4O2hlaWdodDogMTAwJTtmbG9hdDogbGVmdFwiPjwvZGl2PicpXHJcbiAgICBpZih0eXBlTnVtYmVyPT0xKXtcclxuICAgICAgICByZURpdi5hcHBlbmQoJCgnPGRpdiBjbGFzcz1cInczLWJvcmRlci1ib3R0b20gdzMtYm9yZGVyLWxlZnRcIiBzdHlsZT1cIndpZHRoOjEwMCU7aGVpZ2h0OjUwJTtcIj48L2Rpdj48ZGl2IGNsYXNzPVwidzMtYm9yZGVyLWxlZnRcIiBzdHlsZT1cIndpZHRoOjEwMCU7aGVpZ2h0OjUwJTtcIj48L2Rpdj4nKSlcclxuICAgIH1lbHNlIGlmKHR5cGVOdW1iZXI9PTIpe1xyXG4gICAgICAgIHJlRGl2LmFwcGVuZCgkKCc8ZGl2IGNsYXNzPVwidzMtYm9yZGVyLWxlZnRcIiBzdHlsZT1cIndpZHRoOjEwMCU7aGVpZ2h0OjUwJTtcIj48L2Rpdj48ZGl2IGNsYXNzPVwidzMtYm9yZGVyLWxlZnRcIiBzdHlsZT1cIndpZHRoOjEwMCU7aGVpZ2h0OjUwJTtcIj48L2Rpdj4nKSlcclxuICAgIH1lbHNlIGlmKHR5cGVOdW1iZXI9PTMpe1xyXG4gICAgICAgIHJlRGl2LmFwcGVuZCgkKCc8ZGl2IGNsYXNzPVwidzMtYm9yZGVyLWJvdHRvbSB3My1ib3JkZXItbGVmdFwiIHN0eWxlPVwid2lkdGg6MTAwJTtoZWlnaHQ6NTAlO1wiPicpKVxyXG4gICAgfWVsc2UgaWYodHlwZU51bWJlcj09NCl7XHJcbiAgICAgICAgXHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVEaXZcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBuZXcgbW9kZWxJb1RTZXR0aW5nRGlhbG9nKCk7IiwiY29uc3QgZ2xvYmFsQ2FjaGUgPSByZXF1aXJlKFwiLi4vc2hhcmVkU291cmNlRmlsZXMvZ2xvYmFsQ2FjaGVcIilcclxuY29uc3Qgc2ltcGxlU2VsZWN0TWVudT1yZXF1aXJlKFwiLi4vc2hhcmVkU291cmNlRmlsZXMvc2ltcGxlU2VsZWN0TWVudVwiKVxyXG5jb25zdCBtc2FsSGVscGVyPXJlcXVpcmUoXCIuLi9tc2FsSGVscGVyXCIpXHJcbmNvbnN0IGVkaXRQcm9qZWN0RGlhbG9nPXJlcXVpcmUoXCIuLi9zaGFyZWRTb3VyY2VGaWxlcy9lZGl0UHJvamVjdERpYWxvZ1wiKVxyXG5jb25zdCBtb2RlbE1hbmFnZXJEaWFsb2cgPSByZXF1aXJlKFwiLi4vc2hhcmVkU291cmNlRmlsZXMvbW9kZWxNYW5hZ2VyRGlhbG9nXCIpXHJcbmNvbnN0IG1vZGVsQW5hbHl6ZXIgPSByZXF1aXJlKFwiLi4vc2hhcmVkU291cmNlRmlsZXMvbW9kZWxBbmFseXplclwiKVxyXG5cclxuZnVuY3Rpb24gcHJvamVjdFNlbGVjdGlvbkRpYWxvZygpIHtcclxuICAgIGlmKCF0aGlzLkRPTSl7XHJcbiAgICAgICAgdGhpcy5ET00gPSAkKCc8ZGl2IHN0eWxlPVwicG9zaXRpb246YWJzb2x1dGU7dG9wOjUwJTtiYWNrZ3JvdW5kLWNvbG9yOndoaXRlO2xlZnQ6NTAlO3RyYW5zZm9ybTogdHJhbnNsYXRlWCgtNTAlKSB0cmFuc2xhdGVZKC01MCUpO3otaW5kZXg6OTlcIiBjbGFzcz1cInczLWNhcmQtMlwiPjwvZGl2PicpXHJcbiAgICAgICAgJChcImJvZHlcIikuYXBwZW5kKHRoaXMuRE9NKVxyXG4gICAgICAgIHRoaXMuRE9NLmhpZGUoKVxyXG4gICAgICAgIGdsb2JhbENhY2hlLm1ha2VET01EcmFnZ2FibGUodGhpcy5ET00pXHJcbiAgICB9XHJcbn1cclxuXHJcbnByb2plY3RTZWxlY3Rpb25EaWFsb2cucHJvdG90eXBlLnBvcHVwID0gYXN5bmMgZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLkRPTS5zaG93KClcclxuICAgIHRoaXMuRE9NLmVtcHR5KClcclxuICAgIHRoaXMuY29udGVudERPTSA9ICQoJzxkaXYgc3R5bGU9XCJ3aWR0aDo0NTBweFwiPjwvZGl2PicpXHJcbiAgICB0aGlzLkRPTS5hcHBlbmQodGhpcy5jb250ZW50RE9NKVxyXG4gICAgdGhpcy5jb250ZW50RE9NLmFwcGVuZCgkKCc8ZGl2IHN0eWxlPVwiaGVpZ2h0OjQwcHhcIiBjbGFzcz1cInczLWJhciB3My1yZWRcIj48ZGl2IGNsYXNzPVwidzMtYmFyLWl0ZW1cIiBzdHlsZT1cImZvbnQtc2l6ZToxLjVlbVwiPlNlbGVjdCBQcm9qZWN0PC9kaXY+PC9kaXY+JykpXHJcbiAgICB2YXIgY2xvc2VCdXR0b24gPSAkKCc8YnV0dG9uIGNsYXNzPVwidzMtYmFyLWl0ZW0gdzMtYnV0dG9uIHczLXJpZ2h0XCIgc3R5bGU9XCJmb250LXNpemU6MmVtO3BhZGRpbmctdG9wOjRweFwiPsOXPC9idXR0b24+JylcclxuICAgIHRoaXMuY29udGVudERPTS5jaGlsZHJlbignOmZpcnN0JykuYXBwZW5kKGNsb3NlQnV0dG9uKVxyXG5cclxuICAgIHRoaXMuYnV0dG9uSG9sZGVyID0gJChcIjxkaXYgc3R5bGU9J2hlaWdodDoxMDAlJz48L2Rpdj5cIilcclxuICAgIHRoaXMuY29udGVudERPTS5jaGlsZHJlbignOmZpcnN0JykuYXBwZW5kKHRoaXMuYnV0dG9uSG9sZGVyKVxyXG4gICAgY2xvc2VCdXR0b24ub24oXCJjbGlja1wiLCAoKSA9PiB7XHJcbiAgICAgICAgdGhpcy51c2VQcm9qZWN0KClcclxuICAgIH0pXHJcblxyXG4gICAgdmFyIHJvdzE9JCgnPGRpdiBjbGFzcz1cInczLWJhclwiIHN0eWxlPVwicGFkZGluZzoycHhcIj48L2Rpdj4nKVxyXG4gICAgdGhpcy5jb250ZW50RE9NLmFwcGVuZChyb3cxKVxyXG4gICAgdmFyIGxhYmxlPSQoJzxkaXYgY2xhc3M9XCJ3My1iYXItaXRlbSB3My1vcGFjaXR5XCIgc3R5bGU9XCJwYWRkaW5nLXJpZ2h0OjVweDtcIj5Qcm9qZWN0IDwvZGl2PicpXHJcbiAgICByb3cxLmFwcGVuZChsYWJsZSlcclxuICAgIHZhciBzd2l0Y2hQcm9qZWN0U2VsZWN0b3I9bmV3IHNpbXBsZVNlbGVjdE1lbnUoXCIgXCIse3dpdGhCb3JkZXI6MSxjb2xvckNsYXNzOlwidzMtbGlnaHQtZ3JheVwiLGJ1dHRvbkNTUzp7XCJwYWRkaW5nXCI6XCI1cHggMTBweFwifX0pXHJcbiAgICB0aGlzLnN3aXRjaFByb2plY3RTZWxlY3Rvcj1zd2l0Y2hQcm9qZWN0U2VsZWN0b3JcclxuICAgIHJvdzEuYXBwZW5kKHN3aXRjaFByb2plY3RTZWxlY3Rvci5ET00pXHJcbiAgICB2YXIgam9pbmVkUHJvamVjdHM9Z2xvYmFsQ2FjaGUuYWNjb3VudEluZm8uam9pbmVkUHJvamVjdHNcclxuICAgIGpvaW5lZFByb2plY3RzLmZvckVhY2goYVByb2plY3Q9PntcclxuICAgICAgICB2YXIgc3RyID0gYVByb2plY3QubmFtZVxyXG4gICAgICAgIGlmKGFQcm9qZWN0Lm93bmVyIT1nbG9iYWxDYWNoZS5hY2NvdW50SW5mby5hY2NvdW50SUQpIHN0cis9XCIgKGZyb20gXCIrYVByb2plY3Qub3duZXIrXCIpXCJcclxuICAgICAgICBzd2l0Y2hQcm9qZWN0U2VsZWN0b3IuYWRkT3B0aW9uKHN0cixhUHJvamVjdC5pZClcclxuICAgIH0pXHJcbiAgICBzd2l0Y2hQcm9qZWN0U2VsZWN0b3IuY2FsbEJhY2tfY2xpY2tPcHRpb249KG9wdGlvblRleHQsb3B0aW9uVmFsdWUpPT57XHJcbiAgICAgICAgc3dpdGNoUHJvamVjdFNlbGVjdG9yLmNoYW5nZU5hbWUob3B0aW9uVGV4dClcclxuICAgICAgICB0aGlzLmNob29zZVByb2plY3Qob3B0aW9uVmFsdWUpXHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5lZGl0UHJvamVjdEJ0bj0kKCc8YSBjbGFzcz1cInczLWJhci1pdGVtIHczLWJ1dHRvblwiIGhyZWY9XCIjXCI+PGkgY2xhc3M9XCJmYSBmYS1lZGl0IGZhLWxnXCI+PC9pPjwvYT4nKVxyXG4gICAgdGhpcy5kZWxldGVQcm9qZWN0QnRuPSQoJzxhIGNsYXNzPVwidzMtYnV0dG9uXCIgaHJlZj1cIiNcIj48aSBjbGFzcz1cImZhIGZhLXRyYXNoIGZhLWxnXCI+PC9pPjwvYT4nKVxyXG4gICAgdGhpcy5uZXdQcm9qZWN0QnRuPSQoJzxhIGNsYXNzPVwidzMtYnV0dG9uXCIgaHJlZj1cIiNcIj48aSBjbGFzcz1cImZhIGZhLXBsdXMgZmEtbGdcIj48L2k+PC9hPicpXHJcbiAgICByb3cxLmFwcGVuZCh0aGlzLmVkaXRQcm9qZWN0QnRuLHRoaXMuZGVsZXRlUHJvamVjdEJ0bix0aGlzLm5ld1Byb2plY3RCdG4pXHJcbiAgICBcclxuICAgIGlmKHRoaXMucHJldmlvdXNTZWxlY3RlZFByb2plY3QhPW51bGwpe1xyXG4gICAgICAgIHN3aXRjaFByb2plY3RTZWxlY3Rvci50cmlnZ2VyT3B0aW9uVmFsdWUodGhpcy5wcmV2aW91c1NlbGVjdGVkUHJvamVjdClcclxuICAgIH1lbHNle1xyXG4gICAgICAgIHN3aXRjaFByb2plY3RTZWxlY3Rvci50cmlnZ2VyT3B0aW9uSW5kZXgoMClcclxuICAgIH1cclxufVxyXG5cclxucHJvamVjdFNlbGVjdGlvbkRpYWxvZy5wcm90b3R5cGUuY2hvb3NlUHJvamVjdCA9IGFzeW5jIGZ1bmN0aW9uIChzZWxlY3RlZFByb2plY3RJRCkge1xyXG4gICAgdGhpcy5idXR0b25Ib2xkZXIuZW1wdHkoKVxyXG5cclxuICAgIHZhciBwcm9qZWN0SW5mbz1nbG9iYWxDYWNoZS5maW5kUHJvamVjdEluZm8oc2VsZWN0ZWRQcm9qZWN0SUQpXHJcbiAgICBpZihwcm9qZWN0SW5mby5vd25lcj09Z2xvYmFsQ2FjaGUuYWNjb3VudEluZm8uYWNjb3VudElEKXtcclxuICAgICAgICB0aGlzLmVkaXRQcm9qZWN0QnRuLnNob3coKVxyXG4gICAgICAgIHRoaXMuZGVsZXRlUHJvamVjdEJ0bi5zaG93KClcclxuICAgICAgICB0aGlzLmVkaXRQcm9qZWN0QnRuLm9uKFwiY2xpY2tcIiwgKCkgPT4geyBlZGl0UHJvamVjdERpYWxvZy5wb3B1cChwcm9qZWN0SW5mbykgfSlcclxuICAgICAgICB0aGlzLmRlbGV0ZVByb2plY3RCdG4ub24oXCJjbGlja1wiLGFzeW5jICgpPT57XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBtc2FsSGVscGVyLmNhbGxBUEkoXCJhY2NvdW50TWFuYWdlbWVudC9kZWxldGVQcm9qZWN0VG9cIiwgXCJQT1NUXCIsIHtcInByb2plY3RJRFwiOnNlbGVjdGVkUHJvamVjdElEfSlcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coZSlcclxuICAgICAgICAgICAgICAgIGlmIChlLnJlc3BvbnNlVGV4dCkgYWxlcnQoZS5yZXNwb25zZVRleHQpXHJcbiAgICAgICAgICAgICAgICByZXR1cm5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICB9ZWxzZXtcclxuICAgICAgICB0aGlzLmVkaXRQcm9qZWN0QnRuLmhpZGUoKVxyXG4gICAgICAgIHRoaXMuZGVsZXRlUHJvamVjdEJ0bi5oaWRlKClcclxuICAgIH1cclxuICAgIHRoaXMubmV3UHJvamVjdEJ0bi5vbihcImNsaWNrXCIsYXN5bmMgKCk9PntcclxuICAgICAgICB2YXIgdHNTdHI9KG5ldyBEYXRlKCkudG9Mb2NhbGVTdHJpbmcoKSkgXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdmFyIG5ld1Byb2plY3RJbmZvID0gYXdhaXQgbXNhbEhlbHBlci5jYWxsQVBJKFwiYWNjb3VudE1hbmFnZW1lbnQvbmV3UHJvamVjdFRvXCIsIFwiUE9TVFwiLCB7IFwicHJvamVjdE5hbWVcIjogXCJOZXcgUHJvamVjdCBcIiArIHRzU3RyIH0pXHJcbiAgICAgICAgICAgIGdsb2JhbENhY2hlLmFjY291bnRJbmZvLmpvaW5lZFByb2plY3RzLnVuc2hpZnQobmV3UHJvamVjdEluZm8pXHJcbiAgICAgICAgICAgIHRoaXMuc3dpdGNoUHJvamVjdFNlbGVjdG9yLmNsZWFyT3B0aW9ucygpXHJcbiAgICAgICAgICAgIHZhciBqb2luZWRQcm9qZWN0cyA9IGdsb2JhbENhY2hlLmFjY291bnRJbmZvLmpvaW5lZFByb2plY3RzXHJcbiAgICAgICAgICAgIGpvaW5lZFByb2plY3RzLmZvckVhY2goYVByb2plY3QgPT4ge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0ciA9IGFQcm9qZWN0Lm5hbWVcclxuICAgICAgICAgICAgICAgIGlmKGFQcm9qZWN0Lm93bmVyIT1nbG9iYWxDYWNoZS5hY2NvdW50SW5mby5hY2NvdW50SUQpIHN0cis9XCIgKGZyb20gXCIrYVByb2plY3Qub3duZXIrXCIpXCJcclxuICAgICAgICAgICAgICAgIHRoaXMuc3dpdGNoUHJvamVjdFNlbGVjdG9yLmFkZE9wdGlvbihzdHIsIGFQcm9qZWN0LmlkKVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAvL05PVEU6IG11c3QgcXVlcnkgdGhlIG5ldyBqb2luZWQgcHJvamVjdHMgSldUIHRva2VuIGFnYWluXHJcbiAgICAgICAgICAgIGF3YWl0IG1zYWxIZWxwZXIucmVsb2FkVXNlckFjY291bnREYXRhKClcclxuICAgICAgICAgICAgdGhpcy5zd2l0Y2hQcm9qZWN0U2VsZWN0b3IudHJpZ2dlck9wdGlvbkluZGV4KDApXHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlKVxyXG4gICAgICAgICAgICBpZiAoZS5yZXNwb25zZVRleHQpIGFsZXJ0KGUucmVzcG9uc2VUZXh0KVxyXG4gICAgICAgICAgICByZXR1cm5cclxuICAgICAgICB9XHJcbiAgICB9KVxyXG4gICAgXHJcbiAgICBpZih0aGlzLnByZXZpb3VzU2VsZWN0ZWRQcm9qZWN0ID09IHNlbGVjdGVkUHJvamVjdElEKXtcclxuICAgICAgICB2YXIgc3RhcnRCdXR0b24gPSAkKCc8YnV0dG9uIGNsYXNzPVwidzMtYnV0dG9uIHczLWNhcmQgdzMtaG92ZXItZGVlcC1vcmFuZ2UgdzMtZ3JlZW5cIiBzdHlsZT1cImhlaWdodDoxMDAlOyBtYXJnaW4tcmlnaHQ6OHB4XCI+U3RhcnQ8L2J1dHRvbj4nKVxyXG4gICAgICAgIHN0YXJ0QnV0dG9uLm9uKFwiY2xpY2tcIiwgKCkgPT4geyB0aGlzLmNsb3NlRGlhbG9nKCkgfSlcclxuICAgICAgICB0aGlzLmJ1dHRvbkhvbGRlci5hcHBlbmQoc3RhcnRCdXR0b24pXHJcbiAgICB9ZWxzZXtcclxuICAgICAgICB2YXIgc3RhcnRCdXR0b24gPSAkKCc8YnV0dG9uIGNsYXNzPVwidzMtYnV0dG9uIHczLWNhcmQgdzMtaG92ZXItZGVlcC1vcmFuZ2UgdzMtZ3JlZW5cIiBzdHlsZT1cImhlaWdodDoxMDAlOyBtYXJnaW4tcmlnaHQ6OHB4XCI+U3RhcnQ8L2J1dHRvbj4nKVxyXG4gICAgICAgIHN0YXJ0QnV0dG9uLm9uKFwiY2xpY2tcIiwgKCkgPT4geyB0aGlzLnVzZVByb2plY3QoKSB9KVxyXG4gICAgICAgIHRoaXMuYnV0dG9uSG9sZGVyLmFwcGVuZChzdGFydEJ1dHRvbilcclxuICAgIH1cclxuICAgIGdsb2JhbENhY2hlLmN1cnJlbnRQcm9qZWN0SUQgPSBzZWxlY3RlZFByb2plY3RJRFxyXG59XHJcblxyXG5wcm9qZWN0U2VsZWN0aW9uRGlhbG9nLnByb3RvdHlwZS5jbG9zZURpYWxvZz1mdW5jdGlvbigpe1xyXG4gICAgdGhpcy5ET00uaGlkZSgpXHJcbn1cclxuXHJcbnByb2plY3RTZWxlY3Rpb25EaWFsb2cucHJvdG90eXBlLnVzZVByb2plY3Q9YXN5bmMgZnVuY3Rpb24oKXtcclxuICAgIHZhciBib29sX2Jyb2FkQ2FzdFByb2plY3RDaGFuZ2VkPWZhbHNlXHJcbiAgICBpZih0aGlzLnByZXZpb3VzU2VsZWN0ZWRQcm9qZWN0IT1nbG9iYWxDYWNoZS5jdXJyZW50UHJvamVjdElEKXtcclxuICAgICAgICBnbG9iYWxDYWNoZS5pbml0U3RvcmVkSW5mb3JtdGlvbigpXHJcbiAgICAgICAgdGhpcy5wcmV2aW91c1NlbGVjdGVkUHJvamVjdD1nbG9iYWxDYWNoZS5jdXJyZW50UHJvamVjdElEXHJcbiAgICAgICAgYm9vbF9icm9hZENhc3RQcm9qZWN0Q2hhbmdlZD10cnVlXHJcbiAgICB9XHJcbiAgICB2YXIgcHJvamVjdEluZm89Z2xvYmFsQ2FjaGUuZmluZFByb2plY3RJbmZvKGdsb2JhbENhY2hlLmN1cnJlbnRQcm9qZWN0SUQpXHJcbiAgICB2YXIgcHJvamVjdE93bmVyPXByb2plY3RJbmZvLm93bmVyXHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgICB2YXIgcmVzID0gYXdhaXQgbXNhbEhlbHBlci5jYWxsQVBJKFwiZGlnaXRhbHR3aW4vZmV0Y2hQcm9qZWN0TW9kZWxzRGF0YVwiLCBcIlBPU1RcIiwgbnVsbCwgXCJ3aXRoUHJvamVjdElEXCIpXHJcbiAgICAgICAgZ2xvYmFsQ2FjaGUuc3RvcmVQcm9qZWN0TW9kZWxzRGF0YShyZXMuREJNb2RlbHMsIHJlcy5hZHRNb2RlbHMpXHJcbiAgICAgICAgbW9kZWxBbmFseXplci5jbGVhckFsbE1vZGVscygpO1xyXG4gICAgICAgIG1vZGVsQW5hbHl6ZXIuYWRkTW9kZWxzKHJlcy5hZHRNb2RlbHMpXHJcbiAgICAgICAgbW9kZWxBbmFseXplci5hbmFseXplKCk7XHJcblxyXG4gICAgICAgIHZhciByZXMgPSBhd2FpdCBtc2FsSGVscGVyLmNhbGxBUEkoXCJkaWdpdGFsdHdpbi9mZXRjaFByb2plY3RUd2luc0FuZFZpc3VhbERhdGFcIiwgXCJQT1NUXCIsIHtcInByb2plY3RPd25lclwiOnByb2plY3RPd25lcn0sIFwid2l0aFByb2plY3RJRFwiKVxyXG4gICAgICAgIGdsb2JhbENhY2hlLnN0b3JlUHJvamVjdFR3aW5zQW5kVmlzdWFsRGF0YShyZXMpXHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coZSlcclxuICAgICAgICBpZiAoZS5yZXNwb25zZVRleHQpIGFsZXJ0KGUucmVzcG9uc2VUZXh0KVxyXG4gICAgICAgIHJldHVyblxyXG4gICAgfVxyXG5cclxuICAgIGlmKGdsb2JhbENhY2hlLkRCTW9kZWxzQXJyLmxlbmd0aD09MCl7XHJcbiAgICAgICAgLy9kaXJlY3RseSBwb3B1cCB0byBtb2RlbCBtYW5hZ2VtZW50IGRpYWxvZyBhbGxvdyB1c2VyIGltcG9ydCBvciBjcmVhdGUgbW9kZWxcclxuICAgICAgICBtb2RlbE1hbmFnZXJEaWFsb2cucG9wdXAoKVxyXG4gICAgICAgIG1vZGVsTWFuYWdlckRpYWxvZy5ET00uaGlkZSgpXHJcbiAgICAgICAgbW9kZWxNYW5hZ2VyRGlhbG9nLkRPTS5mYWRlSW4oKVxyXG4gICAgICAgIC8vcG9wIHVwIHdlbGNvbWUgc2NyZWVuXHJcbiAgICAgICAgdmFyIHBvcFdpbj0kKCc8ZGl2IGNsYXNzPVwidzMtYmx1ZSB3My1jYXJkLTQgdzMtcGFkZGluZy1sYXJnZVwiIHN0eWxlPVwicG9zaXRpb246YWJzb2x1dGU7dG9wOjUwJTtiYWNrZ3JvdW5kLWNvbG9yOndoaXRlO2xlZnQ6NTAlO3RyYW5zZm9ybTogdHJhbnNsYXRlWCgtNTAlKSB0cmFuc2xhdGVZKC01MCUpO3otaW5kZXg6MTA1O3dpZHRoOjQwMHB4O2N1cnNvcjpkZWZhdWx0XCI+PC9kaXY+JylcclxuICAgICAgICBwb3BXaW4uaHRtbChgV2VsY29tZSwgJHttc2FsSGVscGVyLnVzZXJOYW1lfSEgRmlyc3RseSwgbGV0J3MgaW1wb3J0IG9yIGNyZWF0ZSBhIGZldyB0d2luIG1vZGVscyB0byBzdGFydC4gPGJyLz48YnIvPkNsaWNrIHRvIGNvbnRpbnVlLi4uYClcclxuICAgICAgICAkKFwiYm9keVwiKS5hcHBlbmQocG9wV2luKVxyXG4gICAgICAgIHBvcFdpbi5vbihcImNsaWNrXCIsKCk9Pntwb3BXaW4ucmVtb3ZlKCl9KVxyXG4gICAgICAgIHNldFRpbWVvdXQoKCk9PntcclxuICAgICAgICAgICAgcG9wV2luLmZhZGVPdXQoXCJzbG93XCIsKCk9Pntwb3BXaW4ucmVtb3ZlKCl9KTtcclxuICAgICAgICB9LDMwMDApXHJcbiAgICB9XHJcblxyXG4gICAgaWYoYm9vbF9icm9hZENhc3RQcm9qZWN0Q2hhbmdlZCl7XHJcbiAgICAgICAgdGhpcy5icm9hZGNhc3RNZXNzYWdlKHsgXCJtZXNzYWdlXCI6IFwicHJvamVjdElzQ2hhbmdlZFwiLFwicHJvamVjdElEXCI6Z2xvYmFsQ2FjaGUuY3VycmVudFByb2plY3RJRH0pXHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5jbG9zZURpYWxvZygpXHJcbn1cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBwcm9qZWN0U2VsZWN0aW9uRGlhbG9nKCk7IiwiY29uc3QgZ2xvYmFsQ2FjaGUgPSByZXF1aXJlKFwiLi4vc2hhcmVkU291cmNlRmlsZXMvZ2xvYmFsQ2FjaGVcIik7XHJcbmNvbnN0IG5ld1R3aW5EaWFsb2c9cmVxdWlyZShcIi4uL3NoYXJlZFNvdXJjZUZpbGVzL25ld1R3aW5EaWFsb2dcIik7XHJcbmNvbnN0IG1vZGVsSW9UU2V0dGluZ0RpYWxvZyA9IHJlcXVpcmUoXCIuL21vZGVsSW9UU2V0dGluZ0RpYWxvZ1wiKVxyXG5jb25zdCBzaW1wbGVFeHBhbmRhYmxlU2VjdGlvbiA9IHJlcXVpcmUoXCIuLi9zaGFyZWRTb3VyY2VGaWxlcy9zaW1wbGVFeHBhbmRhYmxlU2VjdGlvblwiKVxyXG5cclxuZnVuY3Rpb24gc2luZ2xlTW9kZWxUd2luc0xpc3Qoc2luZ2xlQURUTW9kZWwscGFyZW50VHdpbnNMaXN0KSB7XHJcbiAgICB0aGlzLnBhcmVudFR3aW5zTGlzdD1wYXJlbnRUd2luc0xpc3RcclxuICAgIHRoaXMuaW5mbz1zaW5nbGVBRFRNb2RlbFxyXG4gICAgdGhpcy5jaGlsZFR3aW5zPVtdXHJcbiAgICB0aGlzLm5hbWU9c2luZ2xlQURUTW9kZWwuZGlzcGxheU5hbWU7XHJcbiAgICB0aGlzLmNyZWF0ZURPTSgpXHJcbn1cclxuXHJcbnNpbmdsZU1vZGVsVHdpbnNMaXN0LnByb3RvdHlwZS5yZW1vdmVNZW1vcnlSZWZlcmVuY2U9ZnVuY3Rpb24oKXtcclxuICAgIGZvcih2YXIgaW5kIGluIHRoaXMpIHRoaXNbaW5kXT1udWxsXHJcbn1cclxuXHJcbnNpbmdsZU1vZGVsVHdpbnNMaXN0LnByb3RvdHlwZS5jcmVhdGVET009ZnVuY3Rpb24oKXtcclxuICAgIHZhciBvbmVTZWN0aW9uPSBuZXcgc2ltcGxlRXhwYW5kYWJsZVNlY3Rpb24oXCJQcm9wZXJ0aWVzIFNlY3Rpb25cIix0aGlzLnBhcmVudFR3aW5zTGlzdC5ET00se1wibWFyZ2luVG9wXCI6XCIxcHhcIn0pXHJcbiAgICB0aGlzLm9uZVNlY3Rpb249b25lU2VjdGlvblxyXG4gICAgdGhpcy5saXN0RE9NPW9uZVNlY3Rpb24ubGlzdERPTVxyXG5cclxuICAgIC8vZmlsbCBpbiB0aGUgdHdpbnMgdW5kZXIgdGhpcyBtb2RlbFxyXG4gICAgdmFyIHR3aW5zPVtdXHJcbiAgICBmb3IodmFyIHR3aW5JRCBpbiBnbG9iYWxDYWNoZS5EQlR3aW5zKXtcclxuICAgICAgICB2YXIgYVR3aW49Z2xvYmFsQ2FjaGUuREJUd2luc1t0d2luSURdXHJcbiAgICAgICAgaWYoYVR3aW4ubW9kZWxJRD09dGhpcy5pbmZvW1wiQGlkXCJdKSB0d2lucy5wdXNoKGFUd2luKVxyXG4gICAgfVxyXG4gICAgdHdpbnMuc29ydChmdW5jdGlvbiAoYSwgYikgeyBcclxuICAgICAgICB2YXIgYU5hbWU9YS5kaXNwbGF5TmFtZS50b0xvd2VyQ2FzZSgpXHJcbiAgICAgICAgdmFyIGJOYW1lPWIuZGlzcGxheU5hbWUudG9Mb3dlckNhc2UoKVxyXG4gICAgICAgIHJldHVybiBhTmFtZS5sb2NhbGVDb21wYXJlKGJOYW1lKSBcclxuICAgIH0pO1xyXG4gICAgdHdpbnMuZm9yRWFjaChhVHdpbj0+e1xyXG4gICAgICAgIHRoaXMuY2hpbGRUd2lucy5wdXNoKG5ldyBzaW5nbGVUd2luSWNvbihhVHdpbix0aGlzKSlcclxuICAgIH0pXHJcblxyXG4gICAgdGhpcy5yZWZyZXNoTmFtZSgpXHJcbn1cclxuXHJcbnNpbmdsZU1vZGVsVHdpbnNMaXN0LnByb3RvdHlwZS5hZGRUd2luPWZ1bmN0aW9uKERCVHdpbkluZm8pe1xyXG4gICAgdGhpcy5jaGlsZFR3aW5zLnB1c2gobmV3IHNpbmdsZVR3aW5JY29uKERCVHdpbkluZm8sdGhpcykpXHJcbiAgICB0aGlzLnJlZnJlc2hOYW1lKClcclxufVxyXG5cclxuXHJcbnNpbmdsZU1vZGVsVHdpbnNMaXN0LnByb3RvdHlwZS5yZWZyZXNoTmFtZT1mdW5jdGlvbigpe1xyXG4gICAgdGhpcy5vbmVTZWN0aW9uLmhlYWRlclRleHRET00uZW1wdHkoKVxyXG4gICAgdmFyIG5hbWVEaXY9JChcIjxkaXYgY2xhc3M9J3czLXRleHQtZGFyay1ncmF5JyBzdHlsZT0nZGlzcGxheTppbmxpbmU7cGFkZGluZy1yaWdodDozcHg7dmVydGljYWwtYWxpZ246bWlkZGxlO2ZvbnQtd2VpZ2h0OmJvbGQ7Y29sb3I6ZGFya2dyYXknPjwvZGl2PlwiKVxyXG4gICAgbmFtZURpdi50ZXh0KHRoaXMubmFtZSlcclxuXHJcbiAgICB2YXIgbW9kZWxJRD10aGlzLmluZm9bXCJAaWRcIl1cclxuICAgIHZhciBzaW5nbGVEQk1vZGVsPSBnbG9iYWxDYWNoZS5nZXRTaW5nbGVEQk1vZGVsQnlJRChtb2RlbElEKVxyXG5cclxuICAgIHZhciBjb3VudFR3aW5zPTBcclxuICAgIHZhciBjb3VudElvVERldmljZXM9MFxyXG4gICAgdGhpcy5jaGlsZFR3aW5zLmZvckVhY2goYVR3aW49PntcclxuICAgICAgICBjb3VudFR3aW5zKytcclxuICAgICAgICBpZihhVHdpbi50d2luSW5mb1tcIklvVERldmljZUlEXCJdIT1udWxsKSBjb3VudElvVERldmljZXMrK1xyXG4gICAgfSlcclxuICAgIHZhciBudW1iZXJsYWJlbD0kKFwiPGxhYmVsIHN0eWxlPSdkaXNwbGF5OmlubGluZTtmb250LXNpemU6OXB4O3BhZGRpbmc6MnB4IDRweDtmb250LXdlaWdodDpub3JtYWw7Ym9yZGVyLXJhZGl1czogMnB4Oyc+XCIrY291bnRUd2lucytcIiB0d2luczwvbGFiZWw+XCIpXHJcbiAgICBpZihjb3VudFR3aW5zPT0wKSBudW1iZXJsYWJlbC5hZGRDbGFzcyhcInczLWdyYXlcIilcclxuICAgIGVsc2UgbnVtYmVybGFiZWwuYWRkQ2xhc3MoXCJ3My1vcmFuZ2VcIilcclxuXHJcbiAgICB2YXIgbnVtYmVybGFiZWwyPSQoXCI8bGFiZWwgY2xhc3M9J3czLWxpbWUnIHN0eWxlPSdkaXNwbGF5OmlubGluZTtmb250LXNpemU6OXB4O3BhZGRpbmc6MnB4IDRweDtmb250LXdlaWdodDpub3JtYWw7Ym9yZGVyLXJhZGl1czogMnB4Oyc+XCIrY291bnRJb1REZXZpY2VzK1wiIElvVCBEZXZpY2VzPC9sYWJlbD5cIilcclxuICAgIFxyXG4gICAgdmFyIGFkZEJ1dHRvbj0gJCgnPGJ1dHRvbiBjbGFzcz1cInczLXJpcHBsZSB3My1iYXItaXRlbSB3My1idXR0b24gdzMtcmVkIHczLWhvdmVyLXBpbmsgdzMtcmlnaHRcIiBzdHlsZT1cIm1hcmdpbi10b3A6MnB4O2ZvbnQtc2l6ZToxLjJlbTtwYWRkaW5nOjRweCA4cHhcIj4rPC9idXR0b24+JylcclxuICAgIGFkZEJ1dHRvbi5vbihcImNsaWNrXCIsKGUpPT57XHJcbiAgICAgICAgdGhpcy5vbmVTZWN0aW9uLmV4cGFuZCgpXHJcbiAgICAgICAgbmV3VHdpbkRpYWxvZy5wb3B1cCh7XHJcbiAgICAgICAgICAgIFwiJG1ldGFkYXRhXCI6IHtcclxuICAgICAgICAgICAgICAgIFwiJG1vZGVsXCI6IHRoaXMuaW5mb1tcIkBpZFwiXVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICByZXR1cm4gZmFsc2VcclxuICAgIH0pXHJcblxyXG4gICAgdmFyIGlvdFNldEJ1dHRvbj0kKCc8YnV0dG9uIGNsYXNzPVwidzMtcmlwcGxlIHczLWJhci1pdGVtIHczLWJ1dHRvbiB3My1yZWQgdzMtaG92ZXItcGluayB3My1yaWdodFwiIHN0eWxlPVwibWFyZ2luLXRvcDoycHg7bWFyZ2luLWxlZnQ6MTBweDtmb250LXNpemU6MS4yZW07cGFkZGluZzo0cHggOHB4XCI+PGkgY2xhc3M9XCJmYSBmYS1jb2cgZmEtbGdcIj48L2k+IElvVCBTZXR0aW5nPC9idXR0b24+JylcclxuICAgIGlvdFNldEJ1dHRvbi5vbihcImNsaWNrXCIsKGUpPT57XHJcbiAgICAgICAgdGhpcy5vbmVTZWN0aW9uLmV4cGFuZCgpXHJcbiAgICAgICAgbW9kZWxJb1RTZXR0aW5nRGlhbG9nLnBvcHVwKHRoaXMuaW5mb1tcIkBpZFwiXSlcclxuICAgICAgICByZXR1cm4gZmFsc2VcclxuICAgIH0pXHJcblxyXG5cclxuICAgIHRoaXMub25lU2VjdGlvbi5oZWFkZXJUZXh0RE9NLmFwcGVuZChuYW1lRGl2LG51bWJlcmxhYmVsKVxyXG4gICAgaWYoc2luZ2xlREJNb2RlbCAmJiBzaW5nbGVEQk1vZGVsLmlzSW9URGV2aWNlTW9kZWwpIHRoaXMub25lU2VjdGlvbi5oZWFkZXJUZXh0RE9NLmFwcGVuZChudW1iZXJsYWJlbDIpXHJcbiAgICB0aGlzLm9uZVNlY3Rpb24uaGVhZGVyVGV4dERPTS5hcHBlbmQoaW90U2V0QnV0dG9uLGFkZEJ1dHRvbilcclxufVxyXG5cclxuc2luZ2xlTW9kZWxUd2luc0xpc3QucHJvdG90eXBlLnJlZnJlc2hUd2luc0ljb249ZnVuY3Rpb24oKXtcclxuICAgIHRoaXMuY2hpbGRUd2lucy5mb3JFYWNoKGFUd2luPT57YVR3aW4ucmVkcmF3SWNvbigpfSlcclxufVxyXG5cclxuc2luZ2xlTW9kZWxUd2luc0xpc3QucHJvdG90eXBlLnJlZnJlc2hUd2luc0lvVFN0YXR1cz1mdW5jdGlvbigpe1xyXG4gICAgdGhpcy5jaGlsZFR3aW5zLmZvckVhY2goYVR3aW49PnthVHdpbi5yZWRyYXdJb1RTdGF0ZSgpfSlcclxufVxyXG5cclxuc2luZ2xlTW9kZWxUd2luc0xpc3QucHJvdG90eXBlLnJlZnJlc2hUd2luc0luZm89ZnVuY3Rpb24oKXtcclxuICAgIHRoaXMuY2hpbGRUd2lucy5mb3JFYWNoKGFUd2luPT57YVR3aW4ucmVmcmVzaFR3aW5JbmZvKCl9KVxyXG59XHJcblxyXG5zaW5nbGVNb2RlbFR3aW5zTGlzdC5wcm90b3R5cGUuZ2V0U2luZ2xlVHdpbkljb249ZnVuY3Rpb24odHdpbklEKXtcclxuICAgIGZvcih2YXIgaT0wO2k8dGhpcy5jaGlsZFR3aW5zLmxlbmd0aDtpKyspe1xyXG4gICAgICAgIHZhciBvbmVUd2luSWNvbj10aGlzLmNoaWxkVHdpbnNbaV1cclxuICAgICAgICBpZihvbmVUd2luSWNvbi50d2luSW5mby5pZD09dHdpbklEKSByZXR1cm4gb25lVHdpbkljb25cclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcblxyXG5cclxuXHJcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbmZ1bmN0aW9uIHNpbmdsZVR3aW5JY29uKHNpbmdsZURCVHdpbixwYXJlbnRNb2RlbFR3aW5zTGlzdCkge1xyXG4gICAgdGhpcy50d2luSW5mbz1zaW5nbGVEQlR3aW5cclxuICAgIHRoaXMucGFyZW50TW9kZWxUd2luc0xpc3Q9cGFyZW50TW9kZWxUd2luc0xpc3RcclxuICAgIHRoaXMuRE9NPSQoXCI8ZGl2IGNsYXNzPSd3My1ob3Zlci1ncmF5JyAgc3R5bGU9J3dpZHRoOjgwcHg7ZmxvYXQ6bGVmdDtoZWlnaHQ6MTAwcHg7bWFyZ2luOjhweDtjdXJzb3I6ZGVmYXVsdDt0ZXh0LWFsaWduOmNlbnRlcicvPlwiKVxyXG5cclxuICAgIHRoaXMuSW9UTGFibGU9JCgnPHNwYW4gY2xhc3M9XCJ3My10ZXh0LWFtYmVyIGZhLXN0YWNrIGZhLXhzXCIgc3R5bGU9XCJvcGFjaXR5OiAxMDA7XCI+PGkgY2xhc3M9XCJmYXMgZmEtc2lnbmFsIGZhLXN0YWNrLTJ4XCI+PC9pPjxpIGNsYXNzPVwiZmFzIGZhLXNsYXNoIGZhLXN0YWNrLTJ4XCI+PC9pPjwvc3Bhbj4nKVxyXG5cclxuICAgIHRoaXMuaWNvbkRPTT0kKFwiPGRpdiBzdHlsZT0nd2lkdGg6MzBweDtoZWlnaHQ6MzBweDttYXJnaW46MCBhdXRvO21hcmdpbi10b3A6MTBweDtwb3NpdGlvbjpyZWxhdGl2ZSc+PC9kaXY+XCIpXHJcbiAgICB0aGlzLm5hbWVET009JChcIjxkaXYgc3R5bGU9J3dvcmQtYnJlYWs6IGJyZWFrLXdvcmQ7d2lkdGg6MTAwJTt0ZXh0LWFsaWduOmNlbnRlcjttYXJnaW4tdG9wOjVweCc+XCIrdGhpcy50d2luSW5mby5kaXNwbGF5TmFtZStcIjwvZGl2PlwiKVxyXG4gICAgdGhpcy5yZWRyYXdJY29uKClcclxuICAgIHRoaXMucmVkcmF3SW9UU3RhdGUoKVxyXG4gICAgcGFyZW50TW9kZWxUd2luc0xpc3QubGlzdERPTS5hcHBlbmQodGhpcy5ET00pXHJcbiAgICB0aGlzLkRPTS5hcHBlbmQodGhpcy5Jb1RMYWJsZSwgdGhpcy5pY29uRE9NLHRoaXMubmFtZURPTSlcclxuXHJcblxyXG4gICAgdmFyIGNsaWNrRj0oZSk9PntcclxuICAgICAgICB0aGlzLmhpZ2hsaWdodCgpO1xyXG4gICAgICAgIHZhciBjbGlja0RldGFpbD1lLmRldGFpbFxyXG4gICAgICAgIGlmIChlLmN0cmxLZXkpIHtcclxuICAgICAgICAgICAgdGhpcy5wYXJlbnRNb2RlbFR3aW5zTGlzdC5wYXJlbnRUd2luc0xpc3QuYXBwZW5kVHdpbkljb25Ub1NlbGVjdGlvbih0aGlzKVxyXG4gICAgICAgICAgICB0aGlzLnBhcmVudE1vZGVsVHdpbnNMaXN0LnBhcmVudFR3aW5zTGlzdC5sYXN0Q2xpY2tlZFR3aW5JY29uPXRoaXM7XHJcbiAgICAgICAgfWVsc2UgaWYoZS5zaGlmdEtleSl7XHJcbiAgICAgICAgICAgIGlmKHRoaXMucGFyZW50TW9kZWxUd2luc0xpc3QucGFyZW50VHdpbnNMaXN0Lmxhc3RDbGlja2VkVHdpbkljb249PW51bGwpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGlja1NlbGYoKVxyXG4gICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgIHZhciBhbGxUd2luSWNvbkFycj10aGlzLnBhcmVudE1vZGVsVHdpbnNMaXN0LnBhcmVudFR3aW5zTGlzdC5nZXRBbGxUd2luSWNvbkFycigpXHJcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXgxID0gYWxsVHdpbkljb25BcnIuaW5kZXhPZih0aGlzLnBhcmVudE1vZGVsVHdpbnNMaXN0LnBhcmVudFR3aW5zTGlzdC5sYXN0Q2xpY2tlZFR3aW5JY29uKVxyXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4MiA9IGFsbFR3aW5JY29uQXJyLmluZGV4T2YodGhpcylcclxuICAgICAgICAgICAgICAgIGlmKGluZGV4MT09LTEgfHwgaW5kZXgyPT0tMSl7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGlja1NlbGYoKVxyXG4gICAgICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9zZWxlY3QgYWxsIHR3aW5pY29ucyBiZXR3ZWVuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxvd2VyST0gTWF0aC5taW4oaW5kZXgxLGluZGV4MilcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaGlnaGVyST0gTWF0aC5tYXgoaW5kZXgxLGluZGV4MilcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbWlkZGxlQXJyPWFsbFR3aW5JY29uQXJyLnNsaWNlKGxvd2VySSxoaWdoZXJJKSAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIG1pZGRsZUFyci5wdXNoKGFsbFR3aW5JY29uQXJyW2hpZ2hlckldKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50TW9kZWxUd2luc0xpc3QucGFyZW50VHdpbnNMaXN0LmFkZFR3aW5JY29uQXJyYXlUb1NlbGVjdGlvbihtaWRkbGVBcnIpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgdGhpcy5jbGlja1NlbGYoY2xpY2tEZXRhaWwpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdGhpcy5ET00ub24oXCJjbGlja1wiLChlKT0+e2NsaWNrRihlKX0pXHJcbn1cclxuXHJcbnNpbmdsZVR3aW5JY29uLnByb3RvdHlwZS5jbGlja1NlbGY9ZnVuY3Rpb24obW91c2VDbGlja0RldGFpbCl7XHJcbiAgICB0aGlzLnBhcmVudE1vZGVsVHdpbnNMaXN0LnBhcmVudFR3aW5zTGlzdC5sYXN0Q2xpY2tlZFR3aW5JY29uPXRoaXM7XHJcbiAgICB0aGlzLnBhcmVudE1vZGVsVHdpbnNMaXN0LnBhcmVudFR3aW5zTGlzdC5zZWxlY3RUd2luSWNvbih0aGlzLG1vdXNlQ2xpY2tEZXRhaWwpXHJcbn1cclxuXHJcbnNpbmdsZVR3aW5JY29uLnByb3RvdHlwZS5yZWZyZXNoVHdpbkluZm89ZnVuY3Rpb24oKXtcclxuICAgIHZhciB0d2luSUQ9dGhpcy50d2luSW5mby5pZFxyXG4gICAgdGhpcy50d2luSW5mbz1nbG9iYWxDYWNoZS5EQlR3aW5zW3R3aW5JRF1cclxufVxyXG5cclxuc2luZ2xlVHdpbkljb24ucHJvdG90eXBlLnJlZHJhd0lvVFN0YXRlPWZ1bmN0aW9uKCl7XHJcbiAgICB0aGlzLklvVExhYmxlLmNzcyhcIm9wYWNpdHlcIiwwKVxyXG4gICAgaWYodGhpcy50d2luSW5mby5Jb1REZXZpY2VJRCE9bnVsbCkge1xyXG4gICAgICAgIHRoaXMuSW9UTGFibGUuY3NzKFwib3BhY2l0eVwiLDEwMCkgLy91c2Ugb3BhY2l0eSB0byBjb250cm9sIHNvIGl0IGhvbGRzIGl0cyB2aXN1YWwgc3BhY2UgZXZlbiB3aGVuIGl0IGlzIG5vIHZpc2libGVcclxuICAgICAgICBpZih0aGlzLnR3aW5JbmZvLmNvbm5lY3RTdGF0ZSkge1xyXG4gICAgICAgICAgICB0aGlzLklvVExhYmxlLnJlbW92ZUNsYXNzKFwidzMtdGV4dC1yZWRcIilcclxuICAgICAgICAgICAgdGhpcy5Jb1RMYWJsZS5hZGRDbGFzcyhcInczLXRleHQtbGltZVwiKVxyXG4gICAgICAgICAgICB0aGlzLklvVExhYmxlLmh0bWwoJzxpIGNsYXNzPVwiZmFzIGZhLXNpZ25hbCBmYS1zdGFjay0yeFwiPjwvaT4nKVxyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICB0aGlzLklvVExhYmxlLmFkZENsYXNzKFwidzMtdGV4dC1yZWRcIilcclxuICAgICAgICAgICAgdGhpcy5Jb1RMYWJsZS5yZW1vdmVDbGFzcyhcInczLXRleHQtbGltZVwiKVxyXG4gICAgICAgICAgICB0aGlzLklvVExhYmxlLmh0bWwoJzxpIGNsYXNzPVwiZmFzIGZhLXNpZ25hbCBmYS1zdGFjay0yeFwiPjwvaT48aSBjbGFzcz1cImZhcyBmYS1zbGFzaCBmYS1zdGFjay0yeFwiPjwvaT4nKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbn1cclxuXHJcbnNpbmdsZVR3aW5JY29uLnByb3RvdHlwZS5yZWRyYXdJY29uPWZ1bmN0aW9uKCl7XHJcbiAgICB0aGlzLmljb25ET00uZW1wdHkoKVxyXG4gICAgdmFyIG1vZGVsSUQ9IHRoaXMudHdpbkluZm8ubW9kZWxJRDtcclxuXHJcbiAgICB2YXIgdmlzdWFsSnNvbj1nbG9iYWxDYWNoZS52aXN1YWxEZWZpbml0aW9uW1wiZGVmYXVsdFwiXS5kZXRhaWxcclxuICAgIHZhciBmaWxsQ29sb3I9XCJkYXJrR3JheVwiXHJcbiAgICBpZih2aXN1YWxKc29uW21vZGVsSURdICYmIHZpc3VhbEpzb25bbW9kZWxJRF0uY29sb3IpIGZpbGxDb2xvcj12aXN1YWxKc29uW21vZGVsSURdLmNvbG9yXHJcbiAgICBpZih2aXN1YWxKc29uW21vZGVsSURdKSB2YXIgc2Vjb25kQ29sb3I9dmlzdWFsSnNvblttb2RlbElEXS5zZWNvbmRDb2xvclxyXG4gICAgdmFyIGRpbWVuc2lvbj0zMDtcclxuICAgIGlmKHZpc3VhbEpzb25bbW9kZWxJRF0gJiYgdmlzdWFsSnNvblttb2RlbElEXS5kaW1lbnNpb25SYXRpbyl7XHJcbiAgICAgICAgZGltZW5zaW9uKj1wYXJzZUZsb2F0KHZpc3VhbEpzb25bbW9kZWxJRF0uZGltZW5zaW9uUmF0aW8pXHJcbiAgICAgICAgdGhpcy5pY29uRE9NLmNzcyh7XCJ3aWR0aFwiOmRpbWVuc2lvbitcInB4XCIsXCJoZWlnaHRcIjpkaW1lbnNpb24rXCJweFwifSlcclxuICAgIH0gXHJcbiAgICB2YXIgc2hhcGU9XCJlbGxpcHNlXCJcclxuICAgIGlmKHZpc3VhbEpzb25bbW9kZWxJRF0gJiYgdmlzdWFsSnNvblttb2RlbElEXS5zaGFwZSkgc2hhcGU9dmlzdWFsSnNvblttb2RlbElEXS5zaGFwZVxyXG4gICAgdmFyIGF2YXJ0YT1udWxsXHJcbiAgICBpZih2aXN1YWxKc29uW21vZGVsSURdICYmIHZpc3VhbEpzb25bbW9kZWxJRF0uYXZhcnRhKSBhdmFydGE9dmlzdWFsSnNvblttb2RlbElEXS5hdmFydGFcclxuXHJcbiAgICB2YXIgaW1nU3JjPWVuY29kZVVSSUNvbXBvbmVudChnbG9iYWxDYWNoZS5zaGFwZVN2ZyhzaGFwZSxmaWxsQ29sb3Isc2Vjb25kQ29sb3IpKVxyXG5cclxuICAgIHRoaXMuaWNvbkRPTS5hcHBlbmQoJChcIjxpbWcgc3JjPSdkYXRhOmltYWdlL3N2Zyt4bWw7dXRmOCxcIitpbWdTcmMrXCInPjwvaW1nPlwiKSlcclxuICAgIGlmKGF2YXJ0YSl7XHJcbiAgICAgICAgdmFyIGF2YXJ0YWltZz0kKGA8aW1nIHN0eWxlPSdtYXgtd2lkdGg6JHtkaW1lbnNpb24qMC43NX1weDttYXgtaGVpZ2h0OiR7ZGltZW5zaW9uKjAuNzV9cHg7cG9zaXRpb246YWJzb2x1dGU7bGVmdDo1MCU7dG9wOjUwJTt0cmFuc2Zvcm06dHJhbnNsYXRlWCgtNTAlKSB0cmFuc2xhdGVZKC01MCUpJyBzcmM9JyR7YXZhcnRhfSc+PC9pbWc+YClcclxuICAgICAgICB0aGlzLmljb25ET00uYXBwZW5kKGF2YXJ0YWltZylcclxuICAgIH1cclxufVxyXG5cclxuc2luZ2xlVHdpbkljb24ucHJvdG90eXBlLmhpZ2hsaWdodD1mdW5jdGlvbigpe1xyXG4gICAgdGhpcy5ET00uYWRkQ2xhc3MoXCJ3My1ob3Zlci1vcmFuZ2VcIilcclxuICAgIHRoaXMuRE9NLmFkZENsYXNzKFwidzMtYW1iZXJcIilcclxuICAgIHRoaXMuRE9NLnJlbW92ZUNsYXNzKFwidzMtaG92ZXItZ3JheVwiKVxyXG59XHJcbnNpbmdsZVR3aW5JY29uLnByb3RvdHlwZS5kaW09ZnVuY3Rpb24oKXtcclxuICAgIHRoaXMuRE9NLnJlbW92ZUNsYXNzKFwidzMtaG92ZXItb3JhbmdlXCIpXHJcbiAgICB0aGlzLkRPTS5yZW1vdmVDbGFzcyhcInczLWFtYmVyXCIpXHJcbiAgICB0aGlzLkRPTS5hZGRDbGFzcyhcInczLWhvdmVyLWdyYXlcIilcclxufVxyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gc2luZ2xlTW9kZWxUd2luc0xpc3Q7IiwiY29uc3QgZ2xvYmFsQ2FjaGUgPSByZXF1aXJlKFwiLi4vc2hhcmVkU291cmNlRmlsZXMvZ2xvYmFsQ2FjaGVcIilcclxuY29uc3QgbXNhbEhlbHBlciA9IHJlcXVpcmUoXCIuLi9tc2FsSGVscGVyXCIpXHJcbmNvbnN0IGJhc2VJbmZvUGFuZWwgPSByZXF1aXJlKFwiLi4vc2hhcmVkU291cmNlRmlsZXMvYmFzZUluZm9QYW5lbFwiKVxyXG5jb25zdCBzaW1wbGVFeHBhbmRhYmxlU2VjdGlvbj0gcmVxdWlyZShcIi4uL3NoYXJlZFNvdXJjZUZpbGVzL3NpbXBsZUV4cGFuZGFibGVTZWN0aW9uXCIpXHJcblxyXG5jbGFzcyB0d2luSW5mb1BhbmVsIGV4dGVuZHMgYmFzZUluZm9QYW5lbHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKClcclxuICAgICAgICB0aGlzLm9wZW5GdW5jdGlvbkJ1dHRvblNlY3Rpb249dHJ1ZVxyXG4gICAgICAgIHRoaXMub3BlblByb3BlcnRpZXNTZWN0aW9uPXRydWVcclxuICAgICAgICB0aGlzLkRPTSA9ICQoXCIjSW5mb0NvbnRlbnRcIilcclxuICAgICAgICB0aGlzLmRyYXdCdXR0b25zKG51bGwpXHJcbiAgICAgICAgdGhpcy5zZWxlY3RlZE9iamVjdHMgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGFzeW5jIHJ4TWVzc2FnZShtc2dQYXlsb2FkKSB7XHJcbiAgICAgICAgdmFyIHR0PXRoaXMuYWJjKzFcclxuICAgICAgICBcclxuICAgICAgICBpZiAobXNnUGF5bG9hZC5tZXNzYWdlID09IFwic2hvd0luZm9TZWxlY3RlZERldmljZXNcIikge1xyXG4gICAgICAgICAgICB0aGlzLkRPTS5lbXB0eSgpXHJcbiAgICAgICAgICAgIHZhciBhcnIgPSBtc2dQYXlsb2FkLmluZm87XHJcblxyXG4gICAgICAgICAgICBpZiAoYXJyID09IG51bGwgfHwgYXJyLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdCdXR0b25zKG51bGwpXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkT2JqZWN0cyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRPYmplY3RzID0gYXJyO1xyXG4gICAgICAgICAgICBpZiAoYXJyLmxlbmd0aCA9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdCdXR0b25zKFwic2luZ2xlTm9kZVwiKVxyXG4gICAgICAgICAgICAgICAgdmFyIHNpbmdsZURCVHdpbkluZm8gPSBhcnJbMF07XHJcbiAgICAgICAgICAgICAgICB2YXIgbW9kZWxJRCA9IHNpbmdsZURCVHdpbkluZm8ubW9kZWxJRFxyXG5cclxuICAgICAgICAgICAgICAgIGlmICghZ2xvYmFsQ2FjaGUuc3RvcmVkVHdpbnNbc2luZ2xlREJUd2luSW5mby5pZF0pIHtcclxuICAgICAgICAgICAgICAgICAgICAvL3F1ZXJ5IGFsbCB0d2lucyBvZiB0aGlzIHBhcmVudCBtb2RlbCBpZiB0aGV5IGhhdmVub3QgYmVlbiBxdWVyaWVkIGZyb20gQURUIHlldFxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0d2luSURzID0gW11cclxuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIHR3aW5JRCBpbiBnbG9iYWxDYWNoZS5EQlR3aW5zKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsZT1nbG9iYWxDYWNoZS5EQlR3aW5zW3R3aW5JRF1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZS5tb2RlbElEID09IG1vZGVsSUQpIHR3aW5JRHMucHVzaChlbGUuaWQpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0d2luc0RhdGEgPSBhd2FpdCBtc2FsSGVscGVyLmNhbGxBUEkoXCJkaWdpdGFsdHdpbi9saXN0VHdpbnNGb3JJRHNcIiwgXCJQT1NUXCIsIHR3aW5JRHMpXHJcbiAgICAgICAgICAgICAgICAgICAgZ2xvYmFsQ2FjaGUuc3RvcmVBRFRUd2lucyh0d2luc0RhdGEpXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHNpbmdsZUFEVFR3aW5JbmZvID0gZ2xvYmFsQ2FjaGUuc3RvcmVkVHdpbnNbc2luZ2xlREJUd2luSW5mby5pZF0gXHJcbiAgICAgICAgICAgICAgICB2YXIgcHJvcGVydGllc1NlY3Rpb249IG5ldyBzaW1wbGVFeHBhbmRhYmxlU2VjdGlvbihcIlByb3BlcnRpZXMgU2VjdGlvblwiLHRoaXMuRE9NKVxyXG4gICAgICAgICAgICAgICAgcHJvcGVydGllc1NlY3Rpb24uY2FsbEJhY2tfY2hhbmdlPShzdGF0dXMpPT57dGhpcy5vcGVuUHJvcGVydGllc1NlY3Rpb249c3RhdHVzfVxyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5vcGVuUHJvcGVydGllc1NlY3Rpb24pIHByb3BlcnRpZXNTZWN0aW9uLmV4cGFuZCgpXHJcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdTaW5nbGVOb2RlUHJvcGVydGllcyhzaW5nbGVEQlR3aW5JbmZvLHNpbmdsZUFEVFR3aW5JbmZvLHByb3BlcnRpZXNTZWN0aW9uLmxpc3RET00pXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJyLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZHJhd0J1dHRvbnMoXCJtdWx0aXBsZVwiKVxyXG4gICAgICAgICAgICAgICAgdmFyIHRleHREaXYgPSAkKFwiPGxhYmVsIHN0eWxlPSdkaXNwbGF5OmJsb2NrO21hcmdpbi10b3A6MTBweDttYXJnaW4tbGVmdDoxNnB4Jz48L2xhYmVsPlwiKVxyXG4gICAgICAgICAgICAgICAgdGV4dERpdi50ZXh0KGFyci5sZW5ndGggKyBcIiBub2RlXCIgKyAoKGFyci5sZW5ndGggPD0gMSkgPyBcIlwiIDogXCJzXCIpKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5ET00uYXBwZW5kKHRleHREaXYpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZHJhd0J1dHRvbnMoc2VsZWN0VHlwZSl7XHJcbiAgICAgICAgaWYoc2VsZWN0VHlwZT09bnVsbCl7XHJcbiAgICAgICAgICAgIHRoaXMuRE9NLmh0bWwoXCI8ZGl2IHN0eWxlPSdwYWRkaW5nOjhweCc+PGEgc3R5bGU9J2Rpc3BsYXk6YmxvY2s7Zm9udC1zdHlsZTppdGFsaWM7Y29sb3I6Z3JheSc+RGVmaW5lIElvVCBzZXR0aW5nIGluIG1vZGVsIHNvIGl0cyB0d2luIHR5cGUgY2FuIGJlIG1hcHBlZCB0byBwaHlzaWNhbCBJb1QgZGV2aWNlIHR5cGU8L2E+PGEgc3R5bGU9J2Rpc3BsYXk6YmxvY2s7Zm9udC1zdHlsZTppdGFsaWM7Y29sb3I6Z3JheTtwYWRkaW5nLXRvcDoyMHB4O3BhZGRpbmctYm90dG9tOjIwcHgnPlByZXNzIGN0cmwgb3Igc2hpZnQga2V5IHRvIHNlbGVjdCBtdWx0aXBsZSB0d2luczwvYT48L2Rpdj5cIilcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGJ1dHRvblNlY3Rpb249IG5ldyBzaW1wbGVFeHBhbmRhYmxlU2VjdGlvbihcIkZ1bmN0aW9uIEJ1dHRvbnMgU2VjdGlvblwiLHRoaXMuRE9NLHtcIm1hcmdpblRvcFwiOjB9KVxyXG4gICAgICAgIGJ1dHRvblNlY3Rpb24uY2FsbEJhY2tfY2hhbmdlPShzdGF0dXMpPT57dGhpcy5vcGVuRnVuY3Rpb25CdXR0b25TZWN0aW9uPXN0YXR1c31cclxuICAgICAgICBpZih0aGlzLm9wZW5GdW5jdGlvbkJ1dHRvblNlY3Rpb24pIGJ1dHRvblNlY3Rpb24uZXhwYW5kKClcclxuXHJcbiAgICAgICAgdmFyIGRlbEJ0biA9ICAkKCc8YnV0dG9uIHN0eWxlPVwid2lkdGg6NDUlXCIgY2xhc3M9XCJ3My1yaXBwbGUgdzMtYnV0dG9uIHczLXJlZCB3My1ob3Zlci1waW5rIHczLWJvcmRlclwiPkRlbGV0ZSBBbGw8L2J1dHRvbj4nKVxyXG4gICAgICAgIGJ1dHRvblNlY3Rpb24ubGlzdERPTS5hcHBlbmQoZGVsQnRuKVxyXG4gICAgICAgIC8vZGVsQnRuLm9uKFwiY2xpY2tcIiwoKT0+e3RoaXMuZGVsZXRlU2VsZWN0ZWQoKX0pXHJcbiAgICAgICAgdmFyIGxhdGVzdFRlbGVtZXRyeUJ0bj0kKCc8YnV0dG9uIHN0eWxlPVwid2lkdGg6NDUlXCIgIGNsYXNzPVwidzMtcmlwcGxlIHczLWJ1dHRvbiB3My1ib3JkZXJcIj5UZWxlbWV0cnk8L2J1dHRvbj4nKVxyXG4gICAgICAgIGJ1dHRvblNlY3Rpb24ubGlzdERPTS5hcHBlbmQobGF0ZXN0VGVsZW1ldHJ5QnRuKVxyXG4gICAgXHJcbiAgICAgICAgdmFyIGFsbEFyZUlPVD10cnVlXHJcbiAgICAgICAgZm9yKHZhciBpPTA7aTx0aGlzLnNlbGVjdGVkT2JqZWN0cy5sZW5ndGg7aSsrKXtcclxuICAgICAgICAgICAgdmFyIG1vZGVsSUQ9dGhpcy5zZWxlY3RlZE9iamVjdHNbaV0ubW9kZWxJRFxyXG4gICAgICAgICAgICB2YXIgdGhlREJNb2RlbD1nbG9iYWxDYWNoZS5nZXRTaW5nbGVEQk1vZGVsQnlJRChtb2RlbElEKVxyXG4gICAgICAgICAgICBpZighdGhlREJNb2RlbC5pc0lvVERldmljZU1vZGVsKXtcclxuICAgICAgICAgICAgICAgIGFsbEFyZUlPVD1mYWxzZVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICBcclxuICAgICAgICBpZihhbGxBcmVJT1Qpe1xyXG4gICAgICAgICAgICB2YXIgcHJvdmlzaW9uQnRuID0kKCc8YnV0dG9uIHN0eWxlPVwid2lkdGg6NDUlXCIgIGNsYXNzPVwidzMtcmlwcGxlIHczLWJ1dHRvbiB3My1ib3JkZXJcIj5Jb1QgUHJvdmlzaW9uPC9idXR0b24+JylcclxuICAgICAgICAgICAgdmFyIGRlcHJvdmlzaW9uQnRuID0kKCc8YnV0dG9uIHN0eWxlPVwid2lkdGg6NDUlXCIgIGNsYXNzPVwidzMtcmlwcGxlIHczLWJ1dHRvbiB3My1ib3JkZXJcIj5Jb1QgRGVwcm92aXNpb248L2J1dHRvbj4nKVxyXG4gICAgICAgICAgICBidXR0b25TZWN0aW9uLmxpc3RET00uYXBwZW5kKHByb3Zpc2lvbkJ0bixkZXByb3Zpc2lvbkJ0bilcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmKHNlbGVjdFR5cGU9PVwic2luZ2xlTm9kZVwiKXtcclxuICAgICAgICAgICAgICAgIHZhciBzYW1wbGVDb2RlQnRuID0kKCc8YnV0dG9uIHN0eWxlPVwid2lkdGg6OTAlXCIgIGNsYXNzPVwidzMtcmlwcGxlIHczLWJ1dHRvbiB3My1ib3JkZXJcIj5TYW1wbGUgQ29kZTwvYnV0dG9uPicpXHJcbiAgICAgICAgICAgICAgICBidXR0b25TZWN0aW9uLmxpc3RET00uYXBwZW5kKHNhbXBsZUNvZGVCdG4pIFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgXHJcbiAgICAgICAgaWYoc2VsZWN0VHlwZT09XCJzaW5nbGVOb2RlXCIpe1xyXG4gICAgICAgICAgICB2YXIgcmVmcmVzaEJ0biA9JCgnPGJ1dHRvbiBzdHlsZT1cIndpZHRoOjQ1JVwiICBjbGFzcz1cInczLXJpcHBsZSB3My1idXR0b24gdzMtYm9yZGVyXCI+UmVmcmVzaDwvYnV0dG9uPicpXHJcbiAgICAgICAgICAgIHZhciBpbnB1dFNpbXVsYXRpb25CdG4gPSQoJzxidXR0b24gc3R5bGU9XCJ3aWR0aDo0NSVcIiAgY2xhc3M9XCJ3My1yaXBwbGUgdzMtYnV0dG9uIHczLWJvcmRlclwiPklucHV0IFNpbXVsYXRpb248L2J1dHRvbj4nKVxyXG4gICAgICAgICAgICBidXR0b25TZWN0aW9uLmxpc3RET00uYXBwZW5kKHJlZnJlc2hCdG4saW5wdXRTaW11bGF0aW9uQnRuKVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgIH1cclxufVxyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gbmV3IHR3aW5JbmZvUGFuZWwoKTsiLCJjb25zdCBnbG9iYWxDYWNoZSA9IHJlcXVpcmUoXCIuLi9zaGFyZWRTb3VyY2VGaWxlcy9nbG9iYWxDYWNoZVwiKTtcclxuY29uc3QgbW9kZWxBbmFseXplciA9IHJlcXVpcmUoXCIuLi9zaGFyZWRTb3VyY2VGaWxlcy9tb2RlbEFuYWx5emVyXCIpXHJcbmNvbnN0IHNpbmdsZU1vZGVsVHdpbnNMaXN0PXJlcXVpcmUoXCIuL3NpbmdsZU1vZGVsVHdpbnNMaXN0XCIpXHJcblxyXG5cclxuZnVuY3Rpb24gdHdpbnNMaXN0KCkge1xyXG4gICAgdGhpcy5ET009JChcIiNUd2luc0xpc3RcIilcclxuICAgIHRoaXMuc2luZ2xlTW9kZWxUd2luc0xpc3RBcnI9W11cclxuICAgIHRoaXMuc2VsZWN0ZWRUd2luSWNvbnM9W107XHJcblxyXG4gICAgdGhpcy5jYWxsYmFja19hZnRlclNlbGVjdFR3aW5JY29ucz0odHdpbkljb25zLG1vdXNlQ2xpY2tEZXRhaWwpPT57XHJcbiAgICAgICAgdmFyIGluZm9BcnI9W11cclxuICAgICAgICB0d2luSWNvbnMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+e1xyXG4gICAgICAgICAgICBpbmZvQXJyLnB1c2goaXRlbS50d2luSW5mbylcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmJyb2FkY2FzdE1lc3NhZ2UoeyBcIm1lc3NhZ2VcIjogXCJzaG93SW5mb1NlbGVjdGVkRGV2aWNlc1wiLCBpbmZvOmluZm9BcnIsIFwibW91c2VDbGlja0RldGFpbFwiOm1vdXNlQ2xpY2tEZXRhaWx9KVxyXG4gICAgfVxyXG59XHJcblxyXG50d2luc0xpc3QucHJvdG90eXBlLmZpbmRTaW5nbGVNb2RlbFR3aW5zTGlzdEJ5TW9kZWxJRD1mdW5jdGlvbihtb2RlbElEKXtcclxuICAgIGZvcih2YXIgaT0wO2k8dGhpcy5zaW5nbGVNb2RlbFR3aW5zTGlzdEFyci5sZW5ndGg7aSsrKXtcclxuICAgICAgICB2YXIgYU1vZGVsVHdpbnNMaXN0PXRoaXMuc2luZ2xlTW9kZWxUd2luc0xpc3RBcnJbaV1cclxuICAgICAgICBpZihhTW9kZWxUd2luc0xpc3QuaW5mb1tcIkBpZFwiXT09bW9kZWxJRCkgcmV0dXJuIGFNb2RlbFR3aW5zTGlzdFxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuXHJcbnR3aW5zTGlzdC5wcm90b3R5cGUucmVmaWxsPWZ1bmN0aW9uKCl7XHJcbiAgICB0aGlzLkRPTS5lbXB0eSgpXHJcbiAgICB0aGlzLnNpbmdsZU1vZGVsVHdpbnNMaXN0QXJyLmZvckVhY2goZWxlPT57ZWxlLnJlbW92ZU1lbW9yeVJlZmVyZW5jZSgpfSlcclxuXHJcbiAgICB0aGlzLnNpbmdsZU1vZGVsVHdpbnNMaXN0QXJyLmxlbmd0aD0wXHJcblxyXG4gICAgZm9yKHZhciBpbmQgaW4gbW9kZWxBbmFseXplci5EVERMTW9kZWxzKXtcclxuICAgICAgICB0aGlzLnNpbmdsZU1vZGVsVHdpbnNMaXN0QXJyLnB1c2gobmV3IHNpbmdsZU1vZGVsVHdpbnNMaXN0KG1vZGVsQW5hbHl6ZXIuRFRETE1vZGVsc1tpbmRdLHRoaXMsdGhpcy5ET00pKVxyXG4gICAgfVxyXG5cclxufVxyXG5cclxudHdpbnNMaXN0LnByb3RvdHlwZS5yeE1lc3NhZ2U9ZnVuY3Rpb24obXNnUGF5bG9hZCl7XHJcbiAgICBpZihtc2dQYXlsb2FkLm1lc3NhZ2U9PVwicHJvamVjdElzQ2hhbmdlZFwiKXtcclxuICAgICAgICB0aGlzLnJlZmlsbCgpXHJcbiAgICB9ZWxzZSBpZihtc2dQYXlsb2FkLm1lc3NhZ2U9PVwidmlzdWFsRGVmaW5pdGlvbkNoYW5nZVwiKXtcclxuICAgICAgICBpZihtc2dQYXlsb2FkLm1vZGVsSUQpICB2YXIgdGhlU2luZ2xlTW9kZWxUd2luc0xpc3Q9dGhpcy5maW5kU2luZ2xlTW9kZWxUd2luc0xpc3RCeU1vZGVsSUQobXNnUGF5bG9hZC5tb2RlbElEKVxyXG4gICAgICAgIHRoZVNpbmdsZU1vZGVsVHdpbnNMaXN0LnJlZnJlc2hUd2luc0ljb24oKVxyXG4gICAgfWVsc2UgaWYobXNnUGF5bG9hZC5tZXNzYWdlPT1cIk1vZGVsSW9UU2V0dGluZ0VkaXRlZFwiKXtcclxuICAgICAgICBpZihtc2dQYXlsb2FkLm1vZGVsSUQpICB2YXIgdGhlU2luZ2xlTW9kZWxUd2luc0xpc3Q9dGhpcy5maW5kU2luZ2xlTW9kZWxUd2luc0xpc3RCeU1vZGVsSUQobXNnUGF5bG9hZC5tb2RlbElEKVxyXG4gICAgICAgIHRoZVNpbmdsZU1vZGVsVHdpbnNMaXN0LnJlZnJlc2hUd2luc0luZm8oKVxyXG4gICAgICAgIHRoZVNpbmdsZU1vZGVsVHdpbnNMaXN0LnJlZnJlc2hOYW1lKClcclxuICAgICAgICB0aGVTaW5nbGVNb2RlbFR3aW5zTGlzdC5yZWZyZXNoVHdpbnNJb1RTdGF0dXMoKVxyXG4gICAgfWVsc2UgaWYobXNnUGF5bG9hZC5tZXNzYWdlPT1cImFkZE5ld1R3aW5cIil7XHJcbiAgICAgICAgdmFyIHRoZVNpbmdsZU1vZGVsVHdpbnNMaXN0PXRoaXMuZmluZFNpbmdsZU1vZGVsVHdpbnNMaXN0QnlNb2RlbElEKG1zZ1BheWxvYWQuREJUd2luSW5mby5tb2RlbElEKVxyXG4gICAgICAgIHRoZVNpbmdsZU1vZGVsVHdpbnNMaXN0LmFkZFR3aW4obXNnUGF5bG9hZC5EQlR3aW5JbmZvKSBcclxuICAgIH1lbHNlIGlmKG1zZ1BheWxvYWQubWVzc2FnZT09XCJsaXZlRGF0YVwiKXtcclxuICAgICAgICB2YXIgbXNnQm9keT1tc2dQYXlsb2FkLmJvZHlcclxuICAgICAgICBpZihtc2dCb2R5LmNvbm5lY3Rpb25TdGF0ZSAmJiBtc2dCb2R5LnByb2plY3RJRD09Z2xvYmFsQ2FjaGUuY3VycmVudFByb2plY3RJRCl7XHJcbiAgICAgICAgICAgIHZhciB0d2luSUQ9bXNnQm9keS50d2luSURcclxuICAgICAgICAgICAgdmFyIHR3aW5EQkluZm89Z2xvYmFsQ2FjaGUuREJUd2luc1t0d2luSURdXHJcbiAgICAgICAgICAgIHZhciB0aGVTaW5nbGVNb2RlbFR3aW5zTGlzdD10aGlzLmZpbmRTaW5nbGVNb2RlbFR3aW5zTGlzdEJ5TW9kZWxJRCh0d2luREJJbmZvLm1vZGVsSUQpXHJcbiAgICAgICAgICAgIHZhciB0aGVUd2luSWNvbj10aGVTaW5nbGVNb2RlbFR3aW5zTGlzdC5nZXRTaW5nbGVUd2luSWNvbih0d2luSUQpXHJcbiAgICAgICAgICAgIGlmKHRoZVR3aW5JY29uKSB0aGVUd2luSWNvbi5yZWRyYXdJb1RTdGF0ZSgpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG50d2luc0xpc3QucHJvdG90eXBlLmFwcGVuZFR3aW5JY29uVG9TZWxlY3Rpb249ZnVuY3Rpb24oYVR3aW5JY29uKXtcclxuICAgIHZhciBuZXdBcnI9W10uY29uY2F0KHRoaXMuc2VsZWN0ZWRUd2luSWNvbnMpXHJcbiAgICBuZXdBcnIucHVzaChhVHdpbkljb24pXHJcbiAgICB0aGlzLnNlbGVjdFR3aW5JY29uQXJyKG5ld0FycilcclxufVxyXG5cclxudHdpbnNMaXN0LnByb3RvdHlwZS5hZGRUd2luSWNvbkFycmF5VG9TZWxlY3Rpb249ZnVuY3Rpb24oYXJyKXtcclxuICAgIHZhciBuZXdBcnIgPSB0aGlzLnNlbGVjdGVkVHdpbkljb25zXHJcbiAgICB2YXIgZmlsdGVyQXJyPWFyci5maWx0ZXIoKGl0ZW0pID0+IG5ld0Fyci5pbmRleE9mKGl0ZW0pIDwgMClcclxuICAgIG5ld0FyciA9IG5ld0Fyci5jb25jYXQoZmlsdGVyQXJyKVxyXG4gICAgdGhpcy5zZWxlY3RUd2luSWNvbkFycihuZXdBcnIpXHJcbn1cclxuXHJcbnR3aW5zTGlzdC5wcm90b3R5cGUuc2VsZWN0VHdpbkljb249ZnVuY3Rpb24oYVR3aW5JY29uLG1vdXNlQ2xpY2tEZXRhaWwpe1xyXG4gICAgdGhpcy5zZWxlY3RUd2luSWNvbkFycihbYVR3aW5JY29uXSxtb3VzZUNsaWNrRGV0YWlsKVxyXG59XHJcblxyXG50d2luc0xpc3QucHJvdG90eXBlLnNlbGVjdFR3aW5JY29uQXJyPWZ1bmN0aW9uKHR3aW5pY29uQXJyLG1vdXNlQ2xpY2tEZXRhaWwpe1xyXG4gICAgZm9yKHZhciBpPTA7aTx0aGlzLnNlbGVjdGVkVHdpbkljb25zLmxlbmd0aDtpKyspe1xyXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRUd2luSWNvbnNbaV0uZGltKClcclxuICAgIH1cclxuICAgIHRoaXMuc2VsZWN0ZWRUd2luSWNvbnMubGVuZ3RoPTA7XHJcbiAgICB0aGlzLnNlbGVjdGVkVHdpbkljb25zPXRoaXMuc2VsZWN0ZWRUd2luSWNvbnMuY29uY2F0KHR3aW5pY29uQXJyKVxyXG4gICAgZm9yKHZhciBpPTA7aTx0aGlzLnNlbGVjdGVkVHdpbkljb25zLmxlbmd0aDtpKyspe1xyXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRUd2luSWNvbnNbaV0uaGlnaGxpZ2h0KClcclxuICAgIH1cclxuXHJcbiAgICBpZih0aGlzLmNhbGxiYWNrX2FmdGVyU2VsZWN0VHdpbkljb25zKSB0aGlzLmNhbGxiYWNrX2FmdGVyU2VsZWN0VHdpbkljb25zKHRoaXMuc2VsZWN0ZWRUd2luSWNvbnMsbW91c2VDbGlja0RldGFpbClcclxufVxyXG5cclxudHdpbnNMaXN0LnByb3RvdHlwZS5nZXRBbGxUd2luSWNvbkFycj1mdW5jdGlvbigpe1xyXG4gICAgdmFyIGFsbFR3aW5JY29ucz1bXVxyXG4gICAgdGhpcy5zaW5nbGVNb2RlbFR3aW5zTGlzdEFyci5mb3JFYWNoKGFNb2RlbFR3aW5zTGlzdD0+e1xyXG4gICAgICAgIGFsbFR3aW5JY29ucz1hbGxUd2luSWNvbnMuY29uY2F0KGFNb2RlbFR3aW5zTGlzdC5jaGlsZFR3aW5zKVxyXG4gICAgfSlcclxuICAgIHJldHVybiBhbGxUd2luSWNvbnM7XHJcbn1cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyB0d2luc0xpc3QoKTsiLCJjb25zdCBzaWdudXBzaWduaW5uYW1lPVwiQjJDXzFfc2luZ3Vwc2lnbmluX3NwYWFwcDFcIlxyXG5jb25zdCBiMmNUZW5hbnROYW1lPVwiYXp1cmVpb3RiMmNcIlxyXG5cclxuY29uc3QgdXJsID0gbmV3IFVSTCh3aW5kb3cubG9jYXRpb24uaHJlZik7XHJcblxyXG52YXIgc3RyQXJyPXdpbmRvdy5sb2NhdGlvbi5ocmVmLnNwbGl0KFwiP1wiKVxyXG52YXIgaXNMb2NhbFRlc3Q9KHN0ckFyci5pbmRleE9mKFwidGVzdD0xXCIpIT0tMSlcclxuXHJcbmNvbnN0IGdsb2JhbEFwcFNldHRpbmdzPXtcclxuICAgIFwiYjJjU2lnblVwU2lnbkluTmFtZVwiOiBzaWdudXBzaWduaW5uYW1lLFxyXG4gICAgXCJiMmNTY29wZV90YXNrbWFzdGVyXCI6XCJodHRwczovL1wiK2IyY1RlbmFudE5hbWUrXCIub25taWNyb3NvZnQuY29tL3Rhc2ttYXN0ZXJtb2R1bGUvb3BlcmF0aW9uXCIsXHJcbiAgICBcImIyY1Njb3BlX2Z1bmN0aW9uc1wiOlwiaHR0cHM6Ly9cIitiMmNUZW5hbnROYW1lK1wiLm9ubWljcm9zb2Z0LmNvbS9henVyZWlvdHJvY2tzZnVuY3Rpb25zL2Jhc2ljXCIsXHJcbiAgICBcImxvZ291dFJlZGlyZWN0VXJpXCI6IHVybC5vcmlnaW4rXCIvc3BhaW5kZXguaHRtbFwiLFxyXG4gICAgXCJtc2FsQ29uZmlnXCI6e1xyXG4gICAgICAgIGF1dGg6IHtcclxuICAgICAgICAgICAgY2xpZW50SWQ6IFwiZjQ2OTNiZTUtNjAxYi00ZDBlLTkyMDgtYzM1ZDlhZDYyMzg3XCIsXHJcbiAgICAgICAgICAgIGF1dGhvcml0eTogXCJodHRwczovL1wiK2IyY1RlbmFudE5hbWUrXCIuYjJjbG9naW4uY29tL1wiK2IyY1RlbmFudE5hbWUrXCIub25taWNyb3NvZnQuY29tL1wiK3NpZ251cHNpZ25pbm5hbWUsXHJcbiAgICAgICAgICAgIGtub3duQXV0aG9yaXRpZXM6IFtiMmNUZW5hbnROYW1lK1wiLmIyY2xvZ2luLmNvbVwiXSxcclxuICAgICAgICAgICAgcmVkaXJlY3RVcmk6IHdpbmRvdy5sb2NhdGlvbi5ocmVmXHJcbiAgICAgICAgfSxcclxuICAgICAgICBjYWNoZToge1xyXG4gICAgICAgICAgICBjYWNoZUxvY2F0aW9uOiBcInNlc3Npb25TdG9yYWdlXCIsIFxyXG4gICAgICAgICAgICBzdG9yZUF1dGhTdGF0ZUluQ29va2llOiBmYWxzZVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc3lzdGVtOiB7XHJcbiAgICAgICAgICAgIGxvZ2dlck9wdGlvbnM6IHtcclxuICAgICAgICAgICAgICAgIGxvZ2dlckNhbGxiYWNrOiAobGV2ZWwsIG1lc3NhZ2UsIGNvbnRhaW5zUGlpKSA9PiB7fVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIFwiaXNMb2NhbFRlc3RcIjppc0xvY2FsVGVzdCxcclxuICAgIFwidGFza01hc3RlckFQSVVSSVwiOigoaXNMb2NhbFRlc3QpP1wiaHR0cDovL2xvY2FsaG9zdDo1MDAyL1wiOlwiaHR0cHM6Ly9henVyZWlvdHJvY2tzdGFza21hc3Rlcm1vZHVsZS5henVyZXdlYnNpdGVzLm5ldC9cIiksXHJcbiAgICBcImZ1bmN0aW9uc0FQSVVSSVwiOlwiaHR0cHM6Ly9henVyZWlvdHJvY2tzZnVuY3Rpb25zLmF6dXJld2Vic2l0ZXMubmV0L2FwaS9cIlxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGdsb2JhbEFwcFNldHRpbmdzOyIsImNvbnN0IGdsb2JhbEFwcFNldHRpbmdzPXJlcXVpcmUoXCIuL2dsb2JhbEFwcFNldHRpbmdzXCIpXHJcbmNvbnN0IGdsb2JhbENhY2hlPXJlcXVpcmUoXCIuL3NoYXJlZFNvdXJjZUZpbGVzL2dsb2JhbENhY2hlXCIpXHJcblxyXG5cclxuZnVuY3Rpb24gbXNhbEhlbHBlcigpe1xyXG4gICAgdGhpcy5teU1TQUxPYmogPSBuZXcgbXNhbC5QdWJsaWNDbGllbnRBcHBsaWNhdGlvbihnbG9iYWxBcHBTZXR0aW5ncy5tc2FsQ29uZmlnKTtcclxufVxyXG5cclxubXNhbEhlbHBlci5wcm90b3R5cGUuc2lnbkluPWFzeW5jIGZ1bmN0aW9uKCl7XHJcbiAgICB0cnl7XHJcbiAgICAgICAgdmFyIHJlc3BvbnNlPSBhd2FpdCB0aGlzLm15TVNBTE9iai5sb2dpblBvcHVwKHsgc2NvcGVzOltdICB9KSAvL2dsb2JhbEFwcFNldHRpbmdzLmIyY1Njb3Blc1xyXG4gICAgICAgIGlmIChyZXNwb25zZSAhPSBudWxsKXtcclxuICAgICAgICAgICAgdGhpcy5zZXRBY2NvdW50KHJlc3BvbnNlLmFjY291bnQpXHJcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5hY2NvdW50XHJcbiAgICAgICAgfSBcclxuICAgICAgICBlbHNlICByZXR1cm4gdGhpcy5mZXRjaEFjY291bnQoKVxyXG4gICAgfWNhdGNoKGUpe1xyXG4gICAgICAgIGlmKGUuZXJyb3JDb2RlIT1cInVzZXJfY2FuY2VsbGVkXCIpIGNvbnNvbGUubG9nKGUpXHJcbiAgICB9XHJcbn1cclxuXHJcbm1zYWxIZWxwZXIucHJvdG90eXBlLnNldEFjY291bnQ9ZnVuY3Rpb24odGhlQWNjb3VudCl7XHJcbiAgICBpZih0aGVBY2NvdW50PT1udWxsKXJldHVybjtcclxuICAgIHRoaXMuYWNjb3VudElkID0gdGhlQWNjb3VudC5ob21lQWNjb3VudElkO1xyXG4gICAgdGhpcy5hY2NvdW50TmFtZSA9IHRoZUFjY291bnQudXNlcm5hbWU7XHJcbiAgICB0aGlzLnVzZXJOYW1lPXRoZUFjY291bnQubmFtZTtcclxufVxyXG5cclxubXNhbEhlbHBlci5wcm90b3R5cGUuZmV0Y2hBY2NvdW50PWZ1bmN0aW9uKCl7XHJcbiAgICBjb25zdCBjdXJyZW50QWNjb3VudHMgPSB0aGlzLm15TVNBTE9iai5nZXRBbGxBY2NvdW50cygpO1xyXG4gICAgaWYgKGN1cnJlbnRBY2NvdW50cy5sZW5ndGggPCAxKSByZXR1cm47XHJcbiAgICB2YXIgZm91bmRBY2NvdW50PW51bGw7XHJcbiAgICBmb3IodmFyIGk9MDtpPGN1cnJlbnRBY2NvdW50cy5sZW5ndGg7aSsrKXtcclxuICAgICAgICB2YXIgYW5BY2NvdW50PSBjdXJyZW50QWNjb3VudHNbaV1cclxuICAgICAgICBpZihhbkFjY291bnQuaG9tZUFjY291bnRJZC50b1VwcGVyQ2FzZSgpLmluY2x1ZGVzKGdsb2JhbEFwcFNldHRpbmdzLmIyY1NpZ25VcFNpZ25Jbk5hbWUudG9VcHBlckNhc2UoKSlcclxuICAgICAgICAgICAgJiYgYW5BY2NvdW50LmlkVG9rZW5DbGFpbXMuaXNzLnRvVXBwZXJDYXNlKCkuaW5jbHVkZXMoZ2xvYmFsQXBwU2V0dGluZ3MubXNhbENvbmZpZy5hdXRoLmtub3duQXV0aG9yaXRpZXNbMF0udG9VcHBlckNhc2UoKSlcclxuICAgICAgICAgICAgJiYgYW5BY2NvdW50LmlkVG9rZW5DbGFpbXMuYXVkID09PSBnbG9iYWxBcHBTZXR0aW5ncy5tc2FsQ29uZmlnLmF1dGguY2xpZW50SWRcclxuICAgICAgICApe1xyXG4gICAgICAgICAgICBmb3VuZEFjY291bnQ9IGFuQWNjb3VudDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB0aGlzLnNldEFjY291bnQoZm91bmRBY2NvdW50KVxyXG4gICAgcmV0dXJuIGZvdW5kQWNjb3VudDtcclxufVxyXG5cclxuXHJcbm1zYWxIZWxwZXIucHJvdG90eXBlLmNhbGxBenVyZUZ1bmN0aW9uc1NlcnZpY2U9YXN5bmMgZnVuY3Rpb24oQVBJU3RyaW5nLFJFU1RNZXRob2QscGF5bG9hZCl7XHJcbiAgICB2YXIgaGVhZGVyc09iaj17fVxyXG4gICAgdmFyIHRva2VuPWF3YWl0IHRoaXMuZ2V0VG9rZW4oZ2xvYmFsQXBwU2V0dGluZ3MuYjJjU2NvcGVfZnVuY3Rpb25zKVxyXG4gICAgaGVhZGVyc09ialtcIkF1dGhvcml6YXRpb25cIl09YEJlYXJlciAke3Rva2VufWBcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgdmFyIGFqYXhDb250ZW50PXtcclxuICAgICAgICAgICAgdHlwZTogUkVTVE1ldGhvZCB8fCAnR0VUJyxcclxuICAgICAgICAgICAgXCJoZWFkZXJzXCI6aGVhZGVyc09iaixcclxuICAgICAgICAgICAgdXJsOiBnbG9iYWxBcHBTZXR0aW5ncy5mdW5jdGlvbnNBUElVUkkrQVBJU3RyaW5nLFxyXG4gICAgICAgICAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCIsXHJcbiAgICAgICAgICAgIGNyb3NzRG9tYWluOiB0cnVlLFxyXG4gICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAocmVzcG9uc2VEYXRhLCB0ZXh0U3RhdHVzLCBqcVhIUikge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZURhdGEpXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbiAocmVzcG9uc2VEYXRhLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bikge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KHJlc3BvbnNlRGF0YSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZihSRVNUTWV0aG9kPT1cIlBPU1RcIikgYWpheENvbnRlbnQuZGF0YT0gSlNPTi5zdHJpbmdpZnkocGF5bG9hZClcclxuICAgICAgICAkLmFqYXgoYWpheENvbnRlbnQpO1xyXG4gICAgfSlcclxufVxyXG5cclxubXNhbEhlbHBlci5wcm90b3R5cGUucGFyc2VKV1Q9ZnVuY3Rpb24odG9rZW4pe1xyXG4gICAgdmFyIGJhc2U2NFVybCA9IHRva2VuLnNwbGl0KCcuJylbMV07XHJcbiAgICB2YXIgYmFzZTY0ID0gYmFzZTY0VXJsLnJlcGxhY2UoLy0vZywgJysnKS5yZXBsYWNlKC9fL2csICcvJyk7XHJcbiAgICBiYXNlNjQ9IEJ1ZmZlci5mcm9tKGJhc2U2NCwgJ2Jhc2U2NCcpLnRvU3RyaW5nKCk7XHJcbiAgICB2YXIganNvblBheWxvYWQgPSBkZWNvZGVVUklDb21wb25lbnQoYmFzZTY0LnNwbGl0KCcnKS5tYXAoZnVuY3Rpb24oYykge1xyXG4gICAgICAgIHJldHVybiAnJScgKyAoJzAwJyArIGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikpLnNsaWNlKC0yKTtcclxuICAgIH0pLmpvaW4oJycpKTtcclxuXHJcbiAgICByZXR1cm4gSlNPTi5wYXJzZShqc29uUGF5bG9hZCk7XHJcbn1cclxuXHJcbm1zYWxIZWxwZXIucHJvdG90eXBlLnJlbG9hZFVzZXJBY2NvdW50RGF0YT1hc3luYyBmdW5jdGlvbigpe1xyXG4gICAgdHJ5e1xyXG4gICAgICAgIHZhciByZXM9YXdhaXQgdGhpcy5jYWxsQVBJKFwiYWNjb3VudE1hbmFnZW1lbnQvZmV0Y2hVc2VyRGF0YVwiKVxyXG4gICAgfWNhdGNoKGUpe1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGUpXHJcbiAgICAgICAgaWYoZS5yZXNwb25zZVRleHQpIGFsZXJ0KGUucmVzcG9uc2VUZXh0KVxyXG4gICAgICAgIHJldHVyblxyXG5cclxuICAgIH1cclxuICAgIGdsb2JhbENhY2hlLnN0b3JlVXNlckRhdGEocmVzKVxyXG59XHJcblxyXG5tc2FsSGVscGVyLnByb3RvdHlwZS5jYWxsQVBJPWFzeW5jIGZ1bmN0aW9uKEFQSVN0cmluZyxSRVNUTWV0aG9kLHBheWxvYWQsd2l0aFByb2plY3RJRCl7XHJcbiAgICB2YXIgaGVhZGVyc09iaj17fVxyXG4gICAgaWYod2l0aFByb2plY3RJRCl7XHJcbiAgICAgICAgcGF5bG9hZD1wYXlsb2FkfHx7fVxyXG4gICAgICAgIHBheWxvYWRbXCJwcm9qZWN0SURcIl09Z2xvYmFsQ2FjaGUuY3VycmVudFByb2plY3RJRFxyXG4gICAgfSBcclxuICAgIGlmKCFnbG9iYWxBcHBTZXR0aW5ncy5pc0xvY2FsVGVzdCl7XHJcbiAgICAgICAgdHJ5e1xyXG4gICAgICAgICAgICB2YXIgdG9rZW49YXdhaXQgdGhpcy5nZXRUb2tlbihnbG9iYWxBcHBTZXR0aW5ncy5iMmNTY29wZV90YXNrbWFzdGVyKVxyXG4gICAgICAgIH1jYXRjaChlKXtcclxuICAgICAgICAgICAgd2luZG93Lm9wZW4oZ2xvYmFsQXBwU2V0dGluZ3MubG9nb3V0UmVkaXJlY3RVcmksXCJfc2VsZlwiKVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBoZWFkZXJzT2JqW1wiQXV0aG9yaXphdGlvblwiXT1gQmVhcmVyICR7dG9rZW59YFxyXG5cclxuICAgICAgICAvL2luIGNhc2Ugam9pbmVkIHByb2plY3RzIEpXVCBpcyBnb2luZyB0byBleHBpcmUsIHJlbmV3IGFub3RoZXIgb25lXHJcbiAgICAgICAgaWYoZ2xvYmFsQ2FjaGUuam9pbmVkUHJvamVjdHNUb2tlbikge1xyXG4gICAgICAgICAgICB2YXIgZXhwVFM9dGhpcy5wYXJzZUpXVChnbG9iYWxDYWNoZS5qb2luZWRQcm9qZWN0c1Rva2VuKS5leHBcclxuICAgICAgICAgICAgdmFyIGN1cnJUaW1lPXBhcnNlSW50KG5ldyBEYXRlKCkuZ2V0VGltZSgpLzEwMDApXHJcbiAgICAgICAgICAgIGlmKGV4cFRTLWN1cnJUaW1lPDYwKXsgLy9mZXRjaCBhIG5ldyBwcm9qZWN0cyBKV1QgdG9rZW4gXHJcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnJlbG9hZFVzZXJBY2NvdW50RGF0YSgpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vaWYgdGhlIEFQSSBuZWVkIHRvIHVzZSBwcm9qZWN0IElELCBtdXN0IGFkZCBhIGhlYWRlciBcInByb2plY3RzXCIgand0IHRva2VuIHNvIHNlcnZlciBzaWRlIHdpbGwgdmVyaWZ5XHJcbiAgICAgICAgaWYocGF5bG9hZCAmJiBwYXlsb2FkLnByb2plY3RJRCAmJiBnbG9iYWxDYWNoZS5qb2luZWRQcm9qZWN0c1Rva2VuKXtcclxuICAgICAgICAgICAgaGVhZGVyc09ialtcInByb2plY3RzXCJdPWdsb2JhbENhY2hlLmpvaW5lZFByb2plY3RzVG9rZW5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICB2YXIgYWpheENvbnRlbnQ9e1xyXG4gICAgICAgICAgICB0eXBlOiBSRVNUTWV0aG9kIHx8ICdHRVQnLFxyXG4gICAgICAgICAgICBcImhlYWRlcnNcIjpoZWFkZXJzT2JqLFxyXG4gICAgICAgICAgICB1cmw6IGdsb2JhbEFwcFNldHRpbmdzLnRhc2tNYXN0ZXJBUElVUkkrQVBJU3RyaW5nLFxyXG4gICAgICAgICAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCIsXHJcbiAgICAgICAgICAgIGNyb3NzRG9tYWluOiB0cnVlLFxyXG4gICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAocmVzcG9uc2VEYXRhLCB0ZXh0U3RhdHVzLCBqcVhIUikge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZURhdGEpXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbiAocmVzcG9uc2VEYXRhLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bikge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KHJlc3BvbnNlRGF0YSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZihSRVNUTWV0aG9kPT1cIlBPU1RcIikgYWpheENvbnRlbnQuZGF0YT0gSlNPTi5zdHJpbmdpZnkocGF5bG9hZClcclxuICAgICAgICAkLmFqYXgoYWpheENvbnRlbnQpO1xyXG4gICAgfSlcclxufVxyXG5cclxubXNhbEhlbHBlci5wcm90b3R5cGUuZ2V0VG9rZW49YXN5bmMgZnVuY3Rpb24oYjJjU2NvcGUpe1xyXG4gICAgdHJ5e1xyXG4gICAgICAgIGlmKHRoaXMuc3RvcmVkVG9rZW49PW51bGwpIHRoaXMuc3RvcmVkVG9rZW49e31cclxuICAgICAgICBpZih0aGlzLnN0b3JlZFRva2VuW2IyY1Njb3BlXSE9bnVsbCl7XHJcbiAgICAgICAgICAgIHZhciBjdXJyVGltZT1wYXJzZUludChuZXcgRGF0ZSgpLmdldFRpbWUoKS8xMDAwKVxyXG4gICAgICAgICAgICBpZihjdXJyVGltZSs2MCA8IHRoaXMuc3RvcmVkVG9rZW5bYjJjU2NvcGVdLmV4cGlyZSkgcmV0dXJuIHRoaXMuc3RvcmVkVG9rZW5bYjJjU2NvcGVdLmFjY2Vzc1Rva2VuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB0b2tlblJlcXVlc3Q9e1xyXG4gICAgICAgICAgICBzY29wZXM6IFtiMmNTY29wZV0sXHJcbiAgICAgICAgICAgIGZvcmNlUmVmcmVzaDogZmFsc2UsIC8vIFNldCB0aGlzIHRvIFwidHJ1ZVwiIHRvIHNraXAgYSBjYWNoZWQgdG9rZW4gYW5kIGdvIHRvIHRoZSBzZXJ2ZXIgdG8gZ2V0IGEgbmV3IHRva2VuXHJcbiAgICAgICAgICAgIGFjY291bnQ6IHRoaXMubXlNU0FMT2JqLmdldEFjY291bnRCeUhvbWVJZCh0aGlzLmFjY291bnRJZClcclxuICAgICAgICB9XHJcbiAgICBcclxuICAgICAgICBjb25zb2xlLmxvZyhcInRyeSB0byBzaWxlbnRseSBnZXQgdG9rZW5cIilcclxuICAgICAgICB2YXIgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLm15TVNBTE9iai5hY3F1aXJlVG9rZW5TaWxlbnQodG9rZW5SZXF1ZXN0KVxyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiZ2V0IHRva2VuIHN1Y2Nlc3NmdWxseVwiKVxyXG4gICAgICAgIGlmICghcmVzcG9uc2UuYWNjZXNzVG9rZW4gfHwgcmVzcG9uc2UuYWNjZXNzVG9rZW4gPT09IFwiXCIpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IG1zYWwuSW50ZXJhY3Rpb25SZXF1aXJlZEF1dGhFcnJvcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnN0b3JlZFRva2VuW2IyY1Njb3BlXT17XCJhY2Nlc3NUb2tlblwiOnJlc3BvbnNlLmFjY2Vzc1Rva2VuLFwiZXhwaXJlXCI6cmVzcG9uc2UuaWRUb2tlbkNsYWltcy5leHB9XHJcbiAgICB9Y2F0Y2goZXJyb3Ipe1xyXG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIG1zYWwuSW50ZXJhY3Rpb25SZXF1aXJlZEF1dGhFcnJvcikge1xyXG4gICAgICAgICAgICAvLyBmYWxsYmFjayB0byBpbnRlcmFjdGlvbiB3aGVuIHNpbGVudCBjYWxsIGZhaWxzXHJcbiAgICAgICAgICAgIHZhciByZXNwb25zZT1hd2FpdCB0aGlzLm15TVNBTE9iai5hY3F1aXJlVG9rZW5Qb3B1cCh0b2tlblJlcXVlc3QpXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXNwb25zZS5hY2Nlc3NUb2tlbjtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBuZXcgbXNhbEhlbHBlcigpOyIsImNvbnN0IHNpbXBsZVNlbGVjdE1lbnU9IHJlcXVpcmUoXCIuL3NpbXBsZVNlbGVjdE1lbnVcIilcclxuY29uc3QgZ2xvYmFsQ2FjaGUgPSByZXF1aXJlKFwiLi4vc2hhcmVkU291cmNlRmlsZXMvZ2xvYmFsQ2FjaGVcIilcclxuY29uc3QgbW9kZWxBbmFseXplciA9IHJlcXVpcmUoXCIuLi9zaGFyZWRTb3VyY2VGaWxlcy9tb2RlbEFuYWx5emVyXCIpO1xyXG5jb25zdCBtc2FsSGVscGVyID0gcmVxdWlyZShcIi4uL21zYWxIZWxwZXJcIilcclxuY29uc3Qgc2ltcGxlQ2hhcnQ9cmVxdWlyZShcIi4vc2ltcGxlQ2hhcnRcIilcclxuXHJcbmNsYXNzIGJhc2VJbmZvUGFuZWwge1xyXG4gICAgZHJhd0VkaXRhYmxlKHBhcmVudCxqc29uSW5mbyxvcmlnaW5FbGVtZW50SW5mbyxwYXRoQXJyLGZ1bmNHZXRLZXlMYmxDb2xvckNsYXNzKXtcclxuICAgICAgICBpZihqc29uSW5mbz09bnVsbCkgcmV0dXJuO1xyXG4gICAgICAgIGZvcih2YXIgaW5kIGluIGpzb25JbmZvKXtcclxuICAgICAgICAgICAgdmFyIGtleURpdj0gJChcIjxsYWJlbCBzdHlsZT0nZGlzcGxheTpibG9jayc+PGRpdiBzdHlsZT0nZGlzcGxheTppbmxpbmU7cGFkZGluZzouMWVtIC4zZW0gLjFlbSAuM2VtOyBtYXJnaW4tcmlnaHQ6NXB4Jz5cIitpbmQrXCI8L2Rpdj48L2xhYmVsPlwiKVxyXG4gICAgICAgICAgICBwYXJlbnQuYXBwZW5kKGtleURpdilcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGtleURpdi5jc3MoXCJwYWRkaW5nLXRvcFwiLFwiLjNlbVwiKSBcclxuICAgIFxyXG4gICAgICAgICAgICB2YXIgY29udGVudERPTT0kKFwiPGxhYmVsIHN0eWxlPSdwYWRkaW5nLXRvcDouMmVtJz48L2xhYmVsPlwiKVxyXG4gICAgICAgICAgICB2YXIgbmV3UGF0aD1wYXRoQXJyLmNvbmNhdChbaW5kXSlcclxuICAgICAgICAgICAgdmFyIGtleUxhYmVsQ29sb3JDbGFzcz1cInczLWRhcmstZ3JheVwiXHJcbiAgICAgICAgICAgIGlmKGZ1bmNHZXRLZXlMYmxDb2xvckNsYXNzKSBrZXlMYWJlbENvbG9yQ2xhc3M9ZnVuY0dldEtleUxibENvbG9yQ2xhc3MobmV3UGF0aClcclxuICAgICAgICAgICAgaWYoQXJyYXkuaXNBcnJheShqc29uSW5mb1tpbmRdKSl7XHJcbiAgICAgICAgICAgICAgICBrZXlEaXYuY2hpbGRyZW4oXCI6Zmlyc3RcIikuYWRkQ2xhc3Moa2V5TGFiZWxDb2xvckNsYXNzKVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVhZE9ubHkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gZ2xvYmFsQ2FjaGUuc2VhcmNoVmFsdWUob3JpZ2luRWxlbWVudEluZm8sIG5ld1BhdGgpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRET00uY3NzKHsgXCJjb2xvclwiOiBcImdyYXlcIiwgXCJmb250LXNpemVcIjogXCI5cHhcIiB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50RE9NLnRleHQoXCJbZW1wdHldXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGNvbnRlbnRET00udGV4dCh2YWwpXHJcbiAgICAgICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdEcm9wZG93bk9wdGlvbihjb250ZW50RE9NLG5ld1BhdGgsanNvbkluZm9baW5kXSxvcmlnaW5FbGVtZW50SW5mbylcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfWVsc2UgaWYodHlwZW9mKGpzb25JbmZvW2luZF0pPT09XCJvYmplY3RcIikge1xyXG4gICAgICAgICAgICAgICAga2V5RGl2LmNoaWxkcmVuKFwiOmZpcnN0XCIpLmNzcyhcImZvbnQtd2VpZ2h0XCIsXCJib2xkXCIpXHJcbiAgICAgICAgICAgICAgICBjb250ZW50RE9NLmNzcyhcImRpc3BsYXlcIixcImJsb2NrXCIpXHJcbiAgICAgICAgICAgICAgICBjb250ZW50RE9NLmNzcyhcInBhZGRpbmctbGVmdFwiLFwiMWVtXCIpXHJcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdFZGl0YWJsZShjb250ZW50RE9NLGpzb25JbmZvW2luZF0sb3JpZ2luRWxlbWVudEluZm8sbmV3UGF0aCxmdW5jR2V0S2V5TGJsQ29sb3JDbGFzcylcclxuICAgICAgICAgICAgfWVsc2Uge1xyXG4gICAgICAgICAgICAgICAga2V5RGl2LmNoaWxkcmVuKFwiOmZpcnN0XCIpLmFkZENsYXNzKGtleUxhYmVsQ29sb3JDbGFzcylcclxuICAgICAgICAgICAgICAgIHZhciB2YWwgPSBnbG9iYWxDYWNoZS5zZWFyY2hWYWx1ZShvcmlnaW5FbGVtZW50SW5mbywgbmV3UGF0aClcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlYWRPbmx5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRET00uY3NzKHsgXCJjb2xvclwiOiBcImdyYXlcIiwgXCJmb250LXNpemVcIjogXCI5cHhcIiB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50RE9NLnRleHQoXCJbZW1wdHldXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGNvbnRlbnRET00udGV4dCh2YWwpXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhSW5wdXQgPSAkKCc8aW5wdXQgdHlwZT1cInRleHRcIiBzdHlsZT1cInBhZGRpbmc6MnB4O3dpZHRoOjUwJTtvdXRsaW5lOm5vbmU7ZGlzcGxheTppbmxpbmVcIiBwbGFjZWhvbGRlcj1cInR5cGU6ICcgKyBqc29uSW5mb1tpbmRdICsgJ1wiLz4nKS5hZGRDbGFzcyhcInczLWlucHV0IHczLWJvcmRlclwiKTtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZW50RE9NLmFwcGVuZChhSW5wdXQpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCAhPSBudWxsKSBhSW5wdXQudmFsKHZhbClcclxuICAgICAgICAgICAgICAgICAgICBhSW5wdXQuZGF0YShcInBhdGhcIiwgbmV3UGF0aClcclxuICAgICAgICAgICAgICAgICAgICBhSW5wdXQuZGF0YShcImRhdGFUeXBlXCIsIGpzb25JbmZvW2luZF0pXHJcbiAgICAgICAgICAgICAgICAgICAgYUlucHV0LmNoYW5nZSgoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVkaXREVFByb3BlcnR5KG9yaWdpbkVsZW1lbnRJbmZvLCAkKGUudGFyZ2V0KS5kYXRhKFwicGF0aFwiKSwgJChlLnRhcmdldCkudmFsKCksICQoZS50YXJnZXQpLmRhdGEoXCJkYXRhVHlwZVwiKSlcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGtleURpdi5hcHBlbmQoY29udGVudERPTSlcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZHJhd0Ryb3Bkb3duT3B0aW9uKGNvbnRlbnRET00sbmV3UGF0aCx2YWx1ZUFycixvcmlnaW5FbGVtZW50SW5mbyl7XHJcbiAgICAgICAgdmFyIGFTZWxlY3RNZW51PW5ldyBzaW1wbGVTZWxlY3RNZW51KFwiXCIse2J1dHRvbkNTUzp7XCJwYWRkaW5nXCI6XCI0cHggMTZweFwifX0pXHJcbiAgICAgICAgY29udGVudERPTS5hcHBlbmQoYVNlbGVjdE1lbnUuRE9NKVxyXG4gICAgICAgIGFTZWxlY3RNZW51LkRPTS5kYXRhKFwicGF0aFwiLCBuZXdQYXRoKVxyXG4gICAgICAgIHZhbHVlQXJyLmZvckVhY2goKG9uZU9wdGlvbik9PntcclxuICAgICAgICAgICAgdmFyIHN0ciA9b25lT3B0aW9uW1wiZGlzcGxheU5hbWVcIl0gIHx8IG9uZU9wdGlvbltcImVudW1WYWx1ZVwiXSBcclxuICAgICAgICAgICAgYVNlbGVjdE1lbnUuYWRkT3B0aW9uKHN0cilcclxuICAgICAgICB9KVxyXG4gICAgICAgIGFTZWxlY3RNZW51LmNhbGxCYWNrX2NsaWNrT3B0aW9uPShvcHRpb25UZXh0LG9wdGlvblZhbHVlLHJlYWxNb3VzZUNsaWNrKT0+e1xyXG4gICAgICAgICAgICBhU2VsZWN0TWVudS5jaGFuZ2VOYW1lKG9wdGlvblRleHQpXHJcbiAgICAgICAgICAgIGlmKHJlYWxNb3VzZUNsaWNrKSB0aGlzLmVkaXREVFByb3BlcnR5KG9yaWdpbkVsZW1lbnRJbmZvLGFTZWxlY3RNZW51LkRPTS5kYXRhKFwicGF0aFwiKSxvcHRpb25WYWx1ZSxcInN0cmluZ1wiKVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdmFsPWdsb2JhbENhY2hlLnNlYXJjaFZhbHVlKG9yaWdpbkVsZW1lbnRJbmZvLG5ld1BhdGgpXHJcbiAgICAgICAgaWYodmFsIT1udWxsKXtcclxuICAgICAgICAgICAgYVNlbGVjdE1lbnUudHJpZ2dlck9wdGlvblZhbHVlKHZhbClcclxuICAgICAgICB9ICAgIFxyXG4gICAgfVxyXG5cclxuICAgIGdlbmVyYXRlU21hbGxLZXlEaXYoc3RyLHBhZGRpbmdUb3Ape1xyXG4gICAgICAgIHZhciBrZXlEaXYgPSAkKFwiPGxhYmVsIHN0eWxlPSdkaXNwbGF5OmJsb2NrJz48ZGl2IGNsYXNzPSd3My1ib3JkZXInIHN0eWxlPSdiYWNrZ3JvdW5kLWNvbG9yOiNmNmY2ZjY7ZGlzcGxheTppbmxpbmU7cGFkZGluZzouMWVtIC4zZW0gLjFlbSAuM2VtO21hcmdpbi1yaWdodDouM2VtO2ZvbnQtc2l6ZToxMHB4Jz5cIitzdHIrXCI8L2Rpdj48L2xhYmVsPlwiKVxyXG4gICAgICAgIGtleURpdi5jc3MoXCJwYWRkaW5nLXRvcFwiLHBhZGRpbmdUb3ApXHJcbiAgICAgICAgcmV0dXJuIGtleURpdlxyXG4gICAgfVxyXG5cclxuICAgIGRyYXdDb25uZWN0aW9uU3RhdHVzKHN0YXR1cyxwYXJlbnREb20pIHtcclxuICAgICAgICBwYXJlbnREb209cGFyZW50RG9tfHx0aGlzLkRPTVxyXG4gICAgICAgIHZhciBrZXlEaXY9dGhpcy5nZW5lcmF0ZVNtYWxsS2V5RGl2KFwiQ29ubmVjdGlvblwiLFwiLjVlbVwiKVxyXG4gICAgICAgIHBhcmVudERvbS5hcHBlbmQoa2V5RGl2KVxyXG4gICAgICAgIHZhciBjb250ZW50RE9NID0gJCgnPHNwYW4gY2xhc3M9XCJmYS1zdGFja1wiIHN0eWxlPVwiZm9udC1zaXplOi41ZW07cGFkZGluZy1sZWZ0OjVweFwiPjwvc3Bhbj4nKVxyXG4gICAgICAgIGlmKHN0YXR1cykge1xyXG4gICAgICAgICAgICBjb250ZW50RE9NLmFkZENsYXNzKFwidzMtdGV4dC1saW1lXCIpXHJcbiAgICAgICAgICAgIGNvbnRlbnRET00uaHRtbCgnPGkgY2xhc3M9XCJmYXMgZmEtc2lnbmFsIGZhLXN0YWNrLTJ4XCI+PC9pPicpXHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIGNvbnRlbnRET00uYWRkQ2xhc3MoXCJ3My10ZXh0LXJlZFwiKVxyXG4gICAgICAgICAgICBjb250ZW50RE9NLmh0bWwoJzxpIGNsYXNzPVwiZmFzIGZhLXNpZ25hbCBmYS1zdGFjay0yeFwiPjwvaT48aSBjbGFzcz1cImZhcyBmYS1zbGFzaCBmYS1zdGFjay0yeFwiPjwvaT4nKVxyXG4gICAgICAgIH1cclxuICAgICAgICBrZXlEaXYuYXBwZW5kKGNvbnRlbnRET00pXHJcbiAgICB9XHJcblxyXG4gICAgZHJhd1N0YXRpY0luZm8ocGFyZW50LGpzb25JbmZvLHBhZGRpbmdUb3AsZm9udFNpemUsZm9udENvbG9yKXtcclxuICAgICAgICBmb250Q29sb3I9Zm9udENvbG9yfHxcImJsYWNrXCJcclxuICAgICAgICBmb3IodmFyIGluZCBpbiBqc29uSW5mbyl7XHJcbiAgICAgICAgICAgIHZhciBrZXlEaXY9dGhpcy5nZW5lcmF0ZVNtYWxsS2V5RGl2KGluZCxwYWRkaW5nVG9wKVxyXG4gICAgICAgICAgICBwYXJlbnQuYXBwZW5kKGtleURpdilcclxuICAgIFxyXG4gICAgICAgICAgICB2YXIgY29udGVudERPTT0kKFwiPGxhYmVsPjwvbGFiZWw+XCIpXHJcbiAgICAgICAgICAgIGNvbnRlbnRET00uY3NzKHtcImZvbnRTaXplXCI6Zm9udFNpemUsXCJjb2xvclwiOmZvbnRDb2xvcn0pXHJcbiAgICAgICAgICAgIGlmKGpzb25JbmZvW2luZF09PW51bGwpe1xyXG4gICAgICAgICAgICAgICAgY29udGVudERPTS5jc3MoeyBcImNvbG9yXCI6IFwiZ3JheVwiLCBcImZvbnQtc2l6ZVwiOiBcIjlweFwiIH0pXHJcbiAgICAgICAgICAgICAgICBjb250ZW50RE9NLnRleHQoXCJbZW1wdHldXCIpXHJcbiAgICAgICAgICAgIH1lbHNlIGlmKHR5cGVvZihqc29uSW5mb1tpbmRdKT09PVwib2JqZWN0XCIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRlbnRET00uY3NzKFwiZGlzcGxheVwiLFwiYmxvY2tcIilcclxuICAgICAgICAgICAgICAgIGNvbnRlbnRET00uY3NzKFwicGFkZGluZy1sZWZ0XCIsXCIxZW1cIilcclxuICAgICAgICAgICAgICAgIHRoaXMuZHJhd1N0YXRpY0luZm8oY29udGVudERPTSxqc29uSW5mb1tpbmRdLFwiLjVlbVwiLGZvbnRTaXplKVxyXG4gICAgICAgICAgICB9ZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZW50RE9NLmNzcyhcInBhZGRpbmctdG9wXCIsXCIuMmVtXCIpXHJcbiAgICAgICAgICAgICAgICBjb250ZW50RE9NLnRleHQoanNvbkluZm9baW5kXSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAga2V5RGl2LmFwcGVuZChjb250ZW50RE9NKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmZXRjaFJlYWxFbGVtZW50SW5mbyhzaW5nbGVFbGVtZW50SW5mbyl7IC8vdGhlIGlucHV0IGlzIHBvc3NpYmx5IGZyb20gdG9wb2xvZ3kgdmlldyB3aGljaCBtaWdodCBub3QgYmUgcHJlY2lzZSBhYm91dCBwcm9wZXJ0eSB2YWx1ZVxyXG4gICAgICAgIHZhciByZXR1cm5FbGVtZW50SW5mbz17fVxyXG4gICAgICAgIGlmKHNpbmdsZUVsZW1lbnRJbmZvPT1udWxsKSByZXR1cm47XHJcbiAgICAgICAgaWYgKHNpbmdsZUVsZW1lbnRJbmZvW1wiJGR0SWRcIl0pIHtcclxuICAgICAgICAgICAgcmV0dXJuRWxlbWVudEluZm89Z2xvYmFsQ2FjaGUuc3RvcmVkVHdpbnNbc2luZ2xlRWxlbWVudEluZm9bXCIkZHRJZFwiXV0gLy9ub3RlIHRoYXQgZHluYW1pY2FsIHByb3BlcnR5IHZhbHVlIGlzIG5vdCBzdG9yZWQgaW4gdG9wb2xvZ3kgbm9kZSwgc28gYWx3YXlzIGdldCByZWZyZXNoIGRhdGEgZnJvbSBnbG9iYWxjYWNoZVxyXG4gICAgICAgIH1lbHNlIGlmIChzaW5nbGVFbGVtZW50SW5mb1tcIiRzb3VyY2VJZFwiXSkge1xyXG4gICAgICAgICAgICB2YXIgYXJyPWdsb2JhbENhY2hlLnN0b3JlZE91dGJvdW5kUmVsYXRpb25zaGlwc1tzaW5nbGVFbGVtZW50SW5mb1tcIiRzb3VyY2VJZFwiXV1cclxuICAgICAgICAgICAgZm9yKHZhciBpPTA7aTxhcnIubGVuZ3RoO2krKyl7XHJcbiAgICAgICAgICAgICAgICBpZihhcnJbaV1bJyRyZWxhdGlvbnNoaXBJZCddPT1zaW5nbGVFbGVtZW50SW5mb1tcIiRyZWxhdGlvbnNoaXBJZFwiXSl7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuRWxlbWVudEluZm89YXJyW2ldXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9ZWxzZSBpZihzaW5nbGVFbGVtZW50SW5mb1tcInNpbU5vZGVOYW1lXCJdKXtcclxuICAgICAgICAgICAgdmFyIGF0dGFjaFR3aW5JRD1zaW5nbGVFbGVtZW50SW5mb1tcInR3aW5JRFwiXVxyXG4gICAgICAgICAgICB2YXIgZGJ0d2luPWdsb2JhbENhY2hlLkRCVHdpbnNbYXR0YWNoVHdpbklEXVxyXG4gICAgICAgICAgICB2YXIgc2ltTm9kZU5hbWU9c2luZ2xlRWxlbWVudEluZm9bXCJzaW1Ob2RlTmFtZVwiXVxyXG4gICAgICAgICAgICBzaW5nbGVFbGVtZW50SW5mby5kZXRhaWw9ZGJ0d2luLnNpbXVsYXRlW3NpbU5vZGVOYW1lXVxyXG4gICAgICAgICAgICByZXR1cm5FbGVtZW50SW5mbz1zaW5nbGVFbGVtZW50SW5mb1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmV0dXJuRWxlbWVudEluZm9cclxuICAgIH1cclxuXHJcbiAgICBkcmF3U2luZ2xlUmVsYXRpb25Qcm9wZXJ0aWVzKHNpbmdsZVJlbGF0aW9uSW5mbyxwYXJlbnREb20pIHtcclxuICAgICAgICBwYXJlbnREb209cGFyZW50RG9tfHx0aGlzLkRPTVxyXG4gICAgICAgIHRoaXMuZHJhd1N0YXRpY0luZm8ocGFyZW50RG9tLCB7XHJcbiAgICAgICAgICAgIFwic291cmNlSVwiOmdsb2JhbENhY2hlLnR3aW5JRE1hcFRvRGlzcGxheU5hbWVbc2luZ2xlUmVsYXRpb25JbmZvW1wiJHNvdXJjZUlkXCJdXSxcclxuICAgICAgICAgICAgXCJ0YXJnZXRcIjogZ2xvYmFsQ2FjaGUudHdpbklETWFwVG9EaXNwbGF5TmFtZVtzaW5nbGVSZWxhdGlvbkluZm9bXCIkdGFyZ2V0SWRcIl1dLFxyXG4gICAgICAgICAgICBcIiRyZWxhdGlvbnNoaXBOYW1lXCI6IHNpbmdsZVJlbGF0aW9uSW5mb1tcIiRyZWxhdGlvbnNoaXBOYW1lXCJdXHJcbiAgICAgICAgfSwgXCIxZW1cIiwgXCIxM3B4XCIpXHJcbiAgICAgICAgdGhpcy5kcmF3U3RhdGljSW5mbyhwYXJlbnREb20sIHtcclxuICAgICAgICAgICAgXCIkcmVsYXRpb25zaGlwSWRcIjogc2luZ2xlUmVsYXRpb25JbmZvW1wiJHJlbGF0aW9uc2hpcElkXCJdXHJcbiAgICAgICAgfSwgXCIxZW1cIiwgXCIxMHB4XCIpXHJcbiAgICAgICAgdmFyIHJlbGF0aW9uc2hpcE5hbWUgPSBzaW5nbGVSZWxhdGlvbkluZm9bXCIkcmVsYXRpb25zaGlwTmFtZVwiXVxyXG4gICAgICAgIHZhciBzb3VyY2VNb2RlbCA9IHNpbmdsZVJlbGF0aW9uSW5mb1tcInNvdXJjZU1vZGVsXCJdXHJcblxyXG4gICAgICAgIHRoaXMuZHJhd0VkaXRhYmxlKHBhcmVudERvbSwgdGhpcy5nZXRSZWxhdGlvblNoaXBFZGl0YWJsZVByb3BlcnRpZXMocmVsYXRpb25zaGlwTmFtZSwgc291cmNlTW9kZWwpLCBzaW5nbGVSZWxhdGlvbkluZm8sIFtdKVxyXG4gICAgICAgIGZvciAodmFyIGluZCBpbiBzaW5nbGVSZWxhdGlvbkluZm9bXCIkbWV0YWRhdGFcIl0pIHtcclxuICAgICAgICAgICAgdmFyIHRtcE9iaiA9IHt9XHJcbiAgICAgICAgICAgIHRtcE9ialtpbmRdID0gc2luZ2xlUmVsYXRpb25JbmZvW1wiJG1ldGFkYXRhXCJdW2luZF1cclxuICAgICAgICAgICAgdGhpcy5kcmF3U3RhdGljSW5mbyhwYXJlbnREb20sIHRtcE9iaiwgXCIxZW1cIiwgXCIxMHB4XCIpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vdGhpcy5kcmF3U3RhdGljSW5mbyhwYXJlbnREb20se1wiJGV0YWdcIjpzaW5nbGVSZWxhdGlvbkluZm9bXCIkZXRhZ1wiXX0sXCIxZW1cIixcIjEwcHhcIixcIkRhcmtHcmF5XCIpXHJcbiAgICB9XHJcblxyXG4gICAgZ2V0UmVsYXRpb25TaGlwRWRpdGFibGVQcm9wZXJ0aWVzKHJlbGF0aW9uc2hpcE5hbWUsIHNvdXJjZU1vZGVsKSB7XHJcbiAgICAgICAgaWYgKCFtb2RlbEFuYWx5emVyLkRURExNb2RlbHNbc291cmNlTW9kZWxdIHx8ICFtb2RlbEFuYWx5emVyLkRURExNb2RlbHNbc291cmNlTW9kZWxdLnZhbGlkUmVsYXRpb25zaGlwc1tyZWxhdGlvbnNoaXBOYW1lXSkgcmV0dXJuXHJcbiAgICAgICAgcmV0dXJuIG1vZGVsQW5hbHl6ZXIuRFRETE1vZGVsc1tzb3VyY2VNb2RlbF0udmFsaWRSZWxhdGlvbnNoaXBzW3JlbGF0aW9uc2hpcE5hbWVdLmVkaXRhYmxlUmVsYXRpb25zaGlwUHJvcGVydGllc1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBkcmF3U2ltRGF0YXNvdXJjZUluZm8oc2ltTm9kZUluZm8scGFyZW50RG9tKXtcclxuICAgICAgICBwYXJlbnREb209cGFyZW50RG9tfHx0aGlzLkRPTVxyXG4gICAgICAgIHZhciBkYlR3aW49Z2xvYmFsQ2FjaGUuREJUd2luc1tzaW1Ob2RlSW5mby50d2luSURdXHJcbiAgICAgICAgdmFyIHR3aW5OYW1lPWdsb2JhbENhY2hlLnR3aW5JRE1hcFRvRGlzcGxheU5hbWVbc2ltTm9kZUluZm8udHdpbklEXVxyXG4gICAgICAgIGlmKCF0aGlzLnJlYWRPbmx5KSB7XHJcbiAgICAgICAgICAgIHZhciBjb250YWluZXJEaXY9JChcIjxkaXYgY2xhc3M9J3czLWNvbnRhaW5lcicvPlwiKVxyXG4gICAgICAgICAgICBwYXJlbnREb20uYXBwZW5kKGNvbnRhaW5lckRpdilcclxuICAgICAgICAgICAgcGFyZW50RG9tPWNvbnRhaW5lckRpdiBcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5kcmF3U3RhdGljSW5mbyhwYXJlbnREb20sIHsgXCJuYW1lXCI6IHR3aW5OYW1lIH0sIFwiLjVlbVwiLCBcIjEzcHhcIilcclxuICAgICAgICB0aGlzLmRyYXdTdGF0aWNJbmZvKHBhcmVudERvbSwgeyBcIk1vZGVsXCI6IGRiVHdpbi5tb2RlbElEIH0sIFwiLjVlbVwiLCBcIjEzcHhcIilcclxuICAgICAgICBpZiAodGhpcy5yZWFkT25seSkgey8vaW4gZmxvYXQgaW5mbyBwYW5lbFxyXG4gICAgICAgICAgICB0aGlzLmRyYXdTdGF0aWNJbmZvKHBhcmVudERvbSwgeyBcIlNpbXVsYXRlIFByb3BlcnR5XCI6IHNpbU5vZGVJbmZvLnByb3BlcnR5UGF0aCB9LCBcIi41ZW1cIiwgXCIxM3B4XCIpXHJcbiAgICAgICAgICAgIHRoaXMuZHJhd1N0YXRpY0luZm8ocGFyZW50RG9tLCB7IFwiQ3ljbGUgTGVuZ3RoXCI6IHNpbU5vZGVJbmZvLmN5Y2xlTGVuZ3RoIH0sIFwiLjVlbVwiLCBcIjEzcHhcIilcclxuICAgICAgICAgICAgdGhpcy5kcmF3U3RhdGljSW5mbyhwYXJlbnREb20sIHsgXCJTYW1wbGluZ1wiOiBzaW1Ob2RlSW5mby5zYW1wbGVJbnRlcnZhbCB9LCBcIi41ZW1cIiwgXCIxM3B4XCIpXHJcbiAgICAgICAgICAgIHRoaXMuZHJhd1N0YXRpY0luZm8ocGFyZW50RG9tLCB7IFwiRm9ybXVsYVwiOiBzaW1Ob2RlSW5mby5mb3JtdWxhIH0sIFwiLjVlbVwiLCBcIjEzcHhcIilcclxuICAgICAgICB9ZWxzZXsgLy8gaW4gcmlnaHQgc2lkZSBpbmZvIHBhbmVsXHJcbiAgICAgICAgICAgIHRoaXMuZHJhd1NpbURhdGFzb3VyY2VJbmZvX3Byb3BlcnR5UGF0aChwYXJlbnREb20sc2ltTm9kZUluZm8sZGJUd2luKVxyXG4gICAgICAgICAgICAvL2RyYXcgY3ljbGVMZW5ndGgsc2FtcGxlSW50ZXJ2YWwgYW5kIGZvcm11bGFcclxuICAgICAgICAgICAgdmFyIGRlbW9DaGFydD10aGlzLmRyYXdTaW1EYXRhc291cmNlSW5mb19jaGFydChzaW1Ob2RlSW5mbyxwYXJlbnREb20pXHJcbiAgICAgICAgICAgIHRoaXMuZHJhd1NpbURhdGFzb3VyY2VJbmZvX2lucHV0KFwiQ3ljbGUgTGVuZ3RoKF9UKVwiLFwiY3ljbGVMZW5ndGhcIixcIkN5Y2xlIHRpbWUgbGVuZ3RoIGluIHNlY29uZHNcIixwYXJlbnREb20sc2ltTm9kZUluZm8sZGJUd2luLGRlbW9DaGFydClcclxuICAgICAgICAgICAgdGhpcy5kcmF3U2ltRGF0YXNvdXJjZUluZm9faW5wdXQoXCJTYW1wbGluZ1wiLFwic2FtcGxlSW50ZXJ2YWxcIixcIlNhbXBsaW5nIHRpbWUgaW4gc2Vjb25kc1wiLHBhcmVudERvbSxzaW1Ob2RlSW5mbyxkYlR3aW4sZGVtb0NoYXJ0KSBcclxuICAgICAgICAgICAgdGhpcy5kcmF3U2ltRGF0YXNvdXJjZUluZm9fZm9ybXVsYShwYXJlbnREb20sc2ltTm9kZUluZm8sZGJUd2luLGRlbW9DaGFydClcclxuICAgICAgICAgICAgcGFyZW50RG9tLmFwcGVuZChkZW1vQ2hhcnQuY2FudmFzKSAvL21vdmUgY2hhcnQgdG8gdGhlIGVuZFxyXG4gICAgICAgICAgICB0aGlzLmRyYXdTaW1EYXRhc291cmNlSW5mb19yZWZyZXNoQ2hhcnQoc2ltTm9kZUluZm8sZGVtb0NoYXJ0KVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBkcmF3U2ltRGF0YXNvdXJjZUluZm9fcmVmcmVzaENoYXJ0KHNpbU5vZGVJbmZvLHRoZUNoYXJ0KXtcclxuICAgICAgICB2YXIgX1Q9cGFyc2VGbG9hdChzaW1Ob2RlSW5mby5kZXRhaWxbXCJjeWNsZUxlbmd0aFwiXSlcclxuICAgICAgICB2YXIgc2FtcGxpbmc9cGFyc2VGbG9hdChzaW1Ob2RlSW5mby5kZXRhaWxbXCJzYW1wbGVJbnRlcnZhbFwiXSlcclxuICAgICAgICB2YXIgZm9ybXVsYT1zaW1Ob2RlSW5mby5kZXRhaWxbXCJmb3JtdWxhXCJdXHJcbiAgICAgICAgdmFyIG51bU9mUG9pbnRzPXBhcnNlSW50KDIqX1Qvc2FtcGxpbmcpKzFcclxuICAgICAgICB0aGVDaGFydC5zZXRYTGVuZ3RoKG51bU9mUG9pbnRzKVxyXG5cclxuICAgICAgICBpZihfVD09MCB8fCBzYW1wbGluZz09MCB8fCBmb3JtdWxhPT1cIlwiIHx8IF9UPT1udWxsIHx8IHNhbXBsaW5nPT1udWxsIHx8IGZvcm11bGE9PW51bGwgfHwgX1Q8MCB8fCBzYW1wbGluZzwwKSByZXR1cm47XHJcblxyXG4gICAgICAgIHZhciBfdD0wO1xyXG4gICAgICAgIHZhciBkYXRhQXJyPVtdXHJcbiAgICAgICAgdmFyIF9vdXRwdXQ9bnVsbDtcclxuICAgICAgICBmb3IodmFyIGk9MDtpPG51bU9mUG9pbnRzO2krKyl7XHJcbiAgICAgICAgICAgIHZhciBldmFsU3RyPWZvcm11bGErXCJcXG5fb3V0cHV0XCJcclxuICAgICAgICAgICAgdHJ5e1xyXG4gICAgICAgICAgICAgICAgX291dHB1dD1ldmFsKGV2YWxTdHIpIC8vIGpzaGludCBpZ25vcmU6bGluZVxyXG4gICAgICAgICAgICB9Y2F0Y2goZSl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRhdGFBcnIucHVzaChfb3V0cHV0KVxyXG4gICAgICAgICAgICBfdCs9c2FtcGxpbmdcclxuICAgICAgICAgICAgaWYoX3Q+PV9UKV90PV90LV9UXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoZUNoYXJ0LnNldERhdGFBcnIoZGF0YUFycilcclxuICAgIH1cclxuXHJcbiAgICBkcmF3U2ltRGF0YXNvdXJjZUluZm9fY2hhcnQoc2ltTm9kZUluZm8scGFyZW50RG9tKXtcclxuICAgICAgICB2YXIgY3ljbGVMPSBzaW1Ob2RlSW5mby5kZXRhaWxbXCJjeWNsZUxlbmd0aFwiXVxyXG4gICAgICAgIHZhciBzYW1wbGluZz1zaW1Ob2RlSW5mby5kZXRhaWxbXCJzYW1wbGVJbnRlcnZhbFwiXVxyXG4gICAgICAgIHZhciBudW1PZlBvaW50cz0xMDBcclxuICAgICAgICB2YXIgZGVtb0NoYXJ0PW5ldyBzaW1wbGVDaGFydChwYXJlbnREb20sbnVtT2ZQb2ludHMse3dpZHRoOlwiMTAwJVwiLFwiaGVpZ2h0XCI6XCIxMzBweFwifSkgXHJcbiAgICAgICAgcmV0dXJuIGRlbW9DaGFydFxyXG4gICAgfVxyXG4gICAgZHJhd1NpbURhdGFzb3VyY2VJbmZvX2Zvcm11bGEocGFyZW50RG9tLHNpbU5vZGVJbmZvLGRiVHdpbixkZW1vQ2hhcnQpe1xyXG4gICAgICAgIHZhciBzY3JpcHRMYmw9dGhpcy5nZW5lcmF0ZVNtYWxsS2V5RGl2KFwiQ2FsY3VsYXRpb24gU2NyaXB0XCIsXCIycHhcIilcclxuICAgICAgICBzY3JpcHRMYmwuY3NzKFwibWFyZ2luLXRvcFwiLFwiMTBweFwiKVxyXG5cclxuICAgICAgICB2YXIgbGJsMj0kKCc8bGJsIHN0eWxlPVwiZm9udC1zaXplOjEwcHg7Y29sb3I6Z3JheVwiPihCdWlsZCBpbiB2YXJpYWJsZXM6X3QgX1QgX291dHB1dCk8L2xibD4nKVxyXG4gICAgICAgIHNjcmlwdExibC5hcHBlbmQobGJsMilcclxuXHJcbiAgICAgICAgdmFyIHBsYWNlSG9sZGVyU3RyPSdTYW1wbGUmIzE2MDtTY3JpcHQmIzU4OyYjMTA7JiMxMDtTSU4mIzE2MDtXYXZlJiMxMDtfb3V0cHV0PU1hdGguc2luKF90L19UKjIqMy4xNCkmIzEwOyYjMTA7VmFsdWUmIzE2MDtMaXN0JiMxMDt2YXImIzE2MDt2YWx1ZUxpc3Q9WzIsMy41LC0xLDEwLjMsOS4xXSYjMTA7dmFyJiMxNjA7aW5kZXg9KF90L19UKnZhbHVlTGlzdC5sZW5ndGgpLnRvRml4ZWQoMCkmIzEwO19vdXRwdXQ9dmFsdWVMaXN0W2luZGV4XSYjMTA7JiMxMDtTcXVhcmUmIzE2MDtXYXZlJiMxMDtfb3V0cHV0PTEtX291dHB1dCcgXHJcbiAgICAgICAgdmFyIHNjcmlwdFRleHRBcmVhPSQoJzx0ZXh0YXJlYSBjbGFzcz1cInczLWJvcmRlclwiIHNwZWxsY2hlY2s9XCJmYWxzZVwiIHN0eWxlPVwib3V0bGluZTpub25lO2ZvbnQtc2l6ZToxMXB4O2hlaWdodDoxNDBweDt3aWR0aDoxMDAlO2ZvbnQtZmFtaWx5OlZlcmRhbmFcIiBwbGFjZWhvbGRlcj0nK3BsYWNlSG9sZGVyU3RyKyc+PC90ZXh0YXJlYT4nKVxyXG4gICAgICAgIHBhcmVudERvbS5hcHBlbmQoc2NyaXB0TGJsLHNjcmlwdFRleHRBcmVhKVxyXG4gICAgICAgIHNjcmlwdFRleHRBcmVhLm9uKFwia2V5ZG93blwiLCAoZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZS5rZXlDb2RlID09IDkpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbnNlcnRUb1RleHRBcmVhKCdcXHQnLHNjcmlwdFRleHRBcmVhKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICBzY3JpcHRUZXh0QXJlYS5oaWdobGlnaHRXaXRoaW5UZXh0YXJlYSh7aGlnaGxpZ2h0OiBbXHJcbiAgICAgICAgICAgIHsgXCJoaWdobGlnaHRcIjogXCJfdFwiLCBcImNsYXNzTmFtZVwiOiBcIlB1cnBsZVwifSxcclxuICAgICAgICAgICAgeyBcImhpZ2hsaWdodFwiOiBcIl9UXCIsIFwiY2xhc3NOYW1lXCI6IFwiQ3lhblwifSxcclxuICAgICAgICAgICAgeyBcImhpZ2hsaWdodFwiOiBcIl9vdXRwdXRcIiwgXCJjbGFzc05hbWVcIjogXCJBbWJlclwifSxcclxuICAgICAgICBdfSk7XHJcbiAgICAgICAgdmFyIGNvbmZpcm1CdG49JCgnPGJ1dHRvbiBjbGFzcz1cInczLWJ1dHRvbiB3My1hbWJlciB3My1yaXBwbGVcIiBzdHlsZT1cInBhZGRpbmc6MnB4IDEwcHg7ZGlzcGxheTpibG9ja1wiPkNvbW1pdCBTY3JpcHQ8L2J1dHRvbj4nKVxyXG4gICAgICAgIHBhcmVudERvbS5hcHBlbmQoY29uZmlybUJ0bilcclxuICAgICAgICB2YXIgb3JpZ2luYWxWPXNpbU5vZGVJbmZvLmRldGFpbFtcImZvcm11bGFcIl1cclxuICAgICAgICBpZiAob3JpZ2luYWxWICE9IG51bGwpIHtcclxuICAgICAgICAgICAgc2NyaXB0VGV4dEFyZWEudmFsKG9yaWdpbmFsVilcclxuICAgICAgICAgICAgc2NyaXB0VGV4dEFyZWEuaGlnaGxpZ2h0V2l0aGluVGV4dGFyZWEoJ3VwZGF0ZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25maXJtQnRuLm9uKFwiY2xpY2tcIiwoKT0+e1xyXG4gICAgICAgICAgICBzaW1Ob2RlSW5mby5kZXRhaWxbXCJmb3JtdWxhXCJdID0gc2NyaXB0VGV4dEFyZWEudmFsKClcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHZhciBlcnJvcj10aGlzLmRyYXdTaW1EYXRhc291cmNlSW5mb19yZWZyZXNoQ2hhcnQoc2ltTm9kZUluZm8sZGVtb0NoYXJ0KVxyXG4gICAgICAgICAgICAgICAgaWYoZXJyb3Ipe1xyXG4gICAgICAgICAgICAgICAgICAgIGFsZXJ0KGVycm9yKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG1zYWxIZWxwZXIuY2FsbEFQSShcImRpZ2l0YWx0d2luL3VwZGF0ZVR3aW5cIiwgXCJQT1NUXCJcclxuICAgICAgICAgICAgICAgICAgICAsIHsgXCJ0d2luSURcIjogc2ltTm9kZUluZm8udHdpbklELCBcInVwZGF0ZUluZm9cIjogSlNPTi5zdHJpbmdpZnkoeyBcInNpbXVsYXRlXCI6IGRiVHdpbi5zaW11bGF0ZSB9KSB9XHJcbiAgICAgICAgICAgICAgICAgICAgLCBcIndpdGhQcm9qZWN0SURcIilcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coZSlcclxuICAgICAgICAgICAgICAgIGlmIChlLnJlc3BvbnNlVGV4dCkgYWxlcnQoZS5yZXNwb25zZVRleHQpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIGRyYXdTaW1EYXRhc291cmNlSW5mb19pbnB1dChsYmxUZXh0LCBrZXlTdHIscGxhY2VIb2xkZXJTdHIsIHBhcmVudERvbSwgc2ltTm9kZUluZm8sIGRiVHdpbixkZW1vQ2hhcnQpIHtcclxuICAgICAgICB2YXIga2V5RGl2ID0gJChcIjxkaXYgc3R5bGU9J2Rpc3BsYXk6YmxvY2s7bWFyZ2luLXRvcDouNWVtJz48ZGl2IHN0eWxlPSdkaXNwbGF5OmlubGluZTtwYWRkaW5nOi4xZW0gLjNlbSAuMWVtIC4zZW07IG1hcmdpbi1yaWdodDo1cHgnPlwiK2xibFRleHQrXCI8L2Rpdj48L2Rpdj5cIilcclxuICAgICAgICBwYXJlbnREb20uYXBwZW5kKGtleURpdilcclxuICAgICAgICB2YXIgY29udGVudERPTSA9ICQoXCI8bGFiZWwgc3R5bGU9J3BhZGRpbmctdG9wOi4yZW0nPjwvbGFiZWw+XCIpXHJcbiAgICAgICAga2V5RGl2LmFwcGVuZChjb250ZW50RE9NKVxyXG4gICAgICAgIHZhciBhSW5wdXQgPSAkKCc8aW5wdXQgdHlwZT1cInRleHRcIiBzdHlsZT1cInBhZGRpbmc6MnB4O3dpZHRoOjQwJTtvdXRsaW5lOm5vbmU7ZGlzcGxheTppbmxpbmVcIiBwbGFjZWhvbGRlcj1cIicgKyBwbGFjZUhvbGRlclN0ciArICdcIi8+JykuYWRkQ2xhc3MoXCJ3My1pbnB1dCB3My1ib3JkZXJcIik7XHJcbiAgICAgICAgY29udGVudERPTS5hcHBlbmQoYUlucHV0KVxyXG4gICAgICAgIGNvbnRlbnRET00uYXBwZW5kKCQoJzxsYWJlbD5zZWM8L2xhYmVsPicpKSBcclxuICAgICAgICB2YXIgb3JpZ2luYWxWPXNpbU5vZGVJbmZvLmRldGFpbFtrZXlTdHJdIFxyXG4gICAgICAgIGlmIChvcmlnaW5hbFYgIT0gbnVsbCkgYUlucHV0LnZhbChvcmlnaW5hbFYpXHJcbiAgICAgICAgYUlucHV0LmNoYW5nZSgoZSkgPT4ge1xyXG4gICAgICAgICAgICBzaW1Ob2RlSW5mby5kZXRhaWxba2V5U3RyXSA9ICQoZS50YXJnZXQpLnZhbCgpXHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdTaW1EYXRhc291cmNlSW5mb19yZWZyZXNoQ2hhcnQoc2ltTm9kZUluZm8sZGVtb0NoYXJ0KVxyXG4gICAgICAgICAgICAgICAgbXNhbEhlbHBlci5jYWxsQVBJKFwiZGlnaXRhbHR3aW4vdXBkYXRlVHdpblwiLCBcIlBPU1RcIlxyXG4gICAgICAgICAgICAgICAgICAgICwgeyBcInR3aW5JRFwiOiBzaW1Ob2RlSW5mby50d2luSUQsIFwidXBkYXRlSW5mb1wiOiBKU09OLnN0cmluZ2lmeSh7IFwic2ltdWxhdGVcIjogZGJUd2luLnNpbXVsYXRlIH0pIH1cclxuICAgICAgICAgICAgICAgICAgICAsIFwid2l0aFByb2plY3RJRFwiKVxyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlKVxyXG4gICAgICAgICAgICAgICAgaWYgKGUucmVzcG9uc2VUZXh0KSBhbGVydChlLnJlc3BvbnNlVGV4dClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG5cclxuICAgIGRyYXdTaW1EYXRhc291cmNlSW5mb19wcm9wZXJ0eVBhdGgocGFyZW50RG9tLHNpbU5vZGVJbmZvLGRiVHdpbil7XHJcbiAgICAgICAgdmFyIGtleURpdj0gJChcIjxsYWJlbCBzdHlsZT0nZGlzcGxheTpibG9jaztwYWRkaW5nLXRvcDouM2VtJz48ZGl2IHN0eWxlPSdkaXNwbGF5OmlubGluZTtwYWRkaW5nOi4xZW0gLjNlbSAuMWVtIC4zZW07IG1hcmdpbi1yaWdodDo1cHgnPlNpbXVsYXRlIFByb3BlcnR5PC9kaXY+PC9sYWJlbD5cIilcclxuICAgICAgICBwYXJlbnREb20uYXBwZW5kKGtleURpdikgICAgXHJcbiAgICAgICAgdmFyIGNvbnRlbnRET009JChcIjxsYWJlbCBzdHlsZT0ncGFkZGluZy10b3A6LjJlbSc+PC9sYWJlbD5cIilcclxuICAgICAgICBrZXlEaXYuYXBwZW5kKGNvbnRlbnRET00pXHJcbiAgICAgICAgdmFyIGFTZWxlY3RNZW51ID0gbmV3IHNpbXBsZVNlbGVjdE1lbnUoXCJcIiwgeyBidXR0b25DU1M6IHsgXCJwYWRkaW5nXCI6IFwiNHB4IDE2cHhcIiB9IH0pXHJcbiAgICAgICAgY29udGVudERPTS5hcHBlbmQoYVNlbGVjdE1lbnUuRE9NKVxyXG4gICAgICAgIHZhciBwcm9wZXJ0aWVzQXJyPW1vZGVsQW5hbHl6ZXIuZmV0Y2hQcm9wZXJ0eVBhdGhzT2ZNb2RlbChkYlR3aW4ubW9kZWxJRClcclxuICAgICAgICBwcm9wZXJ0aWVzQXJyLmZvckVhY2goKG9uZVByb3BlcnR5KSA9PiB7XHJcbiAgICAgICAgICAgIGFTZWxlY3RNZW51LmFkZE9wdGlvbihvbmVQcm9wZXJ0eS5qb2luKFwiLlwiKSxvbmVQcm9wZXJ0eSlcclxuICAgICAgICB9KVxyXG4gICAgICAgIHZhciBvcmlnaW5hbFBhdGg9c2ltTm9kZUluZm8uZGV0YWlsLnByb3BlcnR5UGF0aFxyXG4gICAgICAgIGFTZWxlY3RNZW51LmNhbGxCYWNrX2NsaWNrT3B0aW9uID0gKG9wdGlvblRleHQsIG9wdGlvblZhbHVlLCByZWFsTW91c2VDbGljaykgPT4ge1xyXG4gICAgICAgICAgICBhU2VsZWN0TWVudS5jaGFuZ2VOYW1lKG9wdGlvblRleHQpXHJcbiAgICAgICAgICAgIGlmKCFyZWFsTW91c2VDbGljaykgcmV0dXJuO1xyXG4gICAgICAgICAgICBpZihvcmlnaW5hbFBhdGg9PW51bGwgfHwgb3JpZ2luYWxQYXRoLmpvaW4oKSE9b3B0aW9uVmFsdWUuam9pbil7XHJcbiAgICAgICAgICAgICAgICBzaW1Ob2RlSW5mby5kZXRhaWwucHJvcGVydHlQYXRoPW9wdGlvblZhbHVlXHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1zYWxIZWxwZXIuY2FsbEFQSShcImRpZ2l0YWx0d2luL3VwZGF0ZVR3aW5cIiwgXCJQT1NUXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgLCB7XCJ0d2luSURcIjpzaW1Ob2RlSW5mby50d2luSUQsXCJ1cGRhdGVJbmZvXCI6SlNPTi5zdHJpbmdpZnkoe1wic2ltdWxhdGVcIjpkYlR3aW4uc2ltdWxhdGV9KX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLCBcIndpdGhQcm9qZWN0SURcIilcclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlLnJlc3BvbnNlVGV4dCkgYWxlcnQoZS5yZXNwb25zZVRleHQpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9yaWdpbmFsUGF0aCAhPSBudWxsKSBhU2VsZWN0TWVudS50cmlnZ2VyT3B0aW9uVGV4dChvcmlnaW5hbFBhdGguam9pbihcIi5cIikpXHJcbiAgICB9XHJcblxyXG5cclxuICAgIGRyYXdTaW5nbGVOb2RlUHJvcGVydGllcyhzaW5nbGVEQlR3aW5JbmZvLHNpbmdsZUFEVFR3aW5JbmZvLHBhcmVudERvbSxub3RFbWJlZE1ldGFkYXRhKSB7XHJcbiAgICAgICAgLy9pbnN0ZWFkIG9mIGRyYXcgdGhlICRkdElkLCBkcmF3IGRpc3BsYXkgbmFtZSBpbnN0ZWFkXHJcbiAgICAgICAgLy90aGlzLmRyYXdTdGF0aWNJbmZvKHRoaXMuRE9NLHtcIiRkdElkXCI6c2luZ2xlRWxlbWVudEluZm9bXCIkZHRJZFwiXX0sXCIxZW1cIixcIjEzcHhcIilcclxuICAgICAgICBwYXJlbnREb209cGFyZW50RG9tfHx0aGlzLkRPTVxyXG4gICAgICAgIGNvbnN0IGNvbnN0RGVzaXJlZENvbG9yPVwidzMtYW1iZXJcIlxyXG4gICAgICAgIGNvbnN0IGNvbnN0UmVwb3J0Q29sb3I9XCJ3My1ibHVlXCJcclxuICAgICAgICBjb25zdCBjb25zdFRlbGVtZXRyeUNvbG9yPVwidzMtbGltZVwiXHJcbiAgICAgICAgY29uc3QgY29uc3RDb21tb25Db2xvcj1cInczLWRhcmstZ3JheVwiXHJcblxyXG4gICAgICAgIHZhciBtb2RlbElEID0gc2luZ2xlREJUd2luSW5mby5tb2RlbElEXHJcbiAgICAgICAgdGhpcy5kcmF3U3RhdGljSW5mbyhwYXJlbnREb20sIHsgXCJuYW1lXCI6IHNpbmdsZURCVHdpbkluZm9bXCJkaXNwbGF5TmFtZVwiXSB9LCBcIi41ZW1cIiwgXCIxM3B4XCIpXHJcbiAgICAgICAgdmFyIHRoZURCTW9kZWwgPSBnbG9iYWxDYWNoZS5nZXRTaW5nbGVEQk1vZGVsQnlJRChtb2RlbElEKVxyXG4gICAgICAgIGlmICh0aGVEQk1vZGVsLmlzSW9URGV2aWNlTW9kZWwpIHtcclxuICAgICAgICAgICAgdGhpcy5kcmF3Q29ubmVjdGlvblN0YXR1cyhzaW5nbGVEQlR3aW5JbmZvW1wiY29ubmVjdFN0YXRlXCJdLHBhcmVudERvbSlcclxuICAgICAgICAgICAgdGhpcy5kcmF3U3RhdGljSW5mbyhwYXJlbnREb20sIHsgXCJDb25uZWN0aW9uIFN0YXRlIFRpbWVcIjogc2luZ2xlREJUd2luSW5mb1tcImNvbm5lY3RTdGF0ZVVwZGF0ZVRpbWVcIl0gfSwgXCIuNWVtXCIsIFwiMTBweFwiKVxyXG4gICAgICAgICAgICBwYXJlbnREb20uYXBwZW5kKCQoJzx0YWJsZSBzdHlsZT1cImZvbnQtc2l6ZTpzbWFsbGVyO21hcmdpbjozcHggMHB4XCI+PHRyPjx0ZCBjbGFzcz1cIicrY29uc3RUZWxlbWV0cnlDb2xvcisnXCI+Jm5ic3A7Jm5ic3A7PC90ZD48dGQ+dGVsZW1ldHJ5PC90ZD48dGQgY2xhc3M9XCInK2NvbnN0UmVwb3J0Q29sb3IrJ1wiPiZuYnNwOyZuYnNwOzwvdGQ+PHRkPnJlcG9ydDwvdGQ+PHRkIGNsYXNzPVwiJytjb25zdERlc2lyZWRDb2xvcisnXCI+Jm5ic3A7Jm5ic3A7PC90ZD48dGQ+ZGVzaXJlZDwvdGQ+PHRkIGNsYXNzPVwiJytjb25zdENvbW1vbkNvbG9yKydcIj4mbmJzcDsmbmJzcDs8L3RkPjx0ZD5jb21tb248L3RkPjwvdHI+PC90YWJsZT4nKSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChtb2RlbEFuYWx5emVyLkRURExNb2RlbHNbbW9kZWxJRF0pIHtcclxuICAgICAgICAgICAgaWYgKHRoZURCTW9kZWwuaXNJb1REZXZpY2VNb2RlbCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZ1bmNHZXRLZXlMYmxDb2xvckNsYXNzID0gKHByb3BlcnR5UGF0aCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2xvckNvZGVNYXBwaW5nID0ge31cclxuICAgICAgICAgICAgICAgICAgICB0aGVEQk1vZGVsLmRlc2lyZWRQcm9wZXJ0aWVzLmZvckVhY2goZGVzaXJlZFAgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvckNvZGVNYXBwaW5nW0pTT04uc3RyaW5naWZ5KGRlc2lyZWRQLnBhdGgpXSA9IGNvbnN0RGVzaXJlZENvbG9yXHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICB0aGVEQk1vZGVsLnJlcG9ydFByb3BlcnRpZXMuZm9yRWFjaChyZXBvcnRQID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JDb2RlTWFwcGluZ1tKU09OLnN0cmluZ2lmeShyZXBvcnRQLnBhdGgpXSA9IGNvbnN0UmVwb3J0Q29sb3JcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIHRoZURCTW9kZWwudGVsZW1ldHJ5UHJvcGVydGllcy5mb3JFYWNoKHRlbGVtZXRyeVAgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvckNvZGVNYXBwaW5nW0pTT04uc3RyaW5naWZ5KHRlbGVtZXRyeVAucGF0aCldID0gY29uc3RUZWxlbWV0cnlDb2xvclxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhdGhTdHIgPSBKU09OLnN0cmluZ2lmeShwcm9wZXJ0eVBhdGgpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbG9yQ29kZU1hcHBpbmdbcGF0aFN0cl0pIHJldHVybiBjb2xvckNvZGVNYXBwaW5nW3BhdGhTdHJdXHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSByZXR1cm4gY29uc3RDb21tb25Db2xvclxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZHJhd0VkaXRhYmxlKHBhcmVudERvbSwgbW9kZWxBbmFseXplci5EVERMTW9kZWxzW21vZGVsSURdLmVkaXRhYmxlUHJvcGVydGllcywgc2luZ2xlQURUVHdpbkluZm8sIFtdLCBmdW5jR2V0S2V5TGJsQ29sb3JDbGFzcylcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBtZXRhZGF0YUNvbnRlbnQgPSAkKFwiPGxhYmVsIHN0eWxlPSdkaXNwbGF5OmJsb2NrJz48L2xhYmVsPlwiKVxyXG4gICAgICAgIHZhciBleHBhbmRNZXRhQnRuPSQoXCI8ZGl2IGNsYXNzPSd3My1ib3JkZXIgdzMtYnV0dG9uIHczLWxpZ2h0LWdyYXknIHN0eWxlPSdwYWRkaW5nOi4xZW0gLjVlbTttYXJnaW4tcmlnaHQ6MWVtO2ZvbnQtc2l6ZToxMHB4Jz4uLi48L2Rpdj5cIilcclxuICAgICAgICBwYXJlbnREb20uYXBwZW5kKG1ldGFkYXRhQ29udGVudClcclxuICAgICAgICB2YXIgbWV0YURhdGFEaXY9JCgnPGRpdi8+JylcclxuICAgICAgICBtZXRhZGF0YUNvbnRlbnQuYXBwZW5kKGV4cGFuZE1ldGFCdG4sbWV0YURhdGFEaXYpXHJcbiAgICAgICAgbWV0YURhdGFEaXYuaGlkZSgpXHJcbiAgICAgICAgZXhwYW5kTWV0YUJ0bi5vbihcImNsaWNrXCIsKCk9PntleHBhbmRNZXRhQnRuLmhpZGUoKTttZXRhRGF0YURpdi5zaG93KCl9KVxyXG4gICAgICAgIGlmKG5vdEVtYmVkTWV0YWRhdGEpIGV4cGFuZE1ldGFCdG4udHJpZ2dlcihcImNsaWNrXCIpXHJcblxyXG5cclxuICAgICAgICB0aGlzLmRyYXdTdGF0aWNJbmZvKG1ldGFEYXRhRGl2LCB7IFwiTW9kZWxcIjogbW9kZWxJRCB9LCBcIjFlbVwiLCBcIjEwcHhcIilcclxuICAgICAgICBmb3IgKHZhciBpbmQgaW4gc2luZ2xlQURUVHdpbkluZm9bXCIkbWV0YWRhdGFcIl0pIHtcclxuICAgICAgICAgICAgaWYgKGluZCA9PSBcIiRtb2RlbFwiKSBjb250aW51ZTtcclxuICAgICAgICAgICAgdmFyIHRtcE9iaiA9IHt9XHJcbiAgICAgICAgICAgIHRtcE9ialtpbmRdID0gc2luZ2xlQURUVHdpbkluZm9bXCIkbWV0YWRhdGFcIl1baW5kXVxyXG4gICAgICAgICAgICB0aGlzLmRyYXdTdGF0aWNJbmZvKG1ldGFEYXRhRGl2LCB0bXBPYmosIFwiLjVlbVwiLCBcIjEwcHhcIilcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgYXN5bmMgZWRpdERUUHJvcGVydHkob3JpZ2luRWxlbWVudEluZm8sIHBhdGgsIG5ld1ZhbCwgZGF0YVR5cGUpIHtcclxuICAgICAgICBpZiAoW1wiZG91YmxlXCIsIFwiZmxvYXRcIiwgXCJpbnRlZ2VyXCIsIFwibG9uZ1wiXS5pbmNsdWRlcyhkYXRhVHlwZSkpIG5ld1ZhbCA9IE51bWJlcihuZXdWYWwpXHJcbiAgICAgICAgaWYoZGF0YVR5cGU9PVwiYm9vbGVhblwiKXtcclxuICAgICAgICAgICAgaWYobmV3VmFsPT1cInRydWVcIikgbmV3VmFsPXRydWVcclxuICAgICAgICAgICAgZWxzZSBuZXdWYWw9ZmFsc2VcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8veyBcIm9wXCI6IFwiYWRkXCIsIFwicGF0aFwiOiBcIi94XCIsIFwidmFsdWVcIjogMzAgfVxyXG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PSAxKSB7XHJcbiAgICAgICAgICAgIHZhciBzdHIgPSBcIlwiXHJcbiAgICAgICAgICAgIHBhdGguZm9yRWFjaChzZWdtZW50ID0+IHsgc3RyICs9IFwiL1wiICsgc2VnbWVudCB9KVxyXG4gICAgICAgICAgICB2YXIganNvblBhdGNoID0gW3sgXCJvcFwiOiBcImFkZFwiLCBcInBhdGhcIjogc3RyLCBcInZhbHVlXCI6IG5ld1ZhbCB9XVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vaXQgaXMgYSBwcm9wZXJ0eSBpbnNpZGUgYSBvYmplY3QgdHlwZSBvZiByb290IHByb3BlcnR5LHVwZGF0ZSB0aGUgd2hvbGUgcm9vdCBwcm9wZXJ0eVxyXG4gICAgICAgICAgICB2YXIgcm9vdFByb3BlcnR5ID0gcGF0aFswXVxyXG4gICAgICAgICAgICB2YXIgcGF0Y2hWYWx1ZSA9IG9yaWdpbkVsZW1lbnRJbmZvW3Jvb3RQcm9wZXJ0eV1cclxuICAgICAgICAgICAgaWYgKHBhdGNoVmFsdWUgPT0gbnVsbCkgcGF0Y2hWYWx1ZSA9IHt9XHJcbiAgICAgICAgICAgIGVsc2UgcGF0Y2hWYWx1ZSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocGF0Y2hWYWx1ZSkpIC8vbWFrZSBhIGNvcHlcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVPcmlnaW5PYmplY3RWYWx1ZShwYXRjaFZhbHVlLCBwYXRoLnNsaWNlKDEpLCBuZXdWYWwpXHJcblxyXG4gICAgICAgICAgICB2YXIganNvblBhdGNoID0gW3sgXCJvcFwiOiBcImFkZFwiLCBcInBhdGhcIjogXCIvXCIgKyByb290UHJvcGVydHksIFwidmFsdWVcIjogcGF0Y2hWYWx1ZSB9XVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG9yaWdpbkVsZW1lbnRJbmZvW1wiJGR0SWRcIl0pIHsgLy9lZGl0IGEgbm9kZSBwcm9wZXJ0eVxyXG4gICAgICAgICAgICB2YXIgdHdpbklEID0gb3JpZ2luRWxlbWVudEluZm9bXCIkZHRJZFwiXVxyXG4gICAgICAgICAgICB2YXIgcGF5TG9hZCA9IHsgXCJqc29uUGF0Y2hcIjogSlNPTi5zdHJpbmdpZnkoanNvblBhdGNoKSwgXCJ0d2luSURcIjogdHdpbklEIH1cclxuICAgICAgICB9IGVsc2UgaWYgKG9yaWdpbkVsZW1lbnRJbmZvW1wiJHJlbGF0aW9uc2hpcElkXCJdKSB7IC8vZWRpdCBhIHJlbGF0aW9uc2hpcCBwcm9wZXJ0eVxyXG4gICAgICAgICAgICB2YXIgdHdpbklEID0gb3JpZ2luRWxlbWVudEluZm9bXCIkc291cmNlSWRcIl1cclxuICAgICAgICAgICAgdmFyIHJlbGF0aW9uc2hpcElEID0gb3JpZ2luRWxlbWVudEluZm9bXCIkcmVsYXRpb25zaGlwSWRcIl1cclxuICAgICAgICAgICAgdmFyIHBheUxvYWQgPSB7IFwianNvblBhdGNoXCI6IEpTT04uc3RyaW5naWZ5KGpzb25QYXRjaCksIFwidHdpbklEXCI6IHR3aW5JRCwgXCJyZWxhdGlvbnNoaXBJRFwiOiByZWxhdGlvbnNoaXBJRCB9XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgYXdhaXQgbXNhbEhlbHBlci5jYWxsQVBJKFwiZGlnaXRhbHR3aW4vY2hhbmdlQXR0cmlidXRlXCIsIFwiUE9TVFwiLCBwYXlMb2FkKVxyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZU9yaWdpbk9iamVjdFZhbHVlKG9yaWdpbkVsZW1lbnRJbmZvLCBwYXRoLCBuZXdWYWwpXHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlKVxyXG4gICAgICAgICAgICBpZiAoZS5yZXNwb25zZVRleHQpIGFsZXJ0KGUucmVzcG9uc2VUZXh0KVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlT3JpZ2luT2JqZWN0VmFsdWUobm9kZUluZm8sIHBhdGhBcnIsIG5ld1ZhbCkge1xyXG4gICAgICAgIGlmIChwYXRoQXJyLmxlbmd0aCA9PSAwKSByZXR1cm47XHJcbiAgICAgICAgdmFyIHRoZUpzb24gPSBub2RlSW5mb1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aEFyci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIga2V5ID0gcGF0aEFycltpXVxyXG5cclxuICAgICAgICAgICAgaWYgKGkgPT0gcGF0aEFyci5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgICAgICB0aGVKc29uW2tleV0gPSBuZXdWYWxcclxuICAgICAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoZUpzb25ba2V5XSA9PSBudWxsKSB0aGVKc29uW2tleV0gPSB7fVxyXG4gICAgICAgICAgICB0aGVKc29uID0gdGhlSnNvbltrZXldXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSW5mb1BhbmVsOyIsImNvbnN0IG1zYWxIZWxwZXI9cmVxdWlyZShcIi4uL21zYWxIZWxwZXJcIilcclxuY29uc3QgZ2xvYmFsQ2FjaGU9cmVxdWlyZShcIi4vZ2xvYmFsQ2FjaGVcIilcclxuXHJcbmZ1bmN0aW9uIGVkaXRQcm9qZWN0RGlhbG9nKCkge1xyXG4gICAgaWYoIXRoaXMuRE9NKXtcclxuICAgICAgICB0aGlzLkRPTSA9ICQoJzxkaXYgc3R5bGU9XCJwb3NpdGlvbjphYnNvbHV0ZTt0b3A6NTAlO2JhY2tncm91bmQtY29sb3I6d2hpdGU7bGVmdDo1MCU7dHJhbnNmb3JtOiB0cmFuc2xhdGVYKC01MCUpIHRyYW5zbGF0ZVkoLTUwJSk7ei1pbmRleDoxMDFcIiBjbGFzcz1cInczLWNhcmQtMlwiPjwvZGl2PicpXHJcbiAgICAgICAgJChcImJvZHlcIikuYXBwZW5kKHRoaXMuRE9NKVxyXG4gICAgICAgIHRoaXMuRE9NLmhpZGUoKVxyXG4gICAgICAgIGdsb2JhbENhY2hlLm1ha2VET01EcmFnZ2FibGUodGhpcy5ET00pXHJcbiAgICB9XHJcbn1cclxuXHJcbmVkaXRQcm9qZWN0RGlhbG9nLnByb3RvdHlwZS5wb3B1cCA9IGZ1bmN0aW9uIChwcm9qZWN0SW5mbykge1xyXG4gICAgdGhpcy5ET00uc2hvdygpXHJcbiAgICB0aGlzLkRPTS5lbXB0eSgpXHJcbiAgICB0aGlzLnByb2plY3RJbmZvPXByb2plY3RJbmZvXHJcblxyXG4gICAgdGhpcy5ET00uY3NzKHtcIndpZHRoXCI6XCI0MjBweFwiLFwicGFkZGluZy1ib3R0b21cIjpcIjNweFwifSlcclxuICAgIHRoaXMuRE9NLmFwcGVuZCgkKCc8ZGl2IHN0eWxlPVwiaGVpZ2h0OjQwcHg7bWFyZ2luLWJvdHRvbToycHhcIiBjbGFzcz1cInczLWJhciB3My1yZWRcIj48ZGl2IGNsYXNzPVwidzMtYmFyLWl0ZW1cIiBzdHlsZT1cImZvbnQtc2l6ZToxLjJlbVwiPlByb2plY3QgU2V0dGluZzwvZGl2PjwvZGl2PicpKVxyXG4gICAgdmFyIGNsb3NlQnV0dG9uID0gJCgnPGJ1dHRvbiBjbGFzcz1cInczLWJhci1pdGVtIHczLWJ1dHRvbiB3My1yaWdodFwiIHN0eWxlPVwiZm9udC1zaXplOjJlbTtwYWRkaW5nLXRvcDo0cHhcIj7DlzwvYnV0dG9uPicpXHJcbiAgICB0aGlzLkRPTS5jaGlsZHJlbignOmZpcnN0JykuYXBwZW5kKGNsb3NlQnV0dG9uKVxyXG4gICAgY2xvc2VCdXR0b24ub24oXCJjbGlja1wiLCAoKSA9PiB7IHRoaXMuRE9NLmhpZGUoKSB9KVxyXG5cclxuICAgIHZhciByb3cxPSQoJzxkaXYgY2xhc3M9XCJ3My1iYXJcIiBzdHlsZT1cInBhZGRpbmc6MnB4XCI+PC9kaXY+JylcclxuICAgIHRoaXMuRE9NLmFwcGVuZChyb3cxKVxyXG4gICAgdmFyIGxhYmxlPSQoJzxkaXYgY2xhc3M9XCJ3My1iYXItaXRlbSB3My1vcGFjaXR5XCIgc3R5bGU9XCJwYWRkaW5nLXJpZ2h0OjVweDtcIj5OYW1lIDwvZGl2PicpXHJcbiAgICByb3cxLmFwcGVuZChsYWJsZSlcclxuICAgIHZhciBuYW1lSW5wdXQ9JCgnPGlucHV0IHR5cGU9XCJ0ZXh0XCIgc3R5bGU9XCJvdXRsaW5lOm5vbmU7IHdpZHRoOjcwJTsgZGlzcGxheTppbmxpbmU7bWFyZ2luLWxlZnQ6MnB4O21hcmdpbi1yaWdodDoycHhcIiAgcGxhY2Vob2xkZXI9XCJQcm9qZWN0IE5hbWUuLi5cIi8+JykuYWRkQ2xhc3MoXCJ3My1pbnB1dCB3My1ib3JkZXJcIik7ICAgXHJcbiAgICByb3cxLmFwcGVuZChuYW1lSW5wdXQpXHJcbiAgICBuYW1lSW5wdXQudmFsKHByb2plY3RJbmZvLm5hbWUpXHJcbiAgICBuYW1lSW5wdXQub24oXCJjaGFuZ2VcIixhc3luYyAoKT0+e1xyXG4gICAgICAgIHZhciBuYW1lU3RyPW5hbWVJbnB1dC52YWwoKVxyXG4gICAgICAgIGlmKG5hbWVTdHI9PVwiXCIpIHtcclxuICAgICAgICAgICAgYWxlcnQoXCJOYW1lIGNhbiBub3QgYmUgZW1wdHkhXCIpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJlcXVlc3RCb2R5PXtcInByb2plY3RJRFwiOnByb2plY3RJbmZvLmlkLFwiYWNjb3VudHNcIjpbXSxcIm5ld1Byb2plY3ROYW1lXCI6bmFtZVN0cn1cclxuICAgICAgICByZXF1ZXN0Qm9keS5hY2NvdW50cz1yZXF1ZXN0Qm9keS5hY2NvdW50cy5jb25jYXQocHJvamVjdEluZm8uc2hhcmVXaXRoKVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGF3YWl0IG1zYWxIZWxwZXIuY2FsbEFQSShcImFjY291bnRNYW5hZ2VtZW50L2NoYW5nZU93blByb2plY3ROYW1lXCIsIFwiUE9TVFwiLCByZXF1ZXN0Qm9keSlcclxuICAgICAgICAgICAgbmFtZUlucHV0LmJsdXIoKVxyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coZSlcclxuICAgICAgICAgICAgaWYgKGUucmVzcG9uc2VUZXh0KSBhbGVydChlLnJlc3BvbnNlVGV4dClcclxuICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgfVxyXG4gICAgfSlcclxuXHJcblxyXG5cclxuICAgIHZhciByb3cyPSQoJzxkaXYgY2xhc3M9XCJ3My1iYXJcIiBzdHlsZT1cInBhZGRpbmc6MnB4XCI+PC9kaXY+JylcclxuICAgIHRoaXMuRE9NLmFwcGVuZChyb3cyKVxyXG4gICAgdmFyIGxhYmxlPSQoJzxkaXYgY2xhc3M9XCJ3My1iYXItaXRlbSB3My1vcGFjaXR5XCIgc3R5bGU9XCJwYWRkaW5nLXJpZ2h0OjVweDtcIj5TaGFyZSBXaXRoIDwvZGl2PicpXHJcbiAgICByb3cyLmFwcGVuZChsYWJsZSlcclxuICAgIHZhciBzaGFyZUFjY291bnRJbnB1dD0kKCc8aW5wdXQgdHlwZT1cInRleHRcIiBzdHlsZT1cIm91dGxpbmU6bm9uZTsgd2lkdGg6NjAlOyBkaXNwbGF5OmlubGluZTttYXJnaW4tbGVmdDoycHg7bWFyZ2luLXJpZ2h0OjJweFwiICBwbGFjZWhvbGRlcj1cIkludml0ZWUgRW1haWwuLi5cIi8+JykuYWRkQ2xhc3MoXCJ3My1pbnB1dCB3My1ib3JkZXJcIik7ICAgXHJcbiAgICByb3cyLmFwcGVuZChzaGFyZUFjY291bnRJbnB1dClcclxuICAgIHZhciBpbnZpdGVCdG49JCgnPGEgY2xhc3M9XCJ3My1idXR0b24gdzMtYm9yZGVyIHczLXJlZCB3My1ob3Zlci1hbWJlclwiIGhyZWY9XCIjXCI+SW52aXRlPC9hPicpIFxyXG4gICAgcm93Mi5hcHBlbmQoaW52aXRlQnRuKSBcclxuXHJcbiAgICB2YXIgc2hhcmVBY2NvdW50c0xpc3Q9JChcIjxkaXYgY2xhc3M9J3czLWJvcmRlciB3My1wYWRkaW5nJyBzdHlsZT0nbWFyZ2luOjFweCAxcHg7IGhlaWdodDoyMDBweDtvdmVyZmxvdy14OmhpZGRlbjtvdmVyZmxvdy15OmF1dG8nPjxkaXY+XCIpXHJcbiAgICB0aGlzLkRPTS5hcHBlbmQoc2hhcmVBY2NvdW50c0xpc3QpXHJcbiAgICB0aGlzLnNoYXJlQWNjb3VudHNMaXN0PXNoYXJlQWNjb3VudHNMaXN0O1xyXG4gICAgdGhpcy5kcmF3U2hhcmVkQWNjb3VudHMoKVxyXG5cclxuICAgIHNoYXJlQWNjb3VudElucHV0Lm9uKFwia2V5ZG93blwiLChldmVudCkgPT57XHJcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT0gMTMpIHRoaXMuc2hhcmVXaXRoQWNjb3VudChzaGFyZUFjY291bnRJbnB1dClcclxuICAgIH0pO1xyXG4gICAgaW52aXRlQnRuLm9uKFwiY2xpY2tcIiwoKT0+eyB0aGlzLnNoYXJlV2l0aEFjY291bnQoc2hhcmVBY2NvdW50SW5wdXQpfSlcclxufVxyXG5cclxuZWRpdFByb2plY3REaWFsb2cucHJvdG90eXBlLnNoYXJlV2l0aEFjY291bnQ9YXN5bmMgZnVuY3Rpb24oYWNjb3VudElucHV0KXtcclxuICAgIHZhciBzaGFyZVRvQWNjb3VudD1hY2NvdW50SW5wdXQudmFsKClcclxuICAgIGlmKHNoYXJlVG9BY2NvdW50PT1cIlwiKSByZXR1cm47XHJcbiAgICB2YXIgdGhlSW5kZXg9IHRoaXMucHJvamVjdEluZm8uc2hhcmVXaXRoLmluZGV4T2Yoc2hhcmVUb0FjY291bnQpXHJcbiAgICBpZih0aGVJbmRleCE9LTEpIHJldHVybjtcclxuICAgIHZhciByZXF1ZXN0Qm9keT17XCJwcm9qZWN0SURcIjp0aGlzLnByb2plY3RJbmZvLmlkLFwic2hhcmVUb0FjY291bnRcIjpzaGFyZVRvQWNjb3VudH1cclxuICAgIHRyeSB7XHJcbiAgICAgICAgYXdhaXQgbXNhbEhlbHBlci5jYWxsQVBJKFwiYWNjb3VudE1hbmFnZW1lbnQvc2hhcmVQcm9qZWN0VG9cIiwgXCJQT1NUXCIsIHJlcXVlc3RCb2R5KVxyXG4gICAgICAgIHRoaXMuYWRkQWNjb3VudFRvU2hhcmVXaXRoKHNoYXJlVG9BY2NvdW50KVxyXG4gICAgICAgIHRoaXMuZHJhd1NoYXJlZEFjY291bnRzKClcclxuICAgICAgICBhY2NvdW50SW5wdXQudmFsKFwiXCIpXHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coZSlcclxuICAgICAgICBpZiAoZS5yZXNwb25zZVRleHQpIGFsZXJ0KGUucmVzcG9uc2VUZXh0KVxyXG4gICAgICAgIHJldHVyblxyXG4gICAgfVxyXG59XHJcblxyXG5lZGl0UHJvamVjdERpYWxvZy5wcm90b3R5cGUuYWRkQWNjb3VudFRvU2hhcmVXaXRoPWZ1bmN0aW9uKHNoYXJlVG9BY2NvdW50SUQpe1xyXG4gICAgdmFyIHRoZUluZGV4PSB0aGlzLnByb2plY3RJbmZvLnNoYXJlV2l0aC5pbmRleE9mKHNoYXJlVG9BY2NvdW50SUQpXHJcbiAgICBpZih0aGVJbmRleD09LTEpIHRoaXMucHJvamVjdEluZm8uc2hhcmVXaXRoLnB1c2goc2hhcmVUb0FjY291bnRJRClcclxufVxyXG5cclxuZWRpdFByb2plY3REaWFsb2cucHJvdG90eXBlLmRyYXdTaGFyZWRBY2NvdW50cz1mdW5jdGlvbigpe1xyXG4gICAgdGhpcy5zaGFyZUFjY291bnRzTGlzdC5lbXB0eSgpXHJcbiAgICB2YXIgc2hhcmVkQWNjb3VudD10aGlzLnByb2plY3RJbmZvLnNoYXJlV2l0aFxyXG4gICAgc2hhcmVkQWNjb3VudC5mb3JFYWNoKG9uZUVtYWlsID0+IHtcclxuICAgICAgICB2YXIgYXJvdyA9ICQoJzxkaXYgY2xhc3M9XCJ3My1iYXJcIiBzdHlsZT1cInBhZGRpbmc6MnB4XCI+PC9kaXY+JylcclxuICAgICAgICB0aGlzLnNoYXJlQWNjb3VudHNMaXN0LmFwcGVuZChhcm93KVxyXG4gICAgICAgIHZhciBsYWJsZSA9ICQoJzxkaXYgY2xhc3M9XCJ3My1iYXItaXRlbSB3My1vcGFjaXR5XCIgc3R5bGU9XCJwYWRkaW5nLXJpZ2h0OjVweDtcIj4nK29uZUVtYWlsKycgPC9kaXY+JylcclxuICAgICAgICBhcm93LmFwcGVuZChsYWJsZSlcclxuICAgICAgICB2YXIgcmVtb3ZlQnRuPSQoJzxhIGNsYXNzPVwidzMtYnV0dG9uIHczLWJvcmRlciB3My1yZWQgdzMtaG92ZXItYW1iZXJcIiBzdHlsZT1cIm1hcmdpbi1sZWZ0OjEwcHh5eVwiIGhyZWY9XCIjXCI+UmVtb3ZlPC9hPicpXHJcbiAgICAgICAgYXJvdy5hcHBlbmQocmVtb3ZlQnRuKVxyXG4gICAgICAgIHJlbW92ZUJ0bi5vbihcImNsaWNrXCIsYXN5bmMgKCk9PntcclxuICAgICAgICAgICAgdmFyIHJlcXVlc3RCb2R5PXtcInByb2plY3RJRFwiOnRoaXMucHJvamVjdEluZm8uaWQsXCJub3RTaGFyZVRvQWNjb3VudFwiOm9uZUVtYWlsfVxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgbXNhbEhlbHBlci5jYWxsQVBJKFwiYWNjb3VudE1hbmFnZW1lbnQvbm90U2hhcmVQcm9qZWN0VG9cIiwgXCJQT1NUXCIsIHJlcXVlc3RCb2R5KVxyXG4gICAgICAgICAgICAgICAgdmFyIHRoZUluZGV4ID0gdGhpcy5wcm9qZWN0SW5mby5zaGFyZVdpdGguaW5kZXhPZihvbmVFbWFpbClcclxuICAgICAgICAgICAgICAgIGlmICh0aGVJbmRleCAhPSAtMSkgdGhpcy5wcm9qZWN0SW5mby5zaGFyZVdpdGguc3BsaWNlKHRoZUluZGV4LCAxKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3U2hhcmVkQWNjb3VudHMoKVxyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlKVxyXG4gICAgICAgICAgICAgICAgaWYgKGUucmVzcG9uc2VUZXh0KSBhbGVydChlLnJlc3BvbnNlVGV4dClcclxuICAgICAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgIH0pXHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gbmV3IGVkaXRQcm9qZWN0RGlhbG9nKCk7IiwiZnVuY3Rpb24gZ2xvYmFsQ2FjaGUoKXtcclxuICAgIHRoaXMuYWNjb3VudEluZm89bnVsbDtcclxuICAgIHRoaXMuam9pbmVkUHJvamVjdHNUb2tlbj1udWxsO1xyXG4gICAgdGhpcy5zaG93RmxvYXRJbmZvUGFuZWw9dHJ1ZVxyXG4gICAgdGhpcy5EQk1vZGVsc0FyciA9IFtdXHJcbiAgICB0aGlzLkRCVHdpbnMgPSB7fVxyXG4gICAgdGhpcy5tb2RlbElETWFwVG9OYW1lPXt9XHJcbiAgICB0aGlzLm1vZGVsTmFtZU1hcFRvSUQ9e31cclxuICAgIHRoaXMudHdpbklETWFwVG9EaXNwbGF5TmFtZT17fVxyXG4gICAgdGhpcy50d2luRGlzcGxheU5hbWVNYXBUb0lEPXt9XHJcbiAgICB0aGlzLnN0b3JlZFR3aW5zID0ge31cclxuICAgIHRoaXMubGF5b3V0SlNPTj17fVxyXG4gICAgdGhpcy52aXN1YWxEZWZpbml0aW9uPXtcImRlZmF1bHRcIjp7XCJkZXRhaWxcIjp7fX19XHJcbiAgICB0aGlzLnN5bWJvbExpYnM9e31cclxuXHJcbiAgICB0aGlzLmNsaXBib2FyZE5vZGVTdHlsZT1udWxsXHJcblxyXG4gICAgdGhpcy5pbml0U3RvcmVkSW5mb3JtdGlvbigpXHJcbn1cclxuXHJcbmdsb2JhbENhY2hlLnByb3RvdHlwZS5jaGVja1Rvb0xvbmdJZGxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHByZXZpb3VzVGltZT1uZXcgRGF0ZSgpLmdldFRpbWUoKVxyXG4gICAgdmFyIG1heERpZmY9MTAqNjAqMTAwMFxyXG5cclxuICAgIHZhciBwcmV2aW91c01vdXNlRG93bj1uZXcgRGF0ZSgpLmdldFRpbWUoKVxyXG4gICAgJChkb2N1bWVudCkucmVhZHkoICgpPT4ge1xyXG4gICAgICAgICQoZG9jdW1lbnQpLm1vdXNlZG93biggKGUpPT4ge1xyXG4gICAgICAgICAgICBwcmV2aW91c01vdXNlRG93bj1uZXcgRGF0ZSgpLmdldFRpbWUoKVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSlcclxuXHJcbiAgICBzZXRJbnRlcnZhbCgoKT0+e1xyXG4gICAgICAgIHZhciBjdXJyZW50VGltZT1uZXcgRGF0ZSgpLmdldFRpbWUoKVxyXG4gICAgICAgIHZhciBkaWZmMT1jdXJyZW50VGltZS1wcmV2aW91c1RpbWVcclxuICAgICAgICB2YXIgZGlmZjI9Y3VycmVudFRpbWUtcHJldmlvdXNNb3VzZURvd25cclxuICAgICAgICBpZihkaWZmMT5tYXhEaWZmIHx8IGRpZmYyPm1heERpZmYpe1xyXG4gICAgICAgICAgICAvL2xvZyBvdXQgYXMgaXQgbWVhbnMgdGhlIHBhZ2UganVzdCByZXN1bWVkIGZyb20gbG9uZyB0aW1lIGNvbXB1dGVyIHNsZWVwXHJcbiAgICAgICAgICAgIHRoaXMuc3RhbGxQYWdlKClcclxuICAgICAgICB9XHJcbiAgICAgICAgcHJldmlvdXNUaW1lPWN1cnJlbnRUaW1lXHJcbiAgICB9LDYwMDAwKVxyXG59XHJcblxyXG5nbG9iYWxDYWNoZS5wcm90b3R5cGUuc3RhbGxQYWdlPWZ1bmN0aW9uKCl7XHJcbiAgICAkKCdib2R5JykuZW1wdHkoKVxyXG4gICAgZm9yKHZhciBpbmQgaW4gZ2xvYmFsKXtcclxuICAgICAgICBpZihpbmQ9PVwibG9jYXRpb25cIikgY29udGludWVcclxuICAgICAgICB0cnl7XHJcbiAgICAgICAgICAgIGdsb2JhbFtpbmRdPW51bGxcclxuICAgICAgICB9Y2F0Y2goZSl7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGUpXHJcbiAgICAgICAgfVxyXG4gICAgfSBcclxuXHJcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcclxuICAgIHZhciBkZXN0VVJMPSB1cmwub3JpZ2luK1wiL3NwYWluZGV4Lmh0bWxcIlxyXG4gICAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2UoZGVzdFVSTCk7XHJcbn1cclxuXHJcbmdsb2JhbENhY2hlLnByb3RvdHlwZS5pbml0U3RvcmVkSW5mb3JtdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuc3RvcmVkT3V0Ym91bmRSZWxhdGlvbnNoaXBzID0ge30gXHJcbiAgICAvL3N0b3JlZCBkYXRhLCBzZXBlcmF0ZWx5IGZyb20gQURUIHNlcnZpY2UgYW5kIGZyb20gY29zbW9zREIgc2VydmljZVxyXG4gICAgdGhpcy5jdXJyZW50TGF5b3V0TmFtZT1udWxsICAgXHJcbn1cclxuXHJcbmdsb2JhbENhY2hlLnByb3RvdHlwZS5maW5kUHJvamVjdEluZm89ZnVuY3Rpb24ocHJvamVjdElEKXtcclxuICAgIHZhciBqb2luZWRQcm9qZWN0cz10aGlzLmFjY291bnRJbmZvLmpvaW5lZFByb2plY3RzXHJcbiAgICBmb3IodmFyIGk9MDtpPGpvaW5lZFByb2plY3RzLmxlbmd0aDtpKyspe1xyXG4gICAgICAgIHZhciBvbmVQcm9qZWN0PWpvaW5lZFByb2plY3RzW2ldXHJcbiAgICAgICAgaWYob25lUHJvamVjdC5pZD09cHJvamVjdElEKSByZXR1cm4gb25lUHJvamVjdFxyXG4gICAgfVxyXG59XHJcblxyXG5cclxuZ2xvYmFsQ2FjaGUucHJvdG90eXBlLnN0b3JlQURUVHdpbnM9ZnVuY3Rpb24odHdpbnNEYXRhKXtcclxuICAgIHR3aW5zRGF0YS5mb3JFYWNoKChvbmVOb2RlKT0+e3RoaXMuc3RvcmVTaW5nbGVBRFRUd2luKG9uZU5vZGUpfSk7XHJcbn1cclxuXHJcbmdsb2JhbENhY2hlLnByb3RvdHlwZS5zdG9yZVNpbmdsZUFEVFR3aW49ZnVuY3Rpb24ob25lTm9kZSl7XHJcbiAgICB0aGlzLnN0b3JlZFR3aW5zW29uZU5vZGVbXCIkZHRJZFwiXV0gPSBvbmVOb2RlXHJcbiAgICBvbmVOb2RlW1wiZGlzcGxheU5hbWVcIl09IHRoaXMudHdpbklETWFwVG9EaXNwbGF5TmFtZVtvbmVOb2RlW1wiJGR0SWRcIl1dXHJcbiAgICAvL3RoaXMuYnJvYWRjYXN0TWVzc2FnZSh7IFwibWVzc2FnZVwiOiBcIkFEVFR3aW5JbmZvVXBkYXRlXCIsXCJ0d2luSURcIjpvbmVOb2RlW1wiJGR0SWRcIl19KVxyXG59XHJcblxyXG5cclxuZ2xvYmFsQ2FjaGUucHJvdG90eXBlLnN0b3JlU2luZ2xlREJUd2luPWZ1bmN0aW9uKERCVHdpbil7XHJcbiAgICB0aGlzLkRCVHdpbnNbREJUd2luW1wiaWRcIl1dPURCVHdpblxyXG4gICAgdGhpcy50d2luSURNYXBUb0Rpc3BsYXlOYW1lW0RCVHdpbltcImlkXCJdXT1EQlR3aW5bXCJkaXNwbGF5TmFtZVwiXVxyXG4gICAgdGhpcy50d2luRGlzcGxheU5hbWVNYXBUb0lEW0RCVHdpbltcImRpc3BsYXlOYW1lXCJdXT1EQlR3aW5bXCJpZFwiXVxyXG59XHJcblxyXG5nbG9iYWxDYWNoZS5wcm90b3R5cGUuc3RvcmVEQlR3aW5zQXJyPWZ1bmN0aW9uKERCVHdpbnNBcnIpe1xyXG4gICAgZm9yKHZhciBpbmQgaW4gdGhpcy5EQlR3aW5zKSBkZWxldGUgdGhpcy5EQlR3aW5zW2luZF1cclxuICAgIGZvcih2YXIgaW5kIGluIHRoaXMudHdpbklETWFwVG9EaXNwbGF5TmFtZSkgZGVsZXRlIHRoaXMudHdpbklETWFwVG9EaXNwbGF5TmFtZVtpbmRdXHJcbiAgICBmb3IodmFyIGluZCBpbiB0aGlzLnR3aW5EaXNwbGF5TmFtZU1hcFRvSUQpIGRlbGV0ZSB0aGlzLnR3aW5EaXNwbGF5TmFtZU1hcFRvSURbaW5kXVxyXG5cclxuICAgIHRoaXMubWVyZ2VEQlR3aW5zQXJyKERCVHdpbnNBcnIpXHJcbn1cclxuXHJcbmdsb2JhbENhY2hlLnByb3RvdHlwZS5tZXJnZURCVHdpbnNBcnI9ZnVuY3Rpb24oREJUd2luc0Fycil7XHJcbiAgICBEQlR3aW5zQXJyLmZvckVhY2gob25lREJUd2luPT57XHJcbiAgICAgICAgdGhpcy5EQlR3aW5zW29uZURCVHdpbltcImlkXCJdXT1vbmVEQlR3aW5cclxuICAgICAgICB0aGlzLnR3aW5JRE1hcFRvRGlzcGxheU5hbWVbb25lREJUd2luW1wiaWRcIl1dPW9uZURCVHdpbltcImRpc3BsYXlOYW1lXCJdXHJcbiAgICAgICAgdGhpcy50d2luRGlzcGxheU5hbWVNYXBUb0lEW29uZURCVHdpbltcImRpc3BsYXlOYW1lXCJdXT1vbmVEQlR3aW5bXCJpZFwiXVxyXG4gICAgfSlcclxufVxyXG5cclxuZ2xvYmFsQ2FjaGUucHJvdG90eXBlLnN0b3JlVXNlckRhdGE9ZnVuY3Rpb24ocmVzKXtcclxuICAgIHJlcy5mb3JFYWNoKG9uZVJlc3BvbnNlPT57XHJcbiAgICAgICAgaWYob25lUmVzcG9uc2UudHlwZT09XCJqb2luZWRQcm9qZWN0c1Rva2VuXCIpIHRoaXMuam9pbmVkUHJvamVjdHNUb2tlbj1vbmVSZXNwb25zZS5qd3Q7XHJcbiAgICAgICAgZWxzZSBpZihvbmVSZXNwb25zZS50eXBlPT1cInVzZXJcIikgdGhpcy5hY2NvdW50SW5mbz1vbmVSZXNwb25zZVxyXG4gICAgfSlcclxufVxyXG5cclxuZ2xvYmFsQ2FjaGUucHJvdG90eXBlLnN0b3JlUHJvamVjdE1vZGVsc0RhdGE9ZnVuY3Rpb24oREJNb2RlbHMsYWR0TW9kZWxzKXtcclxuICAgIHRoaXMuc3RvcmVEQk1vZGVsc0FycihEQk1vZGVscylcclxuXHJcbiAgICBmb3IodmFyIGluZCBpbiB0aGlzLm1vZGVsSURNYXBUb05hbWUpIGRlbGV0ZSB0aGlzLm1vZGVsSURNYXBUb05hbWVbaW5kXVxyXG4gICAgZm9yKHZhciBpbmQgaW4gdGhpcy5tb2RlbE5hbWVNYXBUb0lEKSBkZWxldGUgdGhpcy5tb2RlbE5hbWVNYXBUb0lEW2luZF1cclxuXHJcbiAgICB2YXIgdG1wTmFtZVRvT2JqID0ge31cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWR0TW9kZWxzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGFkdE1vZGVsc1tpXVtcImRpc3BsYXlOYW1lXCJdID09IG51bGwpIGFkdE1vZGVsc1tpXVtcImRpc3BsYXlOYW1lXCJdID0gYWR0TW9kZWxzW2ldW1wiQGlkXCJdXHJcbiAgICAgICAgaWYgKCQuaXNQbGFpbk9iamVjdChhZHRNb2RlbHNbaV1bXCJkaXNwbGF5TmFtZVwiXSkpIHtcclxuICAgICAgICAgICAgaWYgKGFkdE1vZGVsc1tpXVtcImRpc3BsYXlOYW1lXCJdW1wiZW5cIl0pIGFkdE1vZGVsc1tpXVtcImRpc3BsYXlOYW1lXCJdID0gYWR0TW9kZWxzW2ldW1wiZGlzcGxheU5hbWVcIl1bXCJlblwiXVxyXG4gICAgICAgICAgICBlbHNlIGFkdE1vZGVsc1tpXVtcImRpc3BsYXlOYW1lXCJdID0gSlNPTi5zdHJpbmdpZnkoYWR0TW9kZWxzW2ldW1wiZGlzcGxheU5hbWVcIl0pXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0bXBOYW1lVG9PYmpbYWR0TW9kZWxzW2ldW1wiZGlzcGxheU5hbWVcIl1dICE9IG51bGwpIHtcclxuICAgICAgICAgICAgLy9yZXBlYXRlZCBtb2RlbCBkaXNwbGF5IG5hbWVcclxuICAgICAgICAgICAgYWR0TW9kZWxzW2ldW1wiZGlzcGxheU5hbWVcIl0gPSBhZHRNb2RlbHNbaV1bXCJAaWRcIl1cclxuICAgICAgICB9XHJcbiAgICAgICAgdG1wTmFtZVRvT2JqW2FkdE1vZGVsc1tpXVtcImRpc3BsYXlOYW1lXCJdXSA9IDFcclxuXHJcbiAgICAgICAgdGhpcy5tb2RlbElETWFwVG9OYW1lW2FkdE1vZGVsc1tpXVtcIkBpZFwiXV0gPSBhZHRNb2RlbHNbaV1bXCJkaXNwbGF5TmFtZVwiXVxyXG4gICAgICAgIHRoaXMubW9kZWxOYW1lTWFwVG9JRFthZHRNb2RlbHNbaV1bXCJkaXNwbGF5TmFtZVwiXV0gPSBhZHRNb2RlbHNbaV1bXCJAaWRcIl1cclxuICAgIH1cclxufVxyXG5cclxuZ2xvYmFsQ2FjaGUucHJvdG90eXBlLnN0b3JlUHJvamVjdFR3aW5zQW5kVmlzdWFsRGF0YT1mdW5jdGlvbihyZXNBcnIpe1xyXG4gICAgdmFyIGRidHdpbnM9W11cclxuICAgIGZvcih2YXIgaW5kIGluIHRoaXMudmlzdWFsRGVmaW5pdGlvbikgZGVsZXRlIHRoaXMudmlzdWFsRGVmaW5pdGlvbltpbmRdXHJcbiAgICBmb3IodmFyIGluZCBpbiB0aGlzLmxheW91dEpTT04pIGRlbGV0ZSB0aGlzLmxheW91dEpTT05baW5kXVxyXG4gICAgdGhpcy52aXN1YWxEZWZpbml0aW9uW1wiZGVmYXVsdFwiXT17XCJkZXRhaWxcIjp7fX1cclxuXHJcbiAgICByZXNBcnIuZm9yRWFjaChlbGVtZW50ID0+IHtcclxuICAgICAgICBpZihlbGVtZW50LnR5cGU9PVwidmlzdWFsU2NoZW1hXCIpIHtcclxuICAgICAgICAgICAgLy9UT0RPOiBub3cgdGhlcmUgaXMgb25seSBvbmUgXCJkZWZhdWx0XCIgc2NoZW1hIHRvIHVzZSxjb25zaWRlciBhbGxvdyBjcmVhdGluZyBtb3JlIHVzZXIgZGVmaW5lIHZpc3VhbCBzY2hlbWFcclxuICAgICAgICAgICAgLy9UT0RPOiBvbmx5IGNob29zZSB0aGUgc2NoZW1hIGJlbG9uZ3MgdG8gc2VsZlxyXG4gICAgICAgICAgICB0aGlzLnJlY29yZFNpbmdsZVZpc3VhbFNjaGVtYShlbGVtZW50LmRldGFpbCxlbGVtZW50LmFjY291bnRJRCxlbGVtZW50Lm5hbWUsZWxlbWVudC5pc1NoYXJlZClcclxuICAgICAgICB9ZWxzZSBpZihlbGVtZW50LnR5cGU9PVwiVG9wb2xvZ3lcIikge1xyXG4gICAgICAgICAgICB0aGlzLnJlY29yZFNpbmdsZUxheW91dChlbGVtZW50LmRldGFpbCxlbGVtZW50LmFjY291bnRJRCxlbGVtZW50Lm5hbWUsZWxlbWVudC5pc1NoYXJlZClcclxuICAgICAgICB9ZWxzZSBpZihlbGVtZW50LnR5cGU9PVwiRFRUd2luXCIpIGRidHdpbnMucHVzaChlbGVtZW50KVxyXG4gICAgICAgIGVsc2UgaWYoZWxlbWVudC50eXBlPT1cInN5bWJvbHNcIil7XHJcbiAgICAgICAgICAgIHRoaXMuc3ltYm9sTGlic1tlbGVtZW50LmRpc3BsYXlOYW1lXT1lbGVtZW50LmRldGFpbFxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgdGhpcy5zdG9yZURCVHdpbnNBcnIoZGJ0d2lucylcclxuXHJcbiAgICByZXNBcnIuZm9yRWFjaChlbGVtZW50ID0+IHtcclxuICAgICAgICBpZihlbGVtZW50Lm9yaWdpbmFsU2NyaXB0IT1udWxsKSB7IFxyXG4gICAgICAgICAgICB2YXIgdHdpbklEPWVsZW1lbnQudHdpbklEXHJcbiAgICAgICAgICAgIHZhciBvbmVEQlR3aW49dGhpcy5EQlR3aW5zW3R3aW5JRF1cclxuICAgICAgICAgICAgaWYob25lREJUd2luKXtcclxuICAgICAgICAgICAgICAgIG9uZURCVHdpbltcIm9yaWdpbmFsU2NyaXB0XCJdPWVsZW1lbnRbXCJvcmlnaW5hbFNjcmlwdFwiXVxyXG4gICAgICAgICAgICAgICAgb25lREJUd2luW1wibGFzdEV4ZWN1dGlvblRpbWVcIl09ZWxlbWVudFtcImxhc3RFeGVjdXRpb25UaW1lXCJdXHJcbiAgICAgICAgICAgICAgICBvbmVEQlR3aW5bXCJhdXRob3JcIl09ZWxlbWVudFtcImF1dGhvclwiXVxyXG4gICAgICAgICAgICAgICAgb25lREJUd2luW1wiaW52YWxpZEZsYWdcIl09ZWxlbWVudFtcImludmFsaWRGbGFnXCJdXHJcbiAgICAgICAgICAgICAgICBvbmVEQlR3aW5bXCJpbnB1dHNcIl09ZWxlbWVudFtcImlucHV0c1wiXVxyXG4gICAgICAgICAgICAgICAgb25lREJUd2luW1wib3V0cHV0c1wiXT1lbGVtZW50W1wib3V0cHV0c1wiXVxyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcblxyXG5nbG9iYWxDYWNoZS5wcm90b3R5cGUucmVjb3JkU2luZ2xlVmlzdWFsU2NoZW1hPWZ1bmN0aW9uKGRldGFpbCxhY2NvdW50SUQsb25hbWUsaXNTaGFyZWQpe1xyXG4gICAgaWYgKGFjY291bnRJRCA9PSB0aGlzLmFjY291bnRJbmZvLmlkKSB2YXIgdnNOYW1lID0gb25hbWVcclxuICAgIGVsc2UgdnNOYW1lID0gb25hbWUgKyBgKGZyb20gJHthY2NvdW50SUR9KWBcclxuICAgIHZhciBkaWN0ID0geyBcImRldGFpbFwiOiBkZXRhaWwsIFwiaXNTaGFyZWRcIjogaXNTaGFyZWQsIFwib3duZXJcIjogYWNjb3VudElELCBcIm9uYW1lXCI6IG9uYW1lfVxyXG4gICAgdGhpcy52aXN1YWxEZWZpbml0aW9uW3ZzTmFtZV09ZGljdFxyXG59XHJcblxyXG5nbG9iYWxDYWNoZS5wcm90b3R5cGUucmVjb3JkU2luZ2xlTGF5b3V0PWZ1bmN0aW9uKGRldGFpbCxhY2NvdW50SUQsb25hbWUsaXNTaGFyZWQpe1xyXG4gICAgaWYgKGFjY291bnRJRCA9PSB0aGlzLmFjY291bnRJbmZvLmlkKSB2YXIgbGF5b3V0TmFtZSA9IG9uYW1lXHJcbiAgICBlbHNlIGxheW91dE5hbWUgPSBvbmFtZSArIGAoZnJvbSAke2FjY291bnRJRH0pYFxyXG4gICAgdmFyIGRpY3QgPSB7IFwiZGV0YWlsXCI6IGRldGFpbCwgXCJpc1NoYXJlZFwiOiBpc1NoYXJlZCwgXCJvd25lclwiOiBhY2NvdW50SUQsIFwibmFtZVwiOiBsYXlvdXROYW1lLCBcIm9uYW1lXCI6b25hbWUgfVxyXG4gICAgdGhpcy5sYXlvdXRKU09OW2xheW91dE5hbWVdID0gZGljdFxyXG59XHJcblxyXG5nbG9iYWxDYWNoZS5wcm90b3R5cGUuZ2V0REJUd2luc0J5TW9kZWxJRD1mdW5jdGlvbihtb2RlbElEKXtcclxuICAgIHZhciByZXN1bHRBcnI9W11cclxuICAgIGZvcih2YXIgaW5kIGluIHRoaXMuREJUd2lucyl7XHJcbiAgICAgICAgdmFyIGVsZT10aGlzLkRCVHdpbnNbaW5kXVxyXG4gICAgICAgIGlmKGVsZS5tb2RlbElEPT1tb2RlbElEKXtcclxuICAgICAgICAgICAgcmVzdWx0QXJyLnB1c2goZWxlKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHRBcnI7XHJcbn1cclxuXHJcbmdsb2JhbENhY2hlLnByb3RvdHlwZS5nZXRTaW5nbGVEQlR3aW5CeU5hbWU9ZnVuY3Rpb24odHdpbk5hbWUpe1xyXG4gICAgdmFyIHR3aW5JRD10aGlzLnR3aW5EaXNwbGF5TmFtZU1hcFRvSURbdHdpbk5hbWVdXHJcbiAgICByZXR1cm4gdGhpcy5EQlR3aW5zW3R3aW5JRF1cclxufVxyXG5cclxuZ2xvYmFsQ2FjaGUucHJvdG90eXBlLmdldFNpbmdsZURCVHdpbkJ5SW5kb29yRmVhdHVyZUlEPWZ1bmN0aW9uKGZlYXR1cmVJRCl7XHJcbiAgICBmb3IodmFyIGluZCBpbiB0aGlzLkRCVHdpbnMpe1xyXG4gICAgICAgIHZhciBlbGU9dGhpcy5EQlR3aW5zW2luZF1cclxuICAgICAgICBpZihlbGUuR0lTICYmIGVsZS5HSVMuaW5kb29yKXtcclxuICAgICAgICAgICAgaWYoZWxlLkdJUy5pbmRvb3IuSW5kb29yRmVhdHVyZUlEPT1mZWF0dXJlSUQpIHJldHVybiBlbGVcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG5cclxuZ2xvYmFsQ2FjaGUucHJvdG90eXBlLmdldFNpbmdsZURCTW9kZWxCeUlEPWZ1bmN0aW9uKG1vZGVsSUQpe1xyXG4gICAgZm9yKHZhciBpPTA7aTx0aGlzLkRCTW9kZWxzQXJyLmxlbmd0aDtpKyspe1xyXG4gICAgICAgIHZhciBlbGUgPSB0aGlzLkRCTW9kZWxzQXJyW2ldXHJcbiAgICAgICAgaWYoZWxlLmlkPT1tb2RlbElEKXtcclxuICAgICAgICAgICAgcmV0dXJuIGVsZVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcblxyXG5nbG9iYWxDYWNoZS5wcm90b3R5cGUuc3RvcmVTaW5nbGVEQk1vZGVsPWZ1bmN0aW9uKHNpbmdsZURCTW9kZWxJbmZvKXtcclxuICAgIHZhciBtb2RlbElEID0gc2luZ2xlREJNb2RlbEluZm8uaWRcclxuICAgIGZvcih2YXIgaT0wO2k8dGhpcy5EQk1vZGVsc0Fyci5sZW5ndGg7aSsrKXtcclxuICAgICAgICB2YXIgZWxlID0gdGhpcy5EQk1vZGVsc0FycltpXVxyXG4gICAgICAgIGlmKGVsZS5pZD09bW9kZWxJRCl7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaW5kIGluIGVsZSkgZGVsZXRlIGVsZVtpbmRdXHJcbiAgICAgICAgICAgIGZvcih2YXIgaW5kIGluIHNpbmdsZURCTW9kZWxJbmZvKSBlbGVbaW5kXT1zaW5nbGVEQk1vZGVsSW5mb1tpbmRdXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvL2l0IGlzIGEgbmV3IHNpbmdsZSBtb2RlbCBpZiBjb2RlIHJlYWNoZXMgaGVyZVxyXG4gICAgdGhpcy5EQk1vZGVsc0Fyci5wdXNoKHNpbmdsZURCTW9kZWxJbmZvKVxyXG4gICAgdGhpcy5zb3J0REJNb2RlbHNBcnIoKVxyXG59XHJcblxyXG5nbG9iYWxDYWNoZS5wcm90b3R5cGUuc3RvcmVEQk1vZGVsc0Fycj1mdW5jdGlvbihEQk1vZGVsc0Fycil7XHJcbiAgICB0aGlzLkRCTW9kZWxzQXJyLmxlbmd0aD0wXHJcbiAgICB0aGlzLkRCTW9kZWxzQXJyPXRoaXMuREJNb2RlbHNBcnIuY29uY2F0KERCTW9kZWxzQXJyKVxyXG4gICAgdGhpcy5zb3J0REJNb2RlbHNBcnIoKVxyXG4gICAgXHJcbn1cclxuZ2xvYmFsQ2FjaGUucHJvdG90eXBlLnNvcnREQk1vZGVsc0Fycj1mdW5jdGlvbigpe1xyXG4gICAgdGhpcy5EQk1vZGVsc0Fyci5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IFxyXG4gICAgICAgIHZhciBhTmFtZT1hLmRpc3BsYXlOYW1lLnRvTG93ZXJDYXNlKClcclxuICAgICAgICB2YXIgYk5hbWU9Yi5kaXNwbGF5TmFtZS50b0xvd2VyQ2FzZSgpXHJcbiAgICAgICAgcmV0dXJuIGFOYW1lLmxvY2FsZUNvbXBhcmUoYk5hbWUpIFxyXG4gICAgfSk7XHJcbn1cclxuXHJcblxyXG5nbG9iYWxDYWNoZS5wcm90b3R5cGUuZ2V0U3RvcmVkQWxsSW5ib3VuZFJlbGF0aW9uc1NvdXJjZXM9ZnVuY3Rpb24odHdpbklEKXtcclxuICAgIHZhciBzcmNUd2lucz17fVxyXG4gICAgZm9yKHZhciBzcmNUd2luIGluIHRoaXMuc3RvcmVkT3V0Ym91bmRSZWxhdGlvbnNoaXBzKXtcclxuICAgICAgICB2YXIgYXJyPXRoaXMuc3RvcmVkT3V0Ym91bmRSZWxhdGlvbnNoaXBzW3NyY1R3aW5dXHJcbiAgICAgICAgYXJyLmZvckVhY2gob25lUmVsYXRpb249PntcclxuICAgICAgICAgICAgaWYob25lUmVsYXRpb25bXCIkdGFyZ2V0SWRcIl09PXR3aW5JRCkgc3JjVHdpbnNbb25lUmVsYXRpb25bXCIkc291cmNlSWRcIl1dPTFcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHNyY1R3aW5zO1xyXG59XHJcblxyXG5nbG9iYWxDYWNoZS5wcm90b3R5cGUuc3RvcmVUd2luUmVsYXRpb25zaGlwcz1mdW5jdGlvbihyZWxhdGlvbnNEYXRhKXtcclxuICAgIHJlbGF0aW9uc0RhdGEuZm9yRWFjaCgob25lUmVsYXRpb25zaGlwKT0+e1xyXG4gICAgICAgIHZhciB0d2luSUQ9b25lUmVsYXRpb25zaGlwWyckc291cmNlSWQnXVxyXG4gICAgICAgIHRoaXMuc3RvcmVkT3V0Ym91bmRSZWxhdGlvbnNoaXBzW3R3aW5JRF09W11cclxuICAgIH0pXHJcblxyXG4gICAgcmVsYXRpb25zRGF0YS5mb3JFYWNoKChvbmVSZWxhdGlvbnNoaXApPT57XHJcbiAgICAgICAgdGhpcy5zdG9yZWRPdXRib3VuZFJlbGF0aW9uc2hpcHNbb25lUmVsYXRpb25zaGlwWyckc291cmNlSWQnXV0ucHVzaChvbmVSZWxhdGlvbnNoaXApXHJcbiAgICB9KVxyXG59XHJcblxyXG5nbG9iYWxDYWNoZS5wcm90b3R5cGUuc3RvcmVUd2luUmVsYXRpb25zaGlwc19hcHBlbmQ9ZnVuY3Rpb24ocmVsYXRpb25zRGF0YSl7XHJcbiAgICByZWxhdGlvbnNEYXRhLmZvckVhY2goKG9uZVJlbGF0aW9uc2hpcCk9PntcclxuICAgICAgICBpZighdGhpcy5zdG9yZWRPdXRib3VuZFJlbGF0aW9uc2hpcHNbb25lUmVsYXRpb25zaGlwWyckc291cmNlSWQnXV0pXHJcbiAgICAgICAgICAgIHRoaXMuc3RvcmVkT3V0Ym91bmRSZWxhdGlvbnNoaXBzW29uZVJlbGF0aW9uc2hpcFsnJHNvdXJjZUlkJ11dPVtdXHJcbiAgICAgICAgdGhpcy5zdG9yZWRPdXRib3VuZFJlbGF0aW9uc2hpcHNbb25lUmVsYXRpb25zaGlwWyckc291cmNlSWQnXV0ucHVzaChvbmVSZWxhdGlvbnNoaXApXHJcbiAgICB9KVxyXG59XHJcblxyXG5nbG9iYWxDYWNoZS5wcm90b3R5cGUuc3RvcmVUd2luUmVsYXRpb25zaGlwc19yZW1vdmU9ZnVuY3Rpb24ocmVsYXRpb25zRGF0YSl7XHJcbiAgICByZWxhdGlvbnNEYXRhLmZvckVhY2goKG9uZVJlbGF0aW9uc2hpcCk9PntcclxuICAgICAgICB2YXIgc3JjSUQ9b25lUmVsYXRpb25zaGlwW1wic3JjSURcIl1cclxuICAgICAgICBpZih0aGlzLnN0b3JlZE91dGJvdW5kUmVsYXRpb25zaGlwc1tzcmNJRF0pe1xyXG4gICAgICAgICAgICB2YXIgYXJyPXRoaXMuc3RvcmVkT3V0Ym91bmRSZWxhdGlvbnNoaXBzW3NyY0lEXVxyXG4gICAgICAgICAgICBmb3IodmFyIGk9MDtpPGFyci5sZW5ndGg7aSsrKXtcclxuICAgICAgICAgICAgICAgIGlmKGFycltpXVsnJHJlbGF0aW9uc2hpcElkJ109PW9uZVJlbGF0aW9uc2hpcFtcInJlbElEXCJdKXtcclxuICAgICAgICAgICAgICAgICAgICBhcnIuc3BsaWNlKGksMSlcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pXHJcbn1cclxuXHJcbmdsb2JhbENhY2hlLnByb3RvdHlwZS5maW5kQWxsSW5wdXRzSW5TY3JpcHQ9ZnVuY3Rpb24oY2FsY1NjcmlwdCxmb3JtdWxhVHdpbk5hbWUpe1xyXG4gICAgLy9maW5kIGFsbCBwcm9wZXJ0aWVzIGluIHRoZSBzY3JpcHRcclxuICAgIGNhbGNTY3JpcHQrPVwiXFxuXCIgLy9tYWtlIHN1cmUgdGhlIGJlbG93IHBhdHRlcm5zIHVzaW5nIFwiW14uIF0gbm90IGZhaWwgYmVjYXVzZSBvZiBpdCBpcyB0aGUgZW5kIG9mIHN0cmluZyBcIlxyXG4gICAgdmFyIHBhdHQgPSAvX3NlbGYoPzw9X3NlbGYpXFxbXFxcIi4qPyg/PVxcXCJcXF1bXlxcW10pXFxcIlxcXS9nOyBcclxuICAgIHZhciBhbGxTZWxmUHJvcGVydGllcz1jYWxjU2NyaXB0Lm1hdGNoKHBhdHQpfHxbXTtcclxuICAgIHZhciBjb3VudEFsbFNlbGZUaW1lcz17fVxyXG4gICAgYWxsU2VsZlByb3BlcnRpZXMuZm9yRWFjaChvbmVTZWxmPT57XHJcbiAgICAgICAgaWYoY291bnRBbGxTZWxmVGltZXNbb25lU2VsZl0pIGNvdW50QWxsU2VsZlRpbWVzW29uZVNlbGZdKz0xXHJcbiAgICAgICAgZWxzZSBjb3VudEFsbFNlbGZUaW1lc1tvbmVTZWxmXT0xXHJcbiAgICB9KVxyXG5cclxuICAgIHZhciBwYXR0ID0gL190d2luVmFsKD88PV90d2luVmFsKVxcW1xcXCIuKj8oPz1cXFwiXFxdW15cXFtdKVxcXCJcXF0vZzsgXHJcbiAgICB2YXIgYWxsT3RoZXJUd2luUHJvcGVydGllcz1jYWxjU2NyaXB0Lm1hdGNoKHBhdHQpfHxbXTtcclxuICAgIHZhciBsaXN0QWxsT3RoZXJzPXt9XHJcbiAgICBhbGxPdGhlclR3aW5Qcm9wZXJ0aWVzLmZvckVhY2gob25lT3RoZXI9PntsaXN0QWxsT3RoZXJzW29uZU90aGVyXT0xIH0pXHJcblxyXG4gICAgLy9hbmFseXplIGFsbCB2YXJpYWJsZXMgdGhhdCBjYW4gbm90IGJlIGFzIGlucHV0IGFzIHRoZXkgYXJlIGNoYW5nZWQgZHVyaW5nIGNhbGN1YXRpb25cclxuICAgIC8vdGhleSBkaXNxdWFsaWZ5IGFzIGlucHV0IGFzIHRoZXkgd2lsbCB0cmlnZ2VyIGluZmluaXRlIGNhbGN1bGF0aW9uLCBhbGwgdGhlc2UgYmVsb25ncyB0byBfc2VsZlxyXG4gICAgdmFyIG91dHB1dHBhdHQgPSAvX3NlbGYoPzw9X3NlbGYpXFxbXFxcIlteO3tdKj9bXlxcPV0oPz1cXD1bXlxcPV0pL2c7XHJcbiAgICB2YXIgb3V0cHV0UHJvcGVydGllcz1jYWxjU2NyaXB0Lm1hdGNoKG91dHB1dHBhdHQpfHxbXTtcclxuICAgIHZhciBjb3VudE91dHB1dFRpbWVzPXt9XHJcbiAgICBvdXRwdXRQcm9wZXJ0aWVzLmZvckVhY2gob25lT3V0cHV0PT57XHJcbiAgICAgICAgaWYoY291bnRPdXRwdXRUaW1lc1tvbmVPdXRwdXRdKSBjb3VudE91dHB1dFRpbWVzW29uZU91dHB1dF0rPTFcclxuICAgICAgICBlbHNlIGNvdW50T3V0cHV0VGltZXNbb25lT3V0cHV0XT0xXHJcbiAgICB9KVxyXG4gICAgXHJcblxyXG4gICAgdmFyIGlucHV0UHJvcGVydGllc0Fycj1bXVxyXG4gICAgZm9yKHZhciBpbmQgaW4gbGlzdEFsbE90aGVycykgaW5wdXRQcm9wZXJ0aWVzQXJyLnB1c2goaW5kKVxyXG4gICAgZm9yKHZhciBpbmQgaW4gY291bnRBbGxTZWxmVGltZXMpe1xyXG4gICAgICAgIGlmKGNvdW50QWxsU2VsZlRpbWVzW2luZF0hPWNvdW50T3V0cHV0VGltZXNbaW5kXSkgaW5wdXRQcm9wZXJ0aWVzQXJyLnB1c2goaW5kKVxyXG4gICAgfVxyXG5cclxuICAgIHZhciByZXR1cm5BcnI9W11cclxuICAgIGlucHV0UHJvcGVydGllc0Fyci5mb3JFYWNoKG9uZVByb3BlcnR5PT57XHJcbiAgICAgICAgdmFyIG9uZUlucHV0T2JqPXt9IC8vdHdpbklELCBwYXRoLCB2YWx1ZVxyXG4gICAgICAgIHZhciBmZXRjaHByb3BlcnR5cGF0dCA9IC8oPzw9XFxbXFxcIikuKj8oPz1cXFwiXFxdKS9nO1xyXG4gICAgICAgIGlmKG9uZVByb3BlcnR5LnN0YXJ0c1dpdGgoXCJfc2VsZlwiKSl7XHJcbiAgICAgICAgICAgIG9uZUlucHV0T2JqLnBhdGg9b25lUHJvcGVydHkubWF0Y2goZmV0Y2hwcm9wZXJ0eXBhdHQpO1xyXG4gICAgICAgICAgICBvbmVJbnB1dE9iai50d2luTmFtZT1mb3JtdWxhVHdpbk5hbWUrXCIoc2VsZilcIlxyXG4gICAgICAgICAgICBvbmVJbnB1dE9iai50d2luTmFtZV9vcmlnaW49Zm9ybXVsYVR3aW5OYW1lXHJcbiAgICAgICAgICAgIHZhciB0d2luSUQ9dGhpcy50d2luRGlzcGxheU5hbWVNYXBUb0lEW2Zvcm11bGFUd2luTmFtZV1cclxuICAgICAgICAgICAgb25lSW5wdXRPYmoudmFsdWU9dGhpcy5zZWFyY2hWYWx1ZSh0aGlzLnN0b3JlZFR3aW5zW3R3aW5JRF0sb25lSW5wdXRPYmoucGF0aClcclxuICAgICAgICB9ZWxzZSBpZihvbmVQcm9wZXJ0eS5zdGFydHNXaXRoKFwiX3R3aW5WYWxcIikpe1xyXG4gICAgICAgICAgICB2YXIgYXJyPW9uZVByb3BlcnR5Lm1hdGNoKGZldGNocHJvcGVydHlwYXR0KTtcclxuICAgICAgICAgICAgdmFyIGZpcnN0RWxlPWFyclswXVxyXG4gICAgICAgICAgICBhcnIuc2hpZnQoKVxyXG4gICAgICAgICAgICBvbmVJbnB1dE9iai5wYXRoPWFyclxyXG4gICAgICAgICAgICB2YXIgdHdpbklEPXRoaXMudHdpbkRpc3BsYXlOYW1lTWFwVG9JRFtmaXJzdEVsZV1cclxuICAgICAgICAgICAgb25lSW5wdXRPYmoudmFsdWU9dGhpcy5zZWFyY2hWYWx1ZSh0aGlzLnN0b3JlZFR3aW5zW3R3aW5JRF0sb25lSW5wdXRPYmoucGF0aClcclxuICAgICAgICAgICAgb25lSW5wdXRPYmoudHdpbk5hbWU9b25lSW5wdXRPYmoudHdpbk5hbWVfb3JpZ2luPWZpcnN0RWxlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybkFyci5wdXNoKG9uZUlucHV0T2JqKVxyXG4gICAgfSlcclxuICAgIHJldHVybiByZXR1cm5BcnJcclxufVxyXG5cclxuZ2xvYmFsQ2FjaGUucHJvdG90eXBlLnNlYXJjaFZhbHVlPWZ1bmN0aW9uKG9yaWdpbkVsZW1lbnRJbmZvLHBhdGhBcnIpe1xyXG4gICAgaWYocGF0aEFyci5sZW5ndGg9PTApIHJldHVybiBudWxsO1xyXG4gICAgdmFyIHRoZUpzb249b3JpZ2luRWxlbWVudEluZm9cclxuICAgIGZvcih2YXIgaT0wO2k8cGF0aEFyci5sZW5ndGg7aSsrKXtcclxuICAgICAgICB2YXIga2V5PXBhdGhBcnJbaV1cclxuICAgICAgICB0aGVKc29uPXRoZUpzb25ba2V5XVxyXG4gICAgICAgIGlmKHRoZUpzb249PW51bGwpIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoZUpzb24gLy9pdCBzaG91bGQgYmUgdGhlIGZpbmFsIHZhbHVlXHJcbn1cclxuXHJcbmdsb2JhbENhY2hlLnByb3RvdHlwZS5zaGFwZVN2Zz1mdW5jdGlvbihzaGFwZSxjb2xvcixzZWNvbmRDb2xvcil7XHJcbiAgICB2YXIgc3ZnU3RhcnQ9JzxzdmcgeG1sbnM6c3ZnPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgdmlld0JveD1cIjAgMCAxMDAgMTAwXCIgZmlsbD1cIm5vbmVcIiB2ZXJzaW9uPVwiMS4xXCIgPidcclxuICAgIGlmKHNlY29uZENvbG9yKXtcclxuICAgICAgICBpZihjb2xvcj09XCJub25lXCIpIGNvbG9yPVwiZGFya0dyYXlcIiBcclxuICAgICAgICB2YXIgZ3JhZGllbnREZWZpbml0aW9uPSc8ZGVmcz4nK1xyXG4gICAgICAgICAgICAnPGxpbmVhckdyYWRpZW50IGlkPVwiZ3JhZDFcIiB4MT1cIjAlXCIgeTE9XCIwJVwiIHgyPVwiMCVcIiB5Mj1cIjEwMCVcIj4nK1xyXG4gICAgICAgICAgICAnPHN0b3Agb2Zmc2V0PVwiMCVcIiBzdHlsZT1cInN0b3AtY29sb3I6Jytjb2xvcisnO3N0b3Atb3BhY2l0eToxXCIgLz4nK1xyXG4gICAgICAgICAgICAnPHN0b3Agb2Zmc2V0PVwiNTAlXCIgc3R5bGU9XCJzdG9wLWNvbG9yOicrY29sb3IrJztzdG9wLW9wYWNpdHk6MVwiIC8+JytcclxuICAgICAgICAgICAgJzxzdG9wIG9mZnNldD1cIjUxJVwiIHN0eWxlPVwic3RvcC1jb2xvcjonK3NlY29uZENvbG9yKyc7c3RvcC1vcGFjaXR5OjFcIiAvPicrXHJcbiAgICAgICAgICAgICc8L2xpbmVhckdyYWRpZW50PjwvZGVmcz4nXHJcbiAgICAgICAgc3ZnU3RhcnQrPWdyYWRpZW50RGVmaW5pdGlvblxyXG4gICAgfVxyXG4gICAgdmFyIGNvbG9yU3RyPShzZWNvbmRDb2xvcik/XCJ1cmwoI2dyYWQxKVwiOmNvbG9yXHJcbiAgICBpZihzaGFwZT09XCJlbGxpcHNlXCIpe1xyXG4gICAgICAgIHJldHVybiBzdmdTdGFydCsnPGNpcmNsZSBjeD1cIjUwXCIgY3k9XCI1MFwiIHI9XCI1MFwiICBmaWxsPVwiJytjb2xvclN0cisnXCIvPjwvc3ZnPidcclxuICAgIH1lbHNlIGlmKHNoYXBlPT1cImhleGFnb25cIil7XHJcbiAgICAgICAgcmV0dXJuIHN2Z1N0YXJ0Kyc8cG9seWdvbiBwb2ludHM9XCI1MCAwLCA5My4zIDI1LCA5My4zIDc1LCA1MCAxMDAsIDYuNyA3NSwgNi43IDI1XCIgIGZpbGw9XCInK2NvbG9yU3RyKydcIiAvPjwvc3ZnPidcclxuICAgIH1lbHNlIGlmKHNoYXBlPT1cInJlY3RhbmdsZVwiKXtcclxuICAgICAgICByZXR1cm4gc3ZnU3RhcnQrJzxyZWN0IHg9XCIxMFwiIHk9XCIxMFwiIHJ4PVwiMTBcIiByeT1cIjEwXCIgd2lkdGg9XCI4MFwiIGhlaWdodD1cIjgwXCIgZmlsbD1cIicrY29sb3JTdHIrJ1wiIC8+PC9zdmc+J1xyXG4gICAgfVxyXG59XHJcblxyXG5nbG9iYWxDYWNoZS5wcm90b3R5cGUubWFrZURPTURyYWdnYWJsZT1mdW5jdGlvbihkb20saWdub3JlQ2hpbGREb21UeXBlKXtcclxuICAgIGlnbm9yZUNoaWxkRG9tVHlwZT1pZ25vcmVDaGlsZERvbVR5cGV8fFtcIkxBQkVMXCIsXCJURFwiLFwiQlwiLFwiQVwiLFwiSU5QVVRcIixcIlBSRVwiXVxyXG4gICAgZG9tLm9uKCdtb3VzZWRvd24nLChlKT0+e1xyXG4gICAgICAgIGlmKGlnbm9yZUNoaWxkRG9tVHlwZS5pbmRleE9mKGUudGFyZ2V0LnRhZ05hbWUpIT0tMSkgcmV0dXJuO1xyXG4gICAgICAgIHZhciBkb21PZmZzZXQ9ZG9tLm9mZnNldCgpXHJcbiAgICAgICAgZG9tLm1vdXNlU3RhcnREcmFnT2Zmc2V0PVtkb21PZmZzZXQubGVmdC1lLmNsaWVudFgsIGRvbU9mZnNldC50b3AtZS5jbGllbnRZXVxyXG4gICAgICAgICQoJ2JvZHknKS5vbignbW91c2V1cCcsKCk9PntcclxuICAgICAgICAgICAgZG9tLm1vdXNlU3RhcnREcmFnT2Zmc2V0PW51bGxcclxuICAgICAgICAgICAgJCgnYm9keScpLm9mZignbW91c2Vtb3ZlJylcclxuICAgICAgICAgICAgJCgnYm9keScpLm9mZignbW91c2V1cCcpXHJcbiAgICAgICAgfSlcclxuICAgICAgICAkKCdib2R5Jykub24oJ21vdXNlbW92ZScsKGUpPT57XHJcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKVxyXG4gICAgICAgICAgICBpZihkb20ubW91c2VTdGFydERyYWdPZmZzZXQpe1xyXG4gICAgICAgICAgICAgICAgdmFyIG5ld0xlZnQ9IGUuY2xpZW50WCtkb20ubW91c2VTdGFydERyYWdPZmZzZXRbMF1cclxuICAgICAgICAgICAgICAgIHZhciBuZXdUb3A9ZS5jbGllbnRZK2RvbS5tb3VzZVN0YXJ0RHJhZ09mZnNldFsxXVxyXG4gICAgICAgICAgICAgICAgZG9tLmNzcyh7XCJsZWZ0XCI6bmV3TGVmdCtcInB4XCIsXCJ0b3BcIjpuZXdUb3ArXCJweFwiLFwidHJhbnNmb3JtXCI6XCJub25lXCJ9KVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgIH0pXHJcbn1cclxuXHJcbmdsb2JhbENhY2hlLnByb3RvdHlwZS51dWlkdjQ9ZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbiAoYykge1xyXG4gICAgICAgIHZhciByID0gTWF0aC5yYW5kb20oKSAqIDE2IHwgMCwgdiA9IGMgPT0gJ3gnID8gciA6IChyICYgMHgzIHwgMHg4KTtcclxuICAgICAgICByZXR1cm4gdi50b1N0cmluZygxNik7XHJcbiAgICB9KTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBuZXcgZ2xvYmFsQ2FjaGUoKTsiLCJjb25zdCBtc2FsSGVscGVyPXJlcXVpcmUoXCIuLi9tc2FsSGVscGVyXCIpXHJcbi8vVGhpcyBpcyBhIHNpbmdsZXRvbiBjbGFzc1xyXG5cclxuZnVuY3Rpb24gbW9kZWxBbmFseXplcigpe1xyXG4gICAgdGhpcy5EVERMTW9kZWxzPXt9XHJcbiAgICB0aGlzLnJlbGF0aW9uc2hpcFR5cGVzPXt9XHJcbn1cclxuXHJcbm1vZGVsQW5hbHl6ZXIucHJvdG90eXBlLmNsZWFyQWxsTW9kZWxzPWZ1bmN0aW9uKCl7XHJcbiAgICAvL2NvbnNvbGUubG9nKFwiY2xlYXIgYWxsIG1vZGVsIGluZm9cIilcclxuICAgIGZvcih2YXIgaWQgaW4gdGhpcy5EVERMTW9kZWxzKSBkZWxldGUgdGhpcy5EVERMTW9kZWxzW2lkXVxyXG59XHJcblxyXG5tb2RlbEFuYWx5emVyLnByb3RvdHlwZS5yZXNldEFsbE1vZGVscz1mdW5jdGlvbigpe1xyXG4gICAgZm9yKHZhciBtb2RlbElEIGluIHRoaXMuRFRETE1vZGVscyl7XHJcbiAgICAgICAgdmFyIGpzb25TdHI9dGhpcy5EVERMTW9kZWxzW21vZGVsSURdW1wib3JpZ2luYWxcIl1cclxuICAgICAgICB0aGlzLkRURExNb2RlbHNbbW9kZWxJRF09SlNPTi5wYXJzZShqc29uU3RyKVxyXG4gICAgICAgIHRoaXMuRFRETE1vZGVsc1ttb2RlbElEXVtcIm9yaWdpbmFsXCJdPWpzb25TdHJcclxuICAgIH1cclxufVxyXG5cclxuXHJcbm1vZGVsQW5hbHl6ZXIucHJvdG90eXBlLmFkZE1vZGVscz1mdW5jdGlvbihhcnIpe1xyXG4gICAgYXJyLmZvckVhY2goKGVsZSk9PntcclxuICAgICAgICB2YXIgbW9kZWxJRD0gZWxlW1wiQGlkXCJdXHJcbiAgICAgICAgZWxlW1wib3JpZ2luYWxcIl09SlNPTi5zdHJpbmdpZnkoZWxlKVxyXG4gICAgICAgIHRoaXMuRFRETE1vZGVsc1ttb2RlbElEXT1lbGVcclxuICAgIH0pXHJcbn1cclxuXHJcblxyXG5tb2RlbEFuYWx5emVyLnByb3RvdHlwZS5yZWNvcmRBbGxCYXNlQ2xhc3Nlcz0gZnVuY3Rpb24gKHBhcmVudE9iaiwgYmFzZUNsYXNzSUQpIHtcclxuICAgIHZhciBiYXNlQ2xhc3MgPSB0aGlzLkRURExNb2RlbHNbYmFzZUNsYXNzSURdXHJcbiAgICBpZiAoYmFzZUNsYXNzID09IG51bGwpIHJldHVybjtcclxuXHJcbiAgICBwYXJlbnRPYmpbYmFzZUNsYXNzSURdPTFcclxuXHJcbiAgICB2YXIgZnVydGhlckJhc2VDbGFzc0lEcyA9IGJhc2VDbGFzcy5leHRlbmRzO1xyXG4gICAgaWYgKGZ1cnRoZXJCYXNlQ2xhc3NJRHMgPT0gbnVsbCkgcmV0dXJuO1xyXG4gICAgaWYoQXJyYXkuaXNBcnJheShmdXJ0aGVyQmFzZUNsYXNzSURzKSkgdmFyIHRtcEFycj1mdXJ0aGVyQmFzZUNsYXNzSURzXHJcbiAgICBlbHNlIHRtcEFycj1bZnVydGhlckJhc2VDbGFzc0lEc11cclxuICAgIHRtcEFyci5mb3JFYWNoKChlYWNoQmFzZSkgPT4geyB0aGlzLnJlY29yZEFsbEJhc2VDbGFzc2VzKHBhcmVudE9iaiwgZWFjaEJhc2UpIH0pXHJcbn1cclxuXHJcbm1vZGVsQW5hbHl6ZXIucHJvdG90eXBlLmV4cGFuZEVkaXRhYmxlUHJvcGVydGllc0Zyb21CYXNlQ2xhc3MgPSBmdW5jdGlvbiAocGFyZW50T2JqLCBiYXNlQ2xhc3NJRCkge1xyXG4gICAgdmFyIGJhc2VDbGFzcyA9IHRoaXMuRFRETE1vZGVsc1tiYXNlQ2xhc3NJRF1cclxuICAgIGlmIChiYXNlQ2xhc3MgPT0gbnVsbCkgcmV0dXJuO1xyXG4gICAgaWYgKGJhc2VDbGFzcy5lZGl0YWJsZVByb3BlcnRpZXMpIHtcclxuICAgICAgICBmb3IgKHZhciBpbmQgaW4gYmFzZUNsYXNzLmVkaXRhYmxlUHJvcGVydGllcykgcGFyZW50T2JqW2luZF0gPSBiYXNlQ2xhc3MuZWRpdGFibGVQcm9wZXJ0aWVzW2luZF1cclxuICAgIH1cclxuICAgIHZhciBmdXJ0aGVyQmFzZUNsYXNzSURzID0gYmFzZUNsYXNzLmV4dGVuZHM7XHJcbiAgICBpZiAoZnVydGhlckJhc2VDbGFzc0lEcyA9PSBudWxsKSByZXR1cm47XHJcbiAgICBpZihBcnJheS5pc0FycmF5KGZ1cnRoZXJCYXNlQ2xhc3NJRHMpKSB2YXIgdG1wQXJyPWZ1cnRoZXJCYXNlQ2xhc3NJRHNcclxuICAgIGVsc2UgdG1wQXJyPVtmdXJ0aGVyQmFzZUNsYXNzSURzXVxyXG4gICAgdG1wQXJyLmZvckVhY2goKGVhY2hCYXNlKSA9PiB7IHRoaXMuZXhwYW5kRWRpdGFibGVQcm9wZXJ0aWVzRnJvbUJhc2VDbGFzcyhwYXJlbnRPYmosIGVhY2hCYXNlKSB9KVxyXG59XHJcblxyXG5tb2RlbEFuYWx5emVyLnByb3RvdHlwZS5leHBhbmRWYWxpZFJlbGF0aW9uc2hpcFR5cGVzRnJvbUJhc2VDbGFzcyA9IGZ1bmN0aW9uIChwYXJlbnRPYmosIGJhc2VDbGFzc0lEKSB7XHJcbiAgICB2YXIgYmFzZUNsYXNzID0gdGhpcy5EVERMTW9kZWxzW2Jhc2VDbGFzc0lEXVxyXG4gICAgaWYgKGJhc2VDbGFzcyA9PSBudWxsKSByZXR1cm47XHJcbiAgICBpZiAoYmFzZUNsYXNzLnZhbGlkUmVsYXRpb25zaGlwcykge1xyXG4gICAgICAgIGZvciAodmFyIGluZCBpbiBiYXNlQ2xhc3MudmFsaWRSZWxhdGlvbnNoaXBzKSB7XHJcbiAgICAgICAgICAgIGlmKHBhcmVudE9ialtpbmRdPT1udWxsKSBwYXJlbnRPYmpbaW5kXSA9IHRoaXMucmVsYXRpb25zaGlwVHlwZXNbaW5kXVtiYXNlQ2xhc3NJRF1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB2YXIgZnVydGhlckJhc2VDbGFzc0lEcyA9IGJhc2VDbGFzcy5leHRlbmRzO1xyXG4gICAgaWYgKGZ1cnRoZXJCYXNlQ2xhc3NJRHMgPT0gbnVsbCkgcmV0dXJuO1xyXG4gICAgaWYoQXJyYXkuaXNBcnJheShmdXJ0aGVyQmFzZUNsYXNzSURzKSkgdmFyIHRtcEFycj1mdXJ0aGVyQmFzZUNsYXNzSURzXHJcbiAgICBlbHNlIHRtcEFycj1bZnVydGhlckJhc2VDbGFzc0lEc11cclxuICAgIHRtcEFyci5mb3JFYWNoKChlYWNoQmFzZSkgPT4geyB0aGlzLmV4cGFuZFZhbGlkUmVsYXRpb25zaGlwVHlwZXNGcm9tQmFzZUNsYXNzKHBhcmVudE9iaiwgZWFjaEJhc2UpIH0pXHJcbn1cclxuXHJcbm1vZGVsQW5hbHl6ZXIucHJvdG90eXBlLmV4cGFuZEVkaXRhYmxlUHJvcGVydGllcz1mdW5jdGlvbihwYXJlbnRPYmosZGF0YUluZm8sZW1iZWRkZWRTY2hlbWEpe1xyXG4gICAgZGF0YUluZm8uZm9yRWFjaCgob25lQ29udGVudCk9PntcclxuICAgICAgICBpZihvbmVDb250ZW50W1wiQHR5cGVcIl09PVwiUmVsYXRpb25zaGlwXCIpIHJldHVybjtcclxuICAgICAgICBpZihvbmVDb250ZW50W1wiQHR5cGVcIl09PVwiUHJvcGVydHlcIlxyXG4gICAgICAgIHx8KEFycmF5LmlzQXJyYXkob25lQ29udGVudFtcIkB0eXBlXCJdKSAmJiBvbmVDb250ZW50W1wiQHR5cGVcIl0uaW5jbHVkZXMoXCJQcm9wZXJ0eVwiKSlcclxuICAgICAgICB8fCBvbmVDb250ZW50W1wiQHR5cGVcIl09PW51bGwpIHtcclxuICAgICAgICAgICAgaWYodHlwZW9mKG9uZUNvbnRlbnRbXCJzY2hlbWFcIl0pICE9ICdvYmplY3QnICYmIGVtYmVkZGVkU2NoZW1hW29uZUNvbnRlbnRbXCJzY2hlbWFcIl1dIT1udWxsKSBvbmVDb250ZW50W1wic2NoZW1hXCJdPWVtYmVkZGVkU2NoZW1hW29uZUNvbnRlbnRbXCJzY2hlbWFcIl1dXHJcblxyXG4gICAgICAgICAgICBpZih0eXBlb2Yob25lQ29udGVudFtcInNjaGVtYVwiXSkgPT09ICdvYmplY3QnICYmIG9uZUNvbnRlbnRbXCJzY2hlbWFcIl1bXCJAdHlwZVwiXT09XCJPYmplY3RcIil7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV3UGFyZW50PXt9XHJcbiAgICAgICAgICAgICAgICBwYXJlbnRPYmpbb25lQ29udGVudFtcIm5hbWVcIl1dPW5ld1BhcmVudFxyXG4gICAgICAgICAgICAgICAgdGhpcy5leHBhbmRFZGl0YWJsZVByb3BlcnRpZXMobmV3UGFyZW50LG9uZUNvbnRlbnRbXCJzY2hlbWFcIl1bXCJmaWVsZHNcIl0sZW1iZWRkZWRTY2hlbWEpXHJcbiAgICAgICAgICAgIH1lbHNlIGlmKHR5cGVvZihvbmVDb250ZW50W1wic2NoZW1hXCJdKSA9PT0gJ29iamVjdCcgJiYgb25lQ29udGVudFtcInNjaGVtYVwiXVtcIkB0eXBlXCJdPT1cIkVudW1cIil7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnRPYmpbb25lQ29udGVudFtcIm5hbWVcIl1dPW9uZUNvbnRlbnRbXCJzY2hlbWFcIl1bXCJlbnVtVmFsdWVzXCJdXHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgcGFyZW50T2JqW29uZUNvbnRlbnRbXCJuYW1lXCJdXT1vbmVDb250ZW50W1wic2NoZW1hXCJdXHJcbiAgICAgICAgICAgIH0gICAgICAgICAgIFxyXG4gICAgICAgIH1cclxuICAgIH0pXHJcbn1cclxuXHJcblxyXG5tb2RlbEFuYWx5emVyLnByb3RvdHlwZS5hbmFseXplPWZ1bmN0aW9uKCl7XHJcbiAgICAvL2NvbnNvbGUubG9nKFwiYW5hbHl6ZSBtb2RlbCBpbmZvXCIpXHJcbiAgICAvL2FuYWx5emUgYWxsIHJlbGF0aW9uc2hpcCB0eXBlc1xyXG4gICAgZm9yICh2YXIgaWQgaW4gdGhpcy5yZWxhdGlvbnNoaXBUeXBlcykgZGVsZXRlIHRoaXMucmVsYXRpb25zaGlwVHlwZXNbaWRdXHJcbiAgICBmb3IgKHZhciBtb2RlbElEIGluIHRoaXMuRFRETE1vZGVscykge1xyXG4gICAgICAgIHZhciBlbGUgPSB0aGlzLkRURExNb2RlbHNbbW9kZWxJRF1cclxuICAgICAgICB2YXIgZW1iZWRkZWRTY2hlbWEgPSB7fVxyXG4gICAgICAgIGlmIChlbGUuc2NoZW1hcykge1xyXG4gICAgICAgICAgICB2YXIgdGVtcEFycjtcclxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZWxlLnNjaGVtYXMpKSB0ZW1wQXJyID0gZWxlLnNjaGVtYXNcclxuICAgICAgICAgICAgZWxzZSB0ZW1wQXJyID0gW2VsZS5zY2hlbWFzXVxyXG4gICAgICAgICAgICB0ZW1wQXJyLmZvckVhY2goKGVsZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgZW1iZWRkZWRTY2hlbWFbZWxlW1wiQGlkXCJdXSA9IGVsZVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGNvbnRlbnRBcnIgPSBlbGUuY29udGVudHNcclxuICAgICAgICBpZiAoIWNvbnRlbnRBcnIpIGNvbnRpbnVlO1xyXG4gICAgICAgIGNvbnRlbnRBcnIuZm9yRWFjaCgob25lQ29udGVudCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAob25lQ29udGVudFtcIkB0eXBlXCJdID09IFwiUmVsYXRpb25zaGlwXCIpIHtcclxuICAgICAgICAgICAgICAgIGlmKCF0aGlzLnJlbGF0aW9uc2hpcFR5cGVzW29uZUNvbnRlbnRbXCJuYW1lXCJdXSkgdGhpcy5yZWxhdGlvbnNoaXBUeXBlc1tvbmVDb250ZW50W1wibmFtZVwiXV09IHt9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbGF0aW9uc2hpcFR5cGVzW29uZUNvbnRlbnRbXCJuYW1lXCJdXVttb2RlbElEXSA9IG9uZUNvbnRlbnRcclxuICAgICAgICAgICAgICAgIG9uZUNvbnRlbnQuZWRpdGFibGVSZWxhdGlvbnNoaXBQcm9wZXJ0aWVzID0ge31cclxuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9uZUNvbnRlbnQucHJvcGVydGllcykpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cGFuZEVkaXRhYmxlUHJvcGVydGllcyhvbmVDb250ZW50LmVkaXRhYmxlUmVsYXRpb25zaGlwUHJvcGVydGllcywgb25lQ29udGVudC5wcm9wZXJ0aWVzLCBlbWJlZGRlZFNjaGVtYSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgLy9hbmFseXplIGVhY2ggbW9kZWwncyBwcm9wZXJ0eSB0aGF0IGNhbiBiZSBlZGl0ZWRcclxuICAgIGZvcih2YXIgbW9kZWxJRCBpbiB0aGlzLkRURExNb2RlbHMpeyAvL2V4cGFuZCBwb3NzaWJsZSBlbWJlZGRlZCBzY2hlbWEgdG8gZWRpdGFibGVQcm9wZXJ0aWVzLCBhbHNvIGV4dHJhY3QgcG9zc2libGUgcmVsYXRpb25zaGlwIHR5cGVzIGZvciB0aGlzIG1vZGVsXHJcbiAgICAgICAgdmFyIGVsZT10aGlzLkRURExNb2RlbHNbbW9kZWxJRF1cclxuICAgICAgICB2YXIgZW1iZWRkZWRTY2hlbWE9e31cclxuICAgICAgICBpZihlbGUuc2NoZW1hcyl7XHJcbiAgICAgICAgICAgIHZhciB0ZW1wQXJyO1xyXG4gICAgICAgICAgICBpZihBcnJheS5pc0FycmF5KGVsZS5zY2hlbWFzKSkgdGVtcEFycj1lbGUuc2NoZW1hc1xyXG4gICAgICAgICAgICBlbHNlIHRlbXBBcnI9W2VsZS5zY2hlbWFzXVxyXG4gICAgICAgICAgICB0ZW1wQXJyLmZvckVhY2goKGVsZSk9PntcclxuICAgICAgICAgICAgICAgIGVtYmVkZGVkU2NoZW1hW2VsZVtcIkBpZFwiXV09ZWxlXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsZS5lZGl0YWJsZVByb3BlcnRpZXM9e31cclxuICAgICAgICBlbGUudmFsaWRSZWxhdGlvbnNoaXBzPXt9XHJcbiAgICAgICAgZWxlLmluY2x1ZGVkQ29tcG9uZW50cz1bXVxyXG4gICAgICAgIGVsZS5hbGxCYXNlQ2xhc3Nlcz17fVxyXG4gICAgICAgIGlmKEFycmF5LmlzQXJyYXkoZWxlLmNvbnRlbnRzKSl7XHJcbiAgICAgICAgICAgIHRoaXMuZXhwYW5kRWRpdGFibGVQcm9wZXJ0aWVzKGVsZS5lZGl0YWJsZVByb3BlcnRpZXMsZWxlLmNvbnRlbnRzLGVtYmVkZGVkU2NoZW1hKVxyXG5cclxuICAgICAgICAgICAgZWxlLmNvbnRlbnRzLmZvckVhY2goKG9uZUNvbnRlbnQpPT57XHJcbiAgICAgICAgICAgICAgICBpZihvbmVDb250ZW50W1wiQHR5cGVcIl09PVwiUmVsYXRpb25zaGlwXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbGUudmFsaWRSZWxhdGlvbnNoaXBzW29uZUNvbnRlbnRbXCJuYW1lXCJdXT10aGlzLnJlbGF0aW9uc2hpcFR5cGVzW29uZUNvbnRlbnRbXCJuYW1lXCJdXVttb2RlbElEXVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmb3IodmFyIG1vZGVsSUQgaW4gdGhpcy5EVERMTW9kZWxzKXsvL2V4cGFuZCBjb21wb25lbnQgcHJvcGVydGllc1xyXG4gICAgICAgIHZhciBlbGU9dGhpcy5EVERMTW9kZWxzW21vZGVsSURdXHJcbiAgICAgICAgaWYoQXJyYXkuaXNBcnJheShlbGUuY29udGVudHMpKXtcclxuICAgICAgICAgICAgZWxlLmNvbnRlbnRzLmZvckVhY2gob25lQ29udGVudD0+e1xyXG4gICAgICAgICAgICAgICAgaWYob25lQ29udGVudFtcIkB0eXBlXCJdPT1cIkNvbXBvbmVudFwiKXtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29tcG9uZW50TmFtZT1vbmVDb250ZW50W1wibmFtZVwiXVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb21wb25lbnRDbGFzcz1vbmVDb250ZW50W1wic2NoZW1hXCJdXHJcbiAgICAgICAgICAgICAgICAgICAgZWxlLmVkaXRhYmxlUHJvcGVydGllc1tjb21wb25lbnROYW1lXT17fVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwYW5kRWRpdGFibGVQcm9wZXJ0aWVzRnJvbUJhc2VDbGFzcyhlbGUuZWRpdGFibGVQcm9wZXJ0aWVzW2NvbXBvbmVudE5hbWVdLGNvbXBvbmVudENsYXNzKVxyXG4gICAgICAgICAgICAgICAgICAgIGVsZS5pbmNsdWRlZENvbXBvbmVudHMucHVzaChjb21wb25lbnROYW1lKVxyXG4gICAgICAgICAgICAgICAgfSBcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZm9yKHZhciBtb2RlbElEIGluIHRoaXMuRFRETE1vZGVscyl7Ly9leHBhbmQgYmFzZSBjbGFzcyBwcm9wZXJ0aWVzIHRvIGVkaXRhYmxlUHJvcGVydGllcyBhbmQgdmFsaWQgcmVsYXRpb25zaGlwIHR5cGVzIHRvIHZhbGlkUmVsYXRpb25zaGlwc1xyXG4gICAgICAgIHZhciBlbGU9dGhpcy5EVERMTW9kZWxzW21vZGVsSURdXHJcbiAgICAgICAgdmFyIGJhc2VDbGFzc0lEcz1lbGUuZXh0ZW5kcztcclxuICAgICAgICBpZihiYXNlQ2xhc3NJRHM9PW51bGwpIGNvbnRpbnVlO1xyXG4gICAgICAgIGlmKEFycmF5LmlzQXJyYXkoYmFzZUNsYXNzSURzKSkgdmFyIHRtcEFycj1iYXNlQ2xhc3NJRHNcclxuICAgICAgICBlbHNlIHRtcEFycj1bYmFzZUNsYXNzSURzXVxyXG4gICAgICAgIHRtcEFyci5mb3JFYWNoKChlYWNoQmFzZSk9PntcclxuICAgICAgICAgICAgdGhpcy5yZWNvcmRBbGxCYXNlQ2xhc3NlcyhlbGUuYWxsQmFzZUNsYXNzZXMsZWFjaEJhc2UpXHJcbiAgICAgICAgICAgIHRoaXMuZXhwYW5kRWRpdGFibGVQcm9wZXJ0aWVzRnJvbUJhc2VDbGFzcyhlbGUuZWRpdGFibGVQcm9wZXJ0aWVzLGVhY2hCYXNlKVxyXG4gICAgICAgICAgICB0aGlzLmV4cGFuZFZhbGlkUmVsYXRpb25zaGlwVHlwZXNGcm9tQmFzZUNsYXNzKGVsZS52YWxpZFJlbGF0aW9uc2hpcHMsZWFjaEJhc2UpXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICAvL2NvbnNvbGUubG9nKHRoaXMuRFRETE1vZGVscylcclxuICAgIC8vY29uc29sZS5sb2codGhpcy5yZWxhdGlvbnNoaXBUeXBlcylcclxufVxyXG5cclxubW9kZWxBbmFseXplci5wcm90b3R5cGUubGlzdE1vZGVsc0ZvckRlbGV0ZU1vZGVsPWZ1bmN0aW9uKG1vZGVsSUQpe1xyXG4gICAgdmFyIGNoaWxkTW9kZWxJRHM9W11cclxuICAgIGZvcih2YXIgYUlEIGluIHRoaXMuRFRETE1vZGVscyl7XHJcbiAgICAgICAgdmFyIGFNb2RlbD10aGlzLkRURExNb2RlbHNbYUlEXVxyXG4gICAgICAgIGlmKGFNb2RlbC5hbGxCYXNlQ2xhc3NlcyAmJiBhTW9kZWwuYWxsQmFzZUNsYXNzZXNbbW9kZWxJRF0pIGNoaWxkTW9kZWxJRHMucHVzaChhTW9kZWxbXCJAaWRcIl0pXHJcbiAgICB9XHJcbiAgICByZXR1cm4gY2hpbGRNb2RlbElEc1xyXG59XHJcblxyXG5tb2RlbEFuYWx5emVyLnByb3RvdHlwZS5kZWxldGVNb2RlbD1hc3luYyBmdW5jdGlvbihtb2RlbElELGZ1bmNBZnRlckVhY2hTdWNjZXNzRGVsZXRlLGZ1bmNBZnRlckZhaWwsY29tcGxldGVGdW5jKXtcclxuICAgIHZhciByZWxhdGVkTW9kZWxJRHM9dGhpcy5saXN0TW9kZWxzRm9yRGVsZXRlTW9kZWwobW9kZWxJRClcclxuICAgIHZhciBtb2RlbExldmVsPVtdXHJcbiAgICByZWxhdGVkTW9kZWxJRHMuZm9yRWFjaChvbmVJRD0+e1xyXG4gICAgICAgIHZhciBjaGVja01vZGVsPXRoaXMuRFRETE1vZGVsc1tvbmVJRF1cclxuICAgICAgICBtb2RlbExldmVsLnB1c2goe1wibW9kZWxJRFwiOm9uZUlELFwibGV2ZWxcIjpPYmplY3Qua2V5cyhjaGVja01vZGVsLmFsbEJhc2VDbGFzc2VzKS5sZW5ndGh9KVxyXG4gICAgfSlcclxuICAgIG1vZGVsTGV2ZWwucHVzaCh7XCJtb2RlbElEXCI6bW9kZWxJRCxcImxldmVsXCI6MH0pXHJcbiAgICBtb2RlbExldmVsLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtyZXR1cm4gYltcImxldmVsXCJdLWFbXCJsZXZlbFwiXSB9KTtcclxuICAgIFxyXG4gICAgZm9yKHZhciBpPTA7aTxtb2RlbExldmVsLmxlbmd0aDtpKyspe1xyXG4gICAgICAgIHZhciBhTW9kZWxJRD1tb2RlbExldmVsW2ldLm1vZGVsSURcclxuICAgICAgICB0cnl7XHJcbiAgICAgICAgICAgIGF3YWl0IG1zYWxIZWxwZXIuY2FsbEFQSShcImRpZ2l0YWx0d2luL2RlbGV0ZU1vZGVsXCIsIFwiUE9TVFwiLCB7IFwibW9kZWxcIjogYU1vZGVsSUQgfSxcIndpdGhQcm9qZWN0SURcIilcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuRFRETE1vZGVsc1thTW9kZWxJRF1cclxuICAgICAgICAgICAgaWYoZnVuY0FmdGVyRWFjaFN1Y2Nlc3NEZWxldGUpIGZ1bmNBZnRlckVhY2hTdWNjZXNzRGVsZXRlKGFNb2RlbElEKVxyXG4gICAgICAgIH1jYXRjaChlKXtcclxuICAgICAgICAgICAgdmFyIGRlbGV0ZWRNb2RlbHM9W11cclxuICAgICAgICAgICAgdmFyIGFsZXJ0U3RyPVwiRGVsZXRlIG1vZGVsIGlzIGluY29tcGxldGUuIERlbGV0ZWQgTW9kZWw6XCJcclxuICAgICAgICAgICAgZm9yKHZhciBqPTA7ajxpO2orKyl7XHJcbiAgICAgICAgICAgICAgICBhbGVydFN0cis9IG1vZGVsTGV2ZWxbal0ubW9kZWxJRCtcIiBcIlxyXG4gICAgICAgICAgICAgICAgZGVsZXRlZE1vZGVscy5wdXNoKG1vZGVsTGV2ZWxbal0ubW9kZWxJRClcclxuICAgICAgICAgICAgfSBcclxuICAgICAgICAgICAgYWxlcnRTdHIrPVwiLiBGYWlsIHRvIGRlbGV0ZSBcIithTW9kZWxJRCtcIi4gRXJyb3IgaXMgXCIrZVxyXG4gICAgICAgICAgICBpZihmdW5jQWZ0ZXJGYWlsKSBmdW5jQWZ0ZXJGYWlsKGRlbGV0ZWRNb2RlbHMpXHJcbiAgICAgICAgICAgIGFsZXJ0KGUpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYoY29tcGxldGVGdW5jKSBjb21wbGV0ZUZ1bmMoKVxyXG59XHJcblxyXG5cclxubW9kZWxBbmFseXplci5wcm90b3R5cGUuZmV0Y2hQcm9wZXJ0eVBhdGhzT2ZNb2RlbD1mdW5jdGlvbihtb2RlbElEKXtcclxuICAgIHZhciBwcm9wZXJ0aWVzPXRoaXMuRFRETE1vZGVsc1ttb2RlbElEXS5lZGl0YWJsZVByb3BlcnRpZXNcclxuICAgIHZhciBwcm9wZXJ0eVBhdGhzPVtdXHJcbiAgICB0aGlzLmFuYWx5emVQcm9wZXJ0eVBhdGgocHJvcGVydGllcyxbXSxwcm9wZXJ0eVBhdGhzKVxyXG4gICAgcmV0dXJuIHByb3BlcnR5UGF0aHNcclxufVxyXG5cclxubW9kZWxBbmFseXplci5wcm90b3R5cGUuYW5hbHl6ZVByb3BlcnR5UGF0aD1mdW5jdGlvbiAoanNvbkluZm8scGF0aEFycixwcm9wZXJ0eVBhdGhzKXtcclxuICAgIGZvcih2YXIgaW5kIGluIGpzb25JbmZvKXtcclxuICAgICAgICB2YXIgbmV3UGF0aD1wYXRoQXJyLmNvbmNhdChbaW5kXSlcclxuICAgICAgICBpZighQXJyYXkuaXNBcnJheShqc29uSW5mb1tpbmRdKSAmJiB0eXBlb2YoanNvbkluZm9baW5kXSk9PT1cIm9iamVjdFwiKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYW5hbHl6ZVByb3BlcnR5UGF0aChqc29uSW5mb1tpbmRdLG5ld1BhdGgscHJvcGVydHlQYXRocylcclxuICAgICAgICB9ZWxzZSB7XHJcbiAgICAgICAgICAgIHByb3BlcnR5UGF0aHMucHVzaChuZXdQYXRoKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBuZXcgbW9kZWxBbmFseXplcigpOyIsImNvbnN0IG1vZGVsQW5hbHl6ZXI9cmVxdWlyZShcIi4vbW9kZWxBbmFseXplclwiKVxyXG5jb25zdCBzaW1wbGVTZWxlY3RNZW51PSByZXF1aXJlKFwiLi9zaW1wbGVTZWxlY3RNZW51XCIpXHJcbmNvbnN0IG1zYWxIZWxwZXI9cmVxdWlyZShcIi4uL21zYWxIZWxwZXJcIilcclxuY29uc3Qgc2ltcGxlQ29uZmlybURpYWxvZz1yZXF1aXJlKFwiLi9zaW1wbGVDb25maXJtRGlhbG9nXCIpXHJcbmNvbnN0IGdsb2JhbENhY2hlPXJlcXVpcmUoXCIuL2dsb2JhbENhY2hlXCIpXHJcblxyXG5mdW5jdGlvbiBtb2RlbEVkaXRvckRpYWxvZygpIHtcclxuICAgIGlmKCF0aGlzLkRPTSl7XHJcbiAgICAgICAgdGhpcy5ET00gPSAkKCc8ZGl2IHN0eWxlPVwicG9zaXRpb246YWJzb2x1dGU7dG9wOjUwJTtiYWNrZ3JvdW5kLWNvbG9yOndoaXRlO2xlZnQ6NTAlO3RyYW5zZm9ybTogdHJhbnNsYXRlWCgtNTAlKSB0cmFuc2xhdGVZKC01MCUpO3otaW5kZXg6MTAwXCIgY2xhc3M9XCJ3My1jYXJkLTJcIj48L2Rpdj4nKVxyXG4gICAgICAgICQoXCJib2R5XCIpLmFwcGVuZCh0aGlzLkRPTSlcclxuICAgICAgICB0aGlzLkRPTS5oaWRlKClcclxuICAgICAgICBnbG9iYWxDYWNoZS5tYWtlRE9NRHJhZ2dhYmxlKHRoaXMuRE9NKVxyXG4gICAgfVxyXG59XHJcblxyXG5tb2RlbEVkaXRvckRpYWxvZy5wcm90b3R5cGUucG9wdXAgPSBhc3luYyBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuRE9NLnNob3coKVxyXG4gICAgdGhpcy5ET00uZW1wdHkoKVxyXG4gICAgdGhpcy5jb250ZW50RE9NID0gJCgnPGRpdiBzdHlsZT1cIndpZHRoOjY2NXB4XCI+PC9kaXY+JylcclxuICAgIHRoaXMuRE9NLmFwcGVuZCh0aGlzLmNvbnRlbnRET00pXHJcbiAgICB0aGlzLmNvbnRlbnRET00uYXBwZW5kKCQoJzxkaXYgc3R5bGU9XCJoZWlnaHQ6NDBweFwiIGNsYXNzPVwidzMtYmFyIHczLXJlZFwiPjxkaXYgY2xhc3M9XCJ3My1iYXItaXRlbVwiIHN0eWxlPVwiZm9udC1zaXplOjEuNWVtXCI+RGlnaXRhbCBUd2luIE1vZGVsIEVkaXRvcjwvZGl2PjwvZGl2PicpKVxyXG4gICAgdmFyIGNsb3NlQnV0dG9uID0gJCgnPGJ1dHRvbiBjbGFzcz1cInczLWJhci1pdGVtIHczLWJ1dHRvbiB3My1yaWdodFwiIHN0eWxlPVwiZm9udC1zaXplOjJlbTtwYWRkaW5nLXRvcDo0cHhcIj7DlzwvYnV0dG9uPicpXHJcbiAgICB0aGlzLmNvbnRlbnRET00uY2hpbGRyZW4oJzpmaXJzdCcpLmFwcGVuZChjbG9zZUJ1dHRvbilcclxuICAgIGNsb3NlQnV0dG9uLm9uKFwiY2xpY2tcIiwgKCkgPT4geyB0aGlzLkRPTS5oaWRlKCkgfSlcclxuXHJcbiAgICB2YXIgYnV0dG9uUm93PSQoJzxkaXYgIHN0eWxlPVwiaGVpZ2h0OjQwcHhcIiBjbGFzcz1cInczLWJhclwiPjwvZGl2PicpXHJcbiAgICB0aGlzLmNvbnRlbnRET00uYXBwZW5kKGJ1dHRvblJvdylcclxuICAgIHZhciBpbXBvcnRCdXR0b24gPSQoJzxidXR0b24gY2xhc3M9XCJ3My1idXR0b24gdzMtY2FyZCB3My1kZWVwLW9yYW5nZSB3My1ob3Zlci1saWdodC1ncmVlbiB3My1yaWdodFwiIHN0eWxlPVwiaGVpZ2h0OjEwMCVcIj5JbXBvcnQ8L2J1dHRvbj4nKVxyXG4gICAgdGhpcy5pbXBvcnRCdXR0b249aW1wb3J0QnV0dG9uXHJcbiAgICBidXR0b25Sb3cuYXBwZW5kKGltcG9ydEJ1dHRvbilcclxuXHJcbiAgICBpbXBvcnRCdXR0b24ub24oXCJjbGlja1wiLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgdmFyIGN1cnJlbnRNb2RlbElEPXRoaXMuZHRkbG9ialtcIkBpZFwiXVxyXG4gICAgICAgIGlmKG1vZGVsQW5hbHl6ZXIuRFRETE1vZGVsc1tjdXJyZW50TW9kZWxJRF09PW51bGwpIHRoaXMuaW1wb3J0TW9kZWxBcnIoW3RoaXMuZHRkbG9ial0pXHJcbiAgICAgICAgZWxzZSB0aGlzLnJlcGxhY2VNb2RlbCgpICAgICAgIFxyXG4gICAgfSlcclxuXHJcbiAgICB2YXIgbGFibGU9JCgnPGRpdiBjbGFzcz1cInczLWJhci1pdGVtIHczLW9wYWNpdHlcIiBzdHlsZT1cInBhZGRpbmctcmlnaHQ6NXB4O2ZvbnQtc2l6ZToxLjJlbTtcIj5Nb2RlbCBUZW1wbGF0ZTwvZGl2PicpXHJcbiAgICBidXR0b25Sb3cuYXBwZW5kKGxhYmxlKVxyXG4gICAgdmFyIG1vZGVsVGVtcGxhdGVTZWxlY3Rvcj1uZXcgc2ltcGxlU2VsZWN0TWVudShcIiBcIix7d2l0aEJvcmRlcjoxLGZvbnRTaXplOlwiMS4yZW1cIixjb2xvckNsYXNzOlwidzMtbGlnaHQtZ3JheVwiLGJ1dHRvbkNTUzp7XCJwYWRkaW5nXCI6XCI1cHggMTBweFwifSxcIm9wdGlvbkxpc3RIZWlnaHRcIjozMDB9KVxyXG4gICAgYnV0dG9uUm93LmFwcGVuZChtb2RlbFRlbXBsYXRlU2VsZWN0b3IuRE9NKVxyXG4gICAgbW9kZWxUZW1wbGF0ZVNlbGVjdG9yLmNhbGxCYWNrX2NsaWNrT3B0aW9uPShvcHRpb25UZXh0LG9wdGlvblZhbHVlKT0+e1xyXG4gICAgICAgIG1vZGVsVGVtcGxhdGVTZWxlY3Rvci5jaGFuZ2VOYW1lKG9wdGlvblRleHQpXHJcbiAgICAgICAgdGhpcy5jaG9vc2VUZW1wbGF0ZShvcHRpb25WYWx1ZSlcclxuICAgIH1cclxuICAgIG1vZGVsVGVtcGxhdGVTZWxlY3Rvci5hZGRPcHRpb24oXCJOZXcgTW9kZWwuLi5cIixcIk5ld1wiKVxyXG4gICAgZm9yKHZhciBtb2RlbE5hbWUgaW4gbW9kZWxBbmFseXplci5EVERMTW9kZWxzKXtcclxuICAgICAgICBtb2RlbFRlbXBsYXRlU2VsZWN0b3IuYWRkT3B0aW9uKG1vZGVsTmFtZSlcclxuICAgIH1cclxuXHJcbiAgICB2YXIgcGFuZWxIZWlnaHQ9XCI0NTBweFwiXHJcbiAgICB2YXIgcm93Mj0kKCc8ZGl2IGNsYXNzPVwidzMtY2VsbC1yb3dcIiBzdHlsZT1cIm1hcmdpbjoycHhcIj48L2Rpdj4nKVxyXG4gICAgdGhpcy5jb250ZW50RE9NLmFwcGVuZChyb3cyKVxyXG4gICAgdmFyIGxlZnRTcGFuPSQoJzxkaXYgY2xhc3M9XCJ3My1jYXJkXCIgc3R5bGU9XCJwYWRkaW5nOjVweDt3aWR0aDozMzBweDtwYWRkaW5nLXJpZ2h0OjVweDtoZWlnaHQ6JytwYW5lbEhlaWdodCsnO292ZXJmbG93OmF1dG9cIj48L2Rpdj4nKVxyXG4gICAgcm93Mi5hcHBlbmQobGVmdFNwYW4pXHJcbiAgICB0aGlzLmxlZnRTcGFuPWxlZnRTcGFuXHJcblxyXG4gICAgdmFyIHJpZ2h0U3Bhbj0kKCc8ZGl2IGNsYXNzPVwidzMtY29udGFpbmVyIHczLWNlbGxcIj48L2Rpdj4nKVxyXG4gICAgcm93Mi5hcHBlbmQocmlnaHRTcGFuKSBcclxuICAgIHZhciBkdGRsU2NyaXB0UGFuZWw9JCgnPGRpdiBjbGFzcz1cInczLWNhcmQtMiB3My13aGl0ZVwiIHN0eWxlPVwib3ZlcmZsb3c6YXV0bzttYXJnaW4tdG9wOjJweDt3aWR0aDozMTBweDtoZWlnaHQ6JytwYW5lbEhlaWdodCsnXCI+PC9kaXY+JylcclxuICAgIHJpZ2h0U3Bhbi5hcHBlbmQoZHRkbFNjcmlwdFBhbmVsKVxyXG4gICAgdGhpcy5kdGRsU2NyaXB0UGFuZWw9ZHRkbFNjcmlwdFBhbmVsXHJcblxyXG4gICAgbW9kZWxUZW1wbGF0ZVNlbGVjdG9yLnRyaWdnZXJPcHRpb25JbmRleCgwKVxyXG59XHJcblxyXG5tb2RlbEVkaXRvckRpYWxvZy5wcm90b3R5cGUucmVwbGFjZU1vZGVsPWZ1bmN0aW9uKCl7XHJcbiAgICAvL2RlbGV0ZSB0aGUgb2xkIHNhbWUgbmFtZSBtb2RlbCwgdGhlbiBjcmVhdGUgaXQgYWdhaW5cclxuICAgIHZhciBjdXJyZW50TW9kZWxJRD10aGlzLmR0ZGxvYmpbXCJAaWRcIl1cclxuXHJcbiAgICB2YXIgcmVsYXRlZE1vZGVsSURzPW1vZGVsQW5hbHl6ZXIubGlzdE1vZGVsc0ZvckRlbGV0ZU1vZGVsKGN1cnJlbnRNb2RlbElEKVxyXG5cclxuICAgIHZhciBkaWFsb2dTdHIgPSAocmVsYXRlZE1vZGVsSURzLmxlbmd0aCA9PSAwKSA/IChcIlR3aW5zIHdpbGwgYmUgaW1wYWN0IHVuZGVyIG1vZGVsIFxcXCJcIiArIGN1cnJlbnRNb2RlbElEICsgXCJcXFwiXCIpIDpcclxuICAgICAgICAoY3VycmVudE1vZGVsSUQgKyBcIiBpcyBiYXNlIG1vZGVsIG9mIFwiICsgcmVsYXRlZE1vZGVsSURzLmpvaW4oXCIsIFwiKSArIFwiLiBUd2lucyB1bmRlciB0aGVzZSBtb2RlbHMgd2lsbCBiZSBpbXBhY3QuXCIpXHJcbiAgICB2YXIgY29uZmlybURpYWxvZ0RpdiA9IG5ldyBzaW1wbGVDb25maXJtRGlhbG9nKClcclxuICAgIGNvbmZpcm1EaWFsb2dEaXYuc2hvdyhcclxuICAgICAgICB7IHdpZHRoOiBcIjM1MHB4XCIgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRpdGxlOiBcIldhcm5pbmdcIlxyXG4gICAgICAgICAgICAsIGNvbnRlbnQ6IGRpYWxvZ1N0clxyXG4gICAgICAgICAgICAsIGJ1dHRvbnM6IFtcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBjb2xvckNsYXNzOiBcInczLXJlZCB3My1ob3Zlci1waW5rXCIsIHRleHQ6IFwiQ29uZmlybVwiLCBcImNsaWNrRnVuY1wiOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpcm1EaWFsb2dEaXYuY2xvc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25maXJtUmVwbGFjZU1vZGVsKGN1cnJlbnRNb2RlbElEKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sb3JDbGFzczogXCJ3My1ncmF5XCIsIHRleHQ6IFwiQ2FuY2VsXCIsIFwiY2xpY2tGdW5jXCI6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlybURpYWxvZ0Rpdi5jbG9zZSgpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfVxyXG4gICAgKSAgICBcclxufVxyXG5cclxubW9kZWxFZGl0b3JEaWFsb2cucHJvdG90eXBlLmltcG9ydE1vZGVsQXJyPWFzeW5jIGZ1bmN0aW9uKG1vZGVsVG9CZUltcG9ydGVkLGZvclJlcGxhY2luZyxhZnRlckZhaWx1cmUpe1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBhd2FpdCBtc2FsSGVscGVyLmNhbGxBUEkoXCJkaWdpdGFsdHdpbi9pbXBvcnRNb2RlbHNcIiwgXCJQT1NUXCIsIHsgXCJtb2RlbHNcIjogSlNPTi5zdHJpbmdpZnkobW9kZWxUb0JlSW1wb3J0ZWQpIH0sXCJ3aXRoUHJvamVjdElEXCIpXHJcbiAgICAgICAgaWYoZm9yUmVwbGFjaW5nKSBhbGVydChcIk1vZGVsIFwiICsgdGhpcy5kdGRsb2JqW1wiZGlzcGxheU5hbWVcIl0gKyBcIiBpcyBtb2RpZmllZCBzdWNjZXNzZnVsbHkhXCIpXHJcbiAgICAgICAgZWxzZSBhbGVydChcIk1vZGVsIFwiICsgdGhpcy5kdGRsb2JqW1wiZGlzcGxheU5hbWVcIl0gKyBcIiBpcyBjcmVhdGVkIVwiKVxyXG5cclxuICAgICAgICB0aGlzLmJyb2FkY2FzdE1lc3NhZ2UoeyBcIm1lc3NhZ2VcIjogXCJBRFRNb2RlbEVkaXRlZFwiIH0pXHJcbiAgICAgICAgbW9kZWxBbmFseXplci5hZGRNb2RlbHMobW9kZWxUb0JlSW1wb3J0ZWQpIC8vYWRkIHNvIGltbWVkaWF0bGV5IHRoZSBsaXN0IGNhbiBzaG93IHRoZSBuZXcgbW9kZWxzXHJcbiAgICAgICAgdGhpcy5wb3B1cCgpIC8vcmVmcmVzaCBjb250ZW50XHJcbiAgICB9Y2F0Y2goZSl7XHJcbiAgICAgICAgaWYoYWZ0ZXJGYWlsdXJlKSBhZnRlckZhaWx1cmUoKVxyXG4gICAgICAgIGNvbnNvbGUubG9nKGUpXHJcbiAgICAgICAgaWYoZS5yZXNwb25zZVRleHQpIGFsZXJ0KGUucmVzcG9uc2VUZXh0KVxyXG4gICAgfSBcclxufVxyXG5cclxubW9kZWxFZGl0b3JEaWFsb2cucHJvdG90eXBlLmNvbmZpcm1SZXBsYWNlTW9kZWw9ZnVuY3Rpb24obW9kZWxJRCl7XHJcbiAgICB2YXIgcmVsYXRlZE1vZGVsSURzPW1vZGVsQW5hbHl6ZXIubGlzdE1vZGVsc0ZvckRlbGV0ZU1vZGVsKG1vZGVsSUQpXHJcbiAgICB2YXIgYmFja3VwTW9kZWxzPVtdXHJcbiAgICByZWxhdGVkTW9kZWxJRHMuZm9yRWFjaChvbmVJRD0+e1xyXG4gICAgICAgIGJhY2t1cE1vZGVscy5wdXNoKEpTT04ucGFyc2UobW9kZWxBbmFseXplci5EVERMTW9kZWxzW29uZUlEXVtcIm9yaWdpbmFsXCJdKSlcclxuICAgIH0pXHJcbiAgICBiYWNrdXBNb2RlbHMucHVzaCh0aGlzLmR0ZGxvYmopXHJcbiAgICB2YXIgYmFja3VwTW9kZWxzU3RyPWVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShiYWNrdXBNb2RlbHMpKVxyXG5cclxuICAgIHZhciBmdW5jQWZ0ZXJGYWlsPShkZWxldGVkTW9kZWxJRHMpPT57XHJcbiAgICAgICAgdmFyIHBvbSA9ICQoXCI8YT48L2E+XCIpXHJcbiAgICAgICAgcG9tLmF0dHIoJ2hyZWYnLCAnZGF0YTp0ZXh0L3BsYWluO2NoYXJzZXQ9dXRmLTgsJyArIGJhY2t1cE1vZGVsc1N0cik7XHJcbiAgICAgICAgcG9tLmF0dHIoJ2Rvd25sb2FkJywgXCJleHBvcnRNb2RlbHNBZnRlckZhaWxlZE9wZXJhdGlvbi5qc29uXCIpO1xyXG4gICAgICAgIHBvbVswXS5jbGljaygpXHJcbiAgICB9XHJcbiAgICB2YXIgZnVuY0FmdGVyRWFjaFN1Y2Nlc3NEZWxldGUgPSAoZWFjaERlbGV0ZWRNb2RlbElELGVhY2hNb2RlbE5hbWUpID0+IHt9XHJcbiAgICBcclxuICAgIHZhciBjb21wbGV0ZUZ1bmM9KCk9PnsgXHJcbiAgICAgICAgLy9pbXBvcnQgYWxsIHRoZSBtb2RlbHMgYWdhaW5cclxuICAgICAgICB0aGlzLmltcG9ydE1vZGVsQXJyKGJhY2t1cE1vZGVscyxcImZvclJlcGxhY2luZ1wiLGZ1bmNBZnRlckZhaWwpXHJcbiAgICB9XHJcbiAgICBtb2RlbEFuYWx5emVyLmRlbGV0ZU1vZGVsKG1vZGVsSUQsZnVuY0FmdGVyRWFjaFN1Y2Nlc3NEZWxldGUsZnVuY0FmdGVyRmFpbCxjb21wbGV0ZUZ1bmMpXHJcbn1cclxuXHJcblxyXG5cclxubW9kZWxFZGl0b3JEaWFsb2cucHJvdG90eXBlLmNob29zZVRlbXBsYXRlPWZ1bmN0aW9uKHRlbXBhbHRlTmFtZSl7XHJcbiAgICBpZih0ZW1wYWx0ZU5hbWUhPVwiTmV3XCIpe1xyXG4gICAgICAgIHRoaXMuZHRkbG9iaj1KU09OLnBhcnNlKG1vZGVsQW5hbHl6ZXIuRFRETE1vZGVsc1t0ZW1wYWx0ZU5hbWVdW1wib3JpZ2luYWxcIl0pXHJcbiAgICB9ZWxzZXtcclxuICAgICAgICB0aGlzLmR0ZGxvYmogPSB7XHJcbiAgICAgICAgICAgIFwiQGlkXCI6IFwiZHRtaTphTmFtZVNwYWNlOmFNb2RlbElEOzFcIixcclxuICAgICAgICAgICAgXCJAY29udGV4dFwiOiBbXCJkdG1pOmR0ZGw6Y29udGV4dDsyXCJdLFxyXG4gICAgICAgICAgICBcIkB0eXBlXCI6IFwiSW50ZXJmYWNlXCIsXHJcbiAgICAgICAgICAgIFwiZGlzcGxheU5hbWVcIjogXCJOZXcgTW9kZWxcIixcclxuICAgICAgICAgICAgXCJjb250ZW50c1wiOiBbXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJAdHlwZVwiOiBcIlByb3BlcnR5XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiYXR0cmlidXRlMVwiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwic2NoZW1hXCI6IFwiZG91YmxlXCJcclxuICAgICAgICAgICAgICAgIH0se1xyXG4gICAgICAgICAgICAgICAgICAgIFwiQHR5cGVcIjogXCJSZWxhdGlvbnNoaXBcIixcclxuICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJsaW5rXCJcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHRoaXMubGVmdFNwYW4uZW1wdHkoKVxyXG5cclxuICAgIHRoaXMucmVmcmVzaERUREwoKVxyXG4gICAgdGhpcy5sZWZ0U3Bhbi5hcHBlbmQoJCgnPGRpdiBjbGFzcz1cInczLWJhclwiPjxkaXYgY2xhc3M9XCJ3My1iYXItaXRlbSB3My10b29sdGlwXCIgc3R5bGU9XCJmb250LXNpemU6MS4yZW07cGFkZGluZy1sZWZ0OjJweDtmb250LXdlaWdodDpib2xkO2NvbG9yOmdyYXlcIj5Nb2RlbCBJRCAmIE5hbWU8cCBzdHlsZT1cInBvc2l0aW9uOmFic29sdXRlO3RleHQtYWxpZ246bGVmdDtmb250LXdlaWdodDpub3JtYWw7dG9wOi0xMHB4O3dpZHRoOjIwMHB4XCIgY2xhc3M9XCJ3My10ZXh0IHczLXRhZyB3My10aW55XCI+bW9kZWwgSUQgY29udGFpbnMgbmFtZXNwYWNlLCBhIG1vZGVsIHN0cmluZyBhbmQgYSB2ZXJzaW9uIG51bWJlcjwvcD48L2Rpdj48L2Rpdj4nKSlcclxuICAgIG5ldyBpZFJvdyh0aGlzLmR0ZGxvYmosdGhpcy5sZWZ0U3BhbiwoKT0+e3RoaXMucmVmcmVzaERUREwoKX0pXHJcbiAgICBuZXcgZGlzcGxheU5hbWVSb3codGhpcy5kdGRsb2JqLHRoaXMubGVmdFNwYW4sKCk9Pnt0aGlzLnJlZnJlc2hEVERMKCl9KVxyXG5cclxuICAgIGlmKCF0aGlzLmR0ZGxvYmpbXCJjb250ZW50c1wiXSl0aGlzLmR0ZGxvYmpbXCJjb250ZW50c1wiXT1bXVxyXG4gICAgbmV3IHBhcmFtZXRlcnNSb3codGhpcy5kdGRsb2JqW1wiY29udGVudHNcIl0sdGhpcy5sZWZ0U3BhbiwoKT0+e3RoaXMucmVmcmVzaERUREwoKX0sdGhpcy5ET00ub2Zmc2V0KCkpXHJcbiAgICBuZXcgcmVsYXRpb25zUm93KHRoaXMuZHRkbG9ialtcImNvbnRlbnRzXCJdLHRoaXMubGVmdFNwYW4sKCk9Pnt0aGlzLnJlZnJlc2hEVERMKCl9LHRoaXMuRE9NLm9mZnNldCgpKVxyXG4gICAgbmV3IGNvbXBvbmVudHNSb3codGhpcy5kdGRsb2JqW1wiY29udGVudHNcIl0sdGhpcy5sZWZ0U3BhbiwoKT0+e3RoaXMucmVmcmVzaERUREwoKX0pXHJcblxyXG4gICAgaWYoIXRoaXMuZHRkbG9ialtcImV4dGVuZHNcIl0pdGhpcy5kdGRsb2JqW1wiZXh0ZW5kc1wiXT1bXVxyXG4gICAgbmV3IGJhc2VDbGFzc2VzUm93KHRoaXMuZHRkbG9ialtcImV4dGVuZHNcIl0sdGhpcy5sZWZ0U3BhbiwoKT0+e3RoaXMucmVmcmVzaERUREwoKX0pXHJcbn1cclxuXHJcbm1vZGVsRWRpdG9yRGlhbG9nLnByb3RvdHlwZS5yZWZyZXNoRFRETD1mdW5jdGlvbigpe1xyXG4gICAgLy9pdCB3aWxsIHJlZnJlc2ggdGhlIGdlbmVyYXRlZCBEVERMIHNhbXBsZSwgaXQgd2lsbCBhbHNvIGNoYW5nZSB0aGUgaW1wb3J0IGJ1dHRvbiB0byBzaG93IFwiQ3JlYXRlXCIgb3IgXCJNb2RpZnlcIlxyXG4gICAgdmFyIGN1cnJlbnRNb2RlbElEPXRoaXMuZHRkbG9ialtcIkBpZFwiXVxyXG4gICAgaWYobW9kZWxBbmFseXplci5EVERMTW9kZWxzW2N1cnJlbnRNb2RlbElEXT09bnVsbCkgdGhpcy5pbXBvcnRCdXR0b24udGV4dChcIkNyZWF0ZVwiKVxyXG4gICAgZWxzZSB0aGlzLmltcG9ydEJ1dHRvbi50ZXh0KFwiTW9kaWZ5XCIpXHJcblxyXG4gICAgdGhpcy5kdGRsU2NyaXB0UGFuZWwuZW1wdHkoKVxyXG4gICAgdGhpcy5kdGRsU2NyaXB0UGFuZWwuYXBwZW5kKCQoJzxkaXYgc3R5bGU9XCJoZWlnaHQ6MjBweDt3aWR0aDoxMDBweFwiIGNsYXNzPVwidzMtYmFyIHczLWdyYXlcIj5HZW5lcmF0ZWQgRFRETDwvZGl2PicpKVxyXG4gICAgdGhpcy5kdGRsU2NyaXB0UGFuZWwuYXBwZW5kKCQoJzxwcmUgc3R5bGU9XCJjb2xvcjpncmF5XCI+JytKU09OLnN0cmluZ2lmeSh0aGlzLmR0ZGxvYmosbnVsbCwyKSsnPC9wcmU+JykpXHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gbmV3IG1vZGVsRWRpdG9yRGlhbG9nKCk7XHJcblxyXG5cclxuZnVuY3Rpb24gYmFzZUNsYXNzZXNSb3coZHRkbE9iaixwYXJlbnRET00scmVmcmVzaERURExGKXtcclxuICAgIHZhciByb3dET009JCgnPGRpdiBjbGFzcz1cInczLWJhclwiPjxkaXYgY2xhc3M9XCJ3My1iYXItaXRlbSAgdzMtdG9vbHRpcFwiIHN0eWxlPVwiZm9udC1zaXplOjEuMmVtO3BhZGRpbmctbGVmdDoycHg7Zm9udC13ZWlnaHQ6Ym9sZDtjb2xvcjpncmF5XCI+QmFzZSBDbGFzc2VzPHAgc3R5bGU9XCJwb3NpdGlvbjphYnNvbHV0ZTt0ZXh0LWFsaWduOmxlZnQ7dG9wOi0xMHB4O2ZvbnQtd2VpZ2h0Om5vcm1hbDt3aWR0aDoyMDBweFwiIGNsYXNzPVwidzMtdGV4dCB3My10YWcgdzMtdGlueVwiPkJhc2UgY2xhc3MgbW9kZWxcXCdzIHBhcmFtZXRlcnMgYW5kIHJlbGF0aW9uc2hpcCB0eXBlIGFyZSBpbmhlcml0ZWQ8L3A+PC9kaXY+PC9kaXY+JylcclxuXHJcbiAgICB2YXIgYWRkQnV0dG9uID0gJCgnPGJ1dHRvbiBjbGFzcz1cInczLXJpcHBsZSB3My1iYXItaXRlbSB3My1idXR0b24gdzMtcmVkIHczLWhvdmVyLWFtYmVyXCIgc3R5bGU9XCJtYXJnaW4tdG9wOjJweDtmb250LXNpemU6MS4yZW07cGFkZGluZzo0cHggOHB4XCI+KzwvYnV0dG9uPicpXHJcbiAgICByb3dET00uYXBwZW5kKGFkZEJ1dHRvbilcclxuICAgIHBhcmVudERPTS5hcHBlbmQocm93RE9NKVxyXG4gICAgdmFyIGNvbnRlbnRET009JCgnPGRpdiBzdHlsZT1cInBhZGRpbmctbGVmdDoxMHB4XCI+PC9kaXY+JylcclxuICAgIHJvd0RPTS5hcHBlbmQoY29udGVudERPTSlcclxuICAgIGFkZEJ1dHRvbi5vbihcImNsaWNrXCIsKCk9PntcclxuICAgICAgICB2YXIgbmV3T2JqID0gXCJ1bmtub3duXCJcclxuICAgICAgICBkdGRsT2JqLnB1c2gobmV3T2JqKVxyXG4gICAgICAgIG5ldyBzaW5nbGVCYXNlY2xhc3NSb3cobmV3T2JqLGNvbnRlbnRET00scmVmcmVzaERURExGLGR0ZGxPYmopXHJcbiAgICAgICAgcmVmcmVzaERURExGKClcclxuICAgIH0pXHJcbiAgICAvL2NoZWNrIGV4aXN0ZWQgY29udGVudCBpbml0aWFsbHkgZnJvbSB0ZW1wbGF0ZSBhbmQgdHJpZ2dlciB0aGVpciBkcmF3aW5nXHJcbiAgICBkdGRsT2JqLmZvckVhY2goZWxlbWVudCA9PiB7XHJcbiAgICAgICAgbmV3IHNpbmdsZUJhc2VjbGFzc1JvdyhlbGVtZW50LGNvbnRlbnRET00scmVmcmVzaERURExGLGR0ZGxPYmopXHJcbiAgICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gc2luZ2xlQmFzZWNsYXNzUm93KGR0ZGxPYmoscGFyZW50RE9NLHJlZnJlc2hEVERMRixwYXJlbnREdGRsT2JqKXtcclxuICAgIHZhciBET00gPSAkKCc8ZGl2IGNsYXNzPVwidzMtY2VsbC1yb3dcIj48L2Rpdj4nKVxyXG4gICAgdmFyIGJhc2VDbGFzc05hbWVJbnB1dD0kKCc8aW5wdXQgdHlwZT1cInRleHRcIiBzdHlsZT1cIm91dGxpbmU6bm9uZTtkaXNwbGF5OmlubGluZTt3aWR0aDoyMjBweDtwYWRkaW5nOjRweFwiICBwbGFjZWhvbGRlcj1cImJhc2UgbW9kZWwgaWRcIi8+JykuYWRkQ2xhc3MoXCJ3My1iYXItaXRlbSB3My1pbnB1dCB3My1ib3JkZXJcIik7XHJcbiAgICB2YXIgcmVtb3ZlQnV0dG9uID0gJCgnPGJ1dHRvbiBjbGFzcz1cInczLWJhci1pdGVtIHczLWJ1dHRvbiB3My1ob3Zlci1hbWJlclwiIHN0eWxlPVwiY29sb3I6Z3JheTttYXJnaW4tbGVmdDozcHg7bWFyZ2luLXRvcDoycHg7Zm9udC1zaXplOjEuMmVtO3BhZGRpbmc6MnB4XCI+PGkgY2xhc3M9XCJmYSBmYS10cmFzaCBmYS1sZ1wiPjwvaT48L2J1dHRvbj4nKVxyXG4gICAgRE9NLmFwcGVuZChiYXNlQ2xhc3NOYW1lSW5wdXQscmVtb3ZlQnV0dG9uKVxyXG5cclxuICAgIHJlbW92ZUJ1dHRvbi5vbihcImNsaWNrXCIsKCk9PntcclxuICAgICAgICBmb3IgKHZhciBpID0wO2k8IHBhcmVudER0ZGxPYmoubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHBhcmVudER0ZGxPYmpbaV0gPT0gZHRkbE9iaikge1xyXG4gICAgICAgICAgICAgICAgcGFyZW50RHRkbE9iai5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBET00ucmVtb3ZlKClcclxuICAgICAgICByZWZyZXNoRFRETEYoKVxyXG4gICAgfSlcclxuXHJcbiAgICBwYXJlbnRET00uYXBwZW5kKERPTSlcclxuXHJcbiAgICBiYXNlQ2xhc3NOYW1lSW5wdXQudmFsKGR0ZGxPYmopXHJcbiAgICBiYXNlQ2xhc3NOYW1lSW5wdXQub24oXCJjaGFuZ2VcIiwoKT0+e1xyXG4gICAgICAgIGZvciAodmFyIGkgPTA7aTwgcGFyZW50RHRkbE9iai5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAocGFyZW50RHRkbE9ialtpXSA9PSBkdGRsT2JqKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnREdGRsT2JqW2ldPWJhc2VDbGFzc05hbWVJbnB1dC52YWwoKVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmVmcmVzaERURExGKClcclxuICAgIH0pXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbXBvbmVudHNSb3coZHRkbE9iaixwYXJlbnRET00scmVmcmVzaERURExGKXtcclxuICAgIHZhciByb3dET009JCgnPGRpdiBjbGFzcz1cInczLWJhclwiPjxkaXYgY2xhc3M9XCJ3My1iYXItaXRlbSAgdzMtdG9vbHRpcFwiIHN0eWxlPVwiZm9udC1zaXplOjEuMmVtO3BhZGRpbmctbGVmdDoycHg7Zm9udC13ZWlnaHQ6Ym9sZDtjb2xvcjpncmF5XCI+Q29tcG9uZW50czxwIHN0eWxlPVwicG9zaXRpb246YWJzb2x1dGU7dGV4dC1hbGlnbjpsZWZ0O3RvcDotMTBweDtmb250LXdlaWdodDpub3JtYWw7d2lkdGg6MjAwcHhcIiBjbGFzcz1cInczLXRleHQgdzMtdGFnIHczLXRpbnlcIj5Db21wb25lbnQgbW9kZWxcXCdzIHBhcmFtZXRlcnMgYXJlIGVtYmVkZGVkIHVuZGVyIGEgbmFtZTwvcD48L2Rpdj48L2Rpdj4nKVxyXG5cclxuICAgIHZhciBhZGRCdXR0b24gPSAkKCc8YnV0dG9uIGNsYXNzPVwidzMtcmlwcGxlIHczLWJhci1pdGVtIHczLWJ1dHRvbiB3My1yZWQgdzMtaG92ZXItYW1iZXJcIiBzdHlsZT1cIm1hcmdpbi10b3A6MnB4O2ZvbnQtc2l6ZToxLjJlbTtwYWRkaW5nOjRweCA4cHhcIj4rPC9idXR0b24+JylcclxuICAgIHJvd0RPTS5hcHBlbmQoYWRkQnV0dG9uKVxyXG4gICAgcGFyZW50RE9NLmFwcGVuZChyb3dET00pXHJcbiAgICB2YXIgY29udGVudERPTT0kKCc8ZGl2IHN0eWxlPVwicGFkZGluZy1sZWZ0OjEwcHhcIj48L2Rpdj4nKVxyXG4gICAgcm93RE9NLmFwcGVuZChjb250ZW50RE9NKVxyXG5cclxuICAgIGFkZEJ1dHRvbi5vbihcImNsaWNrXCIsKCk9PntcclxuICAgICAgICB2YXIgbmV3T2JqID0ge1xyXG4gICAgICAgICAgICBcIkB0eXBlXCI6IFwiQ29tcG9uZW50XCIsXHJcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIlNvbWVDb21wb25lbnRcIixcclxuICAgICAgICAgICAgXCJzY2hlbWFcIjpcImR0bWk6c29tZUNvbXBvbmVudE1vZGVsOzFcIlxyXG4gICAgICAgIH1cclxuICAgICAgICBkdGRsT2JqLnB1c2gobmV3T2JqKVxyXG4gICAgICAgIG5ldyBzaW5nbGVDb21wb25lbnRSb3cobmV3T2JqLGNvbnRlbnRET00scmVmcmVzaERURExGLGR0ZGxPYmopXHJcbiAgICAgICAgcmVmcmVzaERURExGKClcclxuICAgIH0pXHJcbiAgICAvL2NoZWNrIGV4aXN0ZWQgY29udGVudCBpbml0aWFsbHkgZnJvbSB0ZW1wbGF0ZSBhbmQgdHJpZ2dlciB0aGVpciBkcmF3aW5nXHJcbiAgICBkdGRsT2JqLmZvckVhY2goZWxlbWVudCA9PiB7XHJcbiAgICAgICAgaWYoZWxlbWVudFtcIkB0eXBlXCJdIT1cIkNvbXBvbmVudFwiKSByZXR1cm5cclxuICAgICAgICBuZXcgc2luZ2xlQ29tcG9uZW50Um93KGVsZW1lbnQsY29udGVudERPTSxyZWZyZXNoRFRETEYsZHRkbE9iailcclxuICAgIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzaW5nbGVDb21wb25lbnRSb3coZHRkbE9iaixwYXJlbnRET00scmVmcmVzaERURExGLHBhcmVudER0ZGxPYmope1xyXG4gICAgdmFyIERPTSA9ICQoJzxkaXYgY2xhc3M9XCJ3My1jZWxsLXJvd1wiPjwvZGl2PicpXHJcbiAgICB2YXIgY29tcG9uZW50TmFtZUlucHV0PSQoJzxpbnB1dCB0eXBlPVwidGV4dFwiIHN0eWxlPVwib3V0bGluZTpub25lO2Rpc3BsYXk6aW5saW5lO3dpZHRoOjEwMHB4O3BhZGRpbmc6NHB4XCIgIHBsYWNlaG9sZGVyPVwiY29tcG9uZW50IG5hbWVcIi8+JykuYWRkQ2xhc3MoXCJ3My1iYXItaXRlbSB3My1pbnB1dCB3My1ib3JkZXJcIik7XHJcbiAgICB2YXIgc2NoZW1hSW5wdXQ9JCgnPGlucHV0IHR5cGU9XCJ0ZXh0XCIgc3R5bGU9XCJvdXRsaW5lOm5vbmU7ZGlzcGxheTppbmxpbmU7d2lkdGg6MTYwcHg7cGFkZGluZzo0cHhcIiAgcGxhY2Vob2xkZXI9XCJjb21wb25lbnQgbW9kZWwgaWQuLi5cIi8+JykuYWRkQ2xhc3MoXCJ3My1iYXItaXRlbSB3My1pbnB1dCB3My1ib3JkZXJcIik7XHJcbiAgICB2YXIgcmVtb3ZlQnV0dG9uID0gJCgnPGJ1dHRvbiBjbGFzcz1cInczLWJhci1pdGVtIHczLWJ1dHRvbiB3My1ob3Zlci1hbWJlclwiIHN0eWxlPVwiY29sb3I6Z3JheTttYXJnaW4tbGVmdDozcHg7bWFyZ2luLXRvcDoycHg7Zm9udC1zaXplOjEuMmVtO3BhZGRpbmc6MnB4XCI+PGkgY2xhc3M9XCJmYSBmYS10cmFzaCBmYS1sZ1wiPjwvaT48L2J1dHRvbj4nKVxyXG4gICAgRE9NLmFwcGVuZChjb21wb25lbnROYW1lSW5wdXQsc2NoZW1hSW5wdXQscmVtb3ZlQnV0dG9uKVxyXG5cclxuICAgIHJlbW92ZUJ1dHRvbi5vbihcImNsaWNrXCIsKCk9PntcclxuICAgICAgICBmb3IgKHZhciBpID0wO2k8IHBhcmVudER0ZGxPYmoubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHBhcmVudER0ZGxPYmpbaV0gPT09IGR0ZGxPYmopIHtcclxuICAgICAgICAgICAgICAgIHBhcmVudER0ZGxPYmouc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgRE9NLnJlbW92ZSgpXHJcbiAgICAgICAgcmVmcmVzaERURExGKClcclxuICAgIH0pXHJcblxyXG4gICAgcGFyZW50RE9NLmFwcGVuZChET00pXHJcblxyXG4gICAgY29tcG9uZW50TmFtZUlucHV0LnZhbChkdGRsT2JqW1wibmFtZVwiXSlcclxuICAgIHNjaGVtYUlucHV0LnZhbChkdGRsT2JqW1wic2NoZW1hXCJdfHxcIlwiKVxyXG5cclxuICAgIGNvbXBvbmVudE5hbWVJbnB1dC5vbihcImNoYW5nZVwiLCgpPT57XHJcbiAgICAgICAgZHRkbE9ialtcIm5hbWVcIl09Y29tcG9uZW50TmFtZUlucHV0LnZhbCgpXHJcbiAgICAgICAgcmVmcmVzaERURExGKClcclxuICAgIH0pXHJcbiAgICBzY2hlbWFJbnB1dC5vbihcImNoYW5nZVwiLCgpPT57XHJcbiAgICAgICAgZHRkbE9ialtcInNjaGVtYVwiXT1zY2hlbWFJbnB1dC52YWwoKVxyXG4gICAgICAgIHJlZnJlc2hEVERMRigpXHJcbiAgICB9KVxyXG59XHJcblxyXG5mdW5jdGlvbiByZWxhdGlvbnNSb3coZHRkbE9iaixwYXJlbnRET00scmVmcmVzaERURExGLGRpYWxvZ09mZnNldCl7XHJcbiAgICB2YXIgcm93RE9NPSQoJzxkaXYgY2xhc3M9XCJ3My1iYXJcIj48ZGl2IGNsYXNzPVwidzMtYmFyLWl0ZW0gdzMtdG9vbHRpcFwiIHN0eWxlPVwiZm9udC1zaXplOjEuMmVtO3BhZGRpbmctbGVmdDoycHg7Zm9udC13ZWlnaHQ6Ym9sZDtjb2xvcjpncmF5XCI+UmVsYXRpb25zaGlwIFR5cGVzPHAgc3R5bGU9XCJwb3NpdGlvbjphYnNvbHV0ZTt0ZXh0LWFsaWduOmxlZnQ7dG9wOi0xMHB4O2ZvbnQtd2VpZ2h0Om5vcm1hbDt3aWR0aDoyMDBweFwiIGNsYXNzPVwidzMtdGV4dCB3My10YWcgdzMtdGlueVwiPlJlbGF0aW9uc2hpcCBjYW4gaGF2ZSBpdHMgb3duIHBhcmFtZXRlcnM8L3A+PC9kaXY+PC9kaXY+JylcclxuXHJcblxyXG4gICAgdmFyIGFkZEJ1dHRvbiA9ICQoJzxidXR0b24gY2xhc3M9XCJ3My1yaXBwbGUgdzMtYmFyLWl0ZW0gdzMtYnV0dG9uIHczLXJlZCB3My1ob3Zlci1hbWJlclwiIHN0eWxlPVwibWFyZ2luLXRvcDoycHg7Zm9udC1zaXplOjEuMmVtO3BhZGRpbmc6NHB4IDhweFwiPis8L2J1dHRvbj4nKVxyXG4gICAgcm93RE9NLmFwcGVuZChhZGRCdXR0b24pXHJcbiAgICBwYXJlbnRET00uYXBwZW5kKHJvd0RPTSlcclxuICAgIHZhciBjb250ZW50RE9NPSQoJzxkaXYgc3R5bGU9XCJwYWRkaW5nLWxlZnQ6MTBweFwiPjwvZGl2PicpXHJcbiAgICByb3dET00uYXBwZW5kKGNvbnRlbnRET00pXHJcblxyXG4gICAgYWRkQnV0dG9uLm9uKFwiY2xpY2tcIiwoKT0+e1xyXG4gICAgICAgIHZhciBuZXdPYmogPSB7XHJcbiAgICAgICAgICAgIFwiQHR5cGVcIjogXCJSZWxhdGlvbnNoaXBcIixcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwicmVsYXRpb24xXCIsXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGR0ZGxPYmoucHVzaChuZXdPYmopXHJcbiAgICAgICAgbmV3IHNpbmdsZVJlbGF0aW9uVHlwZVJvdyhuZXdPYmosY29udGVudERPTSxyZWZyZXNoRFRETEYsZHRkbE9iaixkaWFsb2dPZmZzZXQpXHJcbiAgICAgICAgcmVmcmVzaERURExGKClcclxuICAgIH0pXHJcblxyXG4gICAgLy9jaGVjayBleGlzdGVkIGNvbnRlbnQgaW5pdGlhbGx5IGZyb20gdGVtcGxhdGUgYW5kIHRyaWdnZXIgdGhlaXIgZHJhd2luZ1xyXG4gICAgZHRkbE9iai5mb3JFYWNoKGVsZW1lbnQgPT4ge1xyXG4gICAgICAgIGlmKGVsZW1lbnRbXCJAdHlwZVwiXSE9XCJSZWxhdGlvbnNoaXBcIikgcmV0dXJuXHJcbiAgICAgICAgbmV3IHNpbmdsZVJlbGF0aW9uVHlwZVJvdyhlbGVtZW50LGNvbnRlbnRET00scmVmcmVzaERURExGLGR0ZGxPYmosZGlhbG9nT2Zmc2V0KVxyXG4gICAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNpbmdsZVJlbGF0aW9uVHlwZVJvdyhkdGRsT2JqLHBhcmVudERPTSxyZWZyZXNoRFRETEYscGFyZW50RHRkbE9iaixkaWFsb2dPZmZzZXQpe1xyXG4gICAgdmFyIERPTSA9ICQoJzxkaXYgY2xhc3M9XCJ3My1jZWxsLXJvd1wiPjwvZGl2PicpXHJcbiAgICB2YXIgcmVsYXRpb25OYW1lSW5wdXQ9JCgnPGlucHV0IHR5cGU9XCJ0ZXh0XCIgc3R5bGU9XCJvdXRsaW5lOm5vbmU7ZGlzcGxheTppbmxpbmU7d2lkdGg6OTBweDtwYWRkaW5nOjRweFwiICBwbGFjZWhvbGRlcj1cInJlbGF0aW9uIG5hbWVcIi8+JykuYWRkQ2xhc3MoXCJ3My1iYXItaXRlbSB3My1pbnB1dCB3My1ib3JkZXJcIik7XHJcbiAgICB2YXIgdGFyZ2V0TW9kZWxJRD0kKCc8aW5wdXQgdHlwZT1cInRleHRcIiBzdHlsZT1cIm91dGxpbmU6bm9uZTtkaXNwbGF5OmlubGluZTt3aWR0aDoxNDBweDtwYWRkaW5nOjRweFwiICBwbGFjZWhvbGRlcj1cIihvcHRpb25hbCl0YXJnZXQgbW9kZWxcIi8+JykuYWRkQ2xhc3MoXCJ3My1iYXItaXRlbSB3My1pbnB1dCB3My1ib3JkZXJcIik7XHJcbiAgICB2YXIgYWRkQnV0dG9uID0gJCgnPGJ1dHRvbiBjbGFzcz1cInczLXJpcHBsZSB3My1iYXItaXRlbSB3My1idXR0b24gdzMtaG92ZXItYW1iZXJcIiBzdHlsZT1cImNvbG9yOmdyYXk7bWFyZ2luLWxlZnQ6M3B4O21hcmdpbi10b3A6MnB4O2ZvbnQtc2l6ZToxLjJlbTtwYWRkaW5nOjJweFwiPjxpIGNsYXNzPVwiZmEgZmEtY29nIGZhLWxnXCI+PC9pPjwvYnV0dG9uPicpXHJcbiAgICB2YXIgcmVtb3ZlQnV0dG9uID0gJCgnPGJ1dHRvbiBjbGFzcz1cInczLWJhci1pdGVtIHczLWJ1dHRvbiB3My1ob3Zlci1hbWJlclwiIHN0eWxlPVwiY29sb3I6Z3JheTttYXJnaW4tbGVmdDozcHg7bWFyZ2luLXRvcDoycHg7Zm9udC1zaXplOjEuMmVtO3BhZGRpbmc6MnB4XCI+PGkgY2xhc3M9XCJmYSBmYS10cmFzaCBmYS1sZ1wiPjwvaT48L2J1dHRvbj4nKVxyXG4gICAgRE9NLmFwcGVuZChyZWxhdGlvbk5hbWVJbnB1dCx0YXJnZXRNb2RlbElELGFkZEJ1dHRvbixyZW1vdmVCdXR0b24pXHJcblxyXG4gICAgcmVtb3ZlQnV0dG9uLm9uKFwiY2xpY2tcIiwoKT0+e1xyXG4gICAgICAgIGZvciAodmFyIGkgPTA7aTwgcGFyZW50RHRkbE9iai5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAocGFyZW50RHRkbE9ialtpXSA9PT0gZHRkbE9iaikge1xyXG4gICAgICAgICAgICAgICAgcGFyZW50RHRkbE9iai5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBET00ucmVtb3ZlKClcclxuICAgICAgICByZWZyZXNoRFRETEYoKVxyXG4gICAgfSlcclxuXHJcbiAgICB2YXIgY29udGVudERPTT0kKCc8ZGl2IHN0eWxlPVwicGFkZGluZy1sZWZ0OjEwcHhcIj48L2Rpdj4nKVxyXG4gICAgRE9NLmFwcGVuZChjb250ZW50RE9NKVxyXG4gICAgcGFyZW50RE9NLmFwcGVuZChET00pXHJcblxyXG4gICAgcmVsYXRpb25OYW1lSW5wdXQudmFsKGR0ZGxPYmpbXCJuYW1lXCJdKVxyXG4gICAgdGFyZ2V0TW9kZWxJRC52YWwoZHRkbE9ialtcInRhcmdldFwiXXx8XCJcIilcclxuXHJcbiAgICBhZGRCdXR0b24ub24oXCJjbGlja1wiLCgpPT57XHJcbiAgICAgICAgaWYoISBkdGRsT2JqW1wicHJvcGVydGllc1wiXSkgZHRkbE9ialtcInByb3BlcnRpZXNcIl09W11cclxuICAgICAgICB2YXIgbmV3T2JqID0ge1xyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJuZXdQXCIsXHJcbiAgICAgICAgICAgIFwic2NoZW1hXCI6IFwiZG91YmxlXCJcclxuICAgICAgICB9XHJcbiAgICAgICAgZHRkbE9ialtcInByb3BlcnRpZXNcIl0ucHVzaChuZXdPYmopXHJcbiAgICAgICAgbmV3IHNpbmdsZVBhcmFtZXRlclJvdyhuZXdPYmosY29udGVudERPTSxyZWZyZXNoRFRETEYsZHRkbE9ialtcInByb3BlcnRpZXNcIl0sbnVsbCxkaWFsb2dPZmZzZXQpXHJcbiAgICAgICAgcmVmcmVzaERURExGKClcclxuICAgIH0pXHJcblxyXG4gICAgcmVsYXRpb25OYW1lSW5wdXQub24oXCJjaGFuZ2VcIiwoKT0+e1xyXG4gICAgICAgIGR0ZGxPYmpbXCJuYW1lXCJdPXJlbGF0aW9uTmFtZUlucHV0LnZhbCgpXHJcbiAgICAgICAgcmVmcmVzaERURExGKClcclxuICAgIH0pXHJcbiAgICB0YXJnZXRNb2RlbElELm9uKFwiY2hhbmdlXCIsKCk9PntcclxuICAgICAgICBpZih0YXJnZXRNb2RlbElELnZhbCgpPT1cIlwiKSBkZWxldGUgZHRkbE9ialtcInRhcmdldFwiXVxyXG4gICAgICAgIGVsc2UgZHRkbE9ialtcInRhcmdldFwiXT10YXJnZXRNb2RlbElELnZhbCgpXHJcbiAgICAgICAgcmVmcmVzaERURExGKClcclxuICAgIH0pXHJcbiAgICBpZihkdGRsT2JqW1wicHJvcGVydGllc1wiXSAmJiBkdGRsT2JqW1wicHJvcGVydGllc1wiXS5sZW5ndGg+MCl7XHJcbiAgICAgICAgdmFyIHByb3BlcnRpZXM9ZHRkbE9ialtcInByb3BlcnRpZXNcIl1cclxuICAgICAgICBwcm9wZXJ0aWVzLmZvckVhY2gob25lUHJvcGVydHk9PntcclxuICAgICAgICAgICAgbmV3IHNpbmdsZVBhcmFtZXRlclJvdyhvbmVQcm9wZXJ0eSxjb250ZW50RE9NLHJlZnJlc2hEVERMRixkdGRsT2JqW1wicHJvcGVydGllc1wiXSxudWxsLGRpYWxvZ09mZnNldClcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBwYXJhbWV0ZXJzUm93KGR0ZGxPYmoscGFyZW50RE9NLHJlZnJlc2hEVERMRixkaWFsb2dPZmZzZXQpe1xyXG4gICAgdmFyIHJvd0RPTT0kKCc8ZGl2IGNsYXNzPVwidzMtYmFyXCI+PGRpdiBjbGFzcz1cInczLWJhci1pdGVtXCIgc3R5bGU9XCJmb250LXNpemU6MS4yZW07cGFkZGluZy1sZWZ0OjJweDtmb250LXdlaWdodDpib2xkO2NvbG9yOmdyYXlcIj5QYXJhbWV0ZXJzPC9kaXY+PC9kaXY+JylcclxuICAgIHZhciBhZGRCdXR0b24gPSAkKCc8YnV0dG9uIGNsYXNzPVwidzMtcmlwcGxlIHczLWJhci1pdGVtIHczLWJ1dHRvbiB3My1yZWQgdzMtaG92ZXItYW1iZXJcIiBzdHlsZT1cIm1hcmdpbi10b3A6MnB4O2ZvbnQtc2l6ZToxLjJlbTtwYWRkaW5nOjRweCA4cHhcIj4rPC9idXR0b24+JylcclxuICAgIHJvd0RPTS5hcHBlbmQoYWRkQnV0dG9uKVxyXG4gICAgcGFyZW50RE9NLmFwcGVuZChyb3dET00pXHJcbiAgICB2YXIgY29udGVudERPTT0kKCc8ZGl2IHN0eWxlPVwicGFkZGluZy1sZWZ0OjEwcHhcIj48L2Rpdj4nKVxyXG4gICAgcm93RE9NLmFwcGVuZChjb250ZW50RE9NKVxyXG4gICAgYWRkQnV0dG9uLm9uKFwiY2xpY2tcIiwoKT0+e1xyXG4gICAgICAgIHZhciBuZXdPYmogPSB7XHJcbiAgICAgICAgICAgIFwiQHR5cGVcIjogXCJQcm9wZXJ0eVwiLFxyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJuZXdQXCIsXHJcbiAgICAgICAgICAgIFwic2NoZW1hXCI6IFwiZG91YmxlXCJcclxuICAgICAgICB9XHJcbiAgICAgICAgZHRkbE9iai5wdXNoKG5ld09iailcclxuICAgICAgICBuZXcgc2luZ2xlUGFyYW1ldGVyUm93KG5ld09iaixjb250ZW50RE9NLHJlZnJlc2hEVERMRixkdGRsT2JqLFwidG9wTGV2ZWxcIixkaWFsb2dPZmZzZXQpXHJcbiAgICAgICAgcmVmcmVzaERURExGKClcclxuICAgIH0pXHJcblxyXG4gICAgLy9jaGVjayBleGlzdGVkIGNvbnRlbnQgaW5pdGlhbGx5IGZyb20gdGVtcGxhdGUgYW5kIHRyaWdnZXIgdGhlaXIgZHJhd2luZ1xyXG4gICAgZHRkbE9iai5mb3JFYWNoKGVsZW1lbnQgPT4ge1xyXG4gICAgICAgIGlmKGVsZW1lbnRbXCJAdHlwZVwiXSE9XCJQcm9wZXJ0eVwiKSByZXR1cm5cclxuICAgICAgICBuZXcgc2luZ2xlUGFyYW1ldGVyUm93KGVsZW1lbnQsY29udGVudERPTSxyZWZyZXNoRFRETEYsZHRkbE9iaixcInRvcExldmVsXCIsZGlhbG9nT2Zmc2V0KVxyXG4gICAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNpbmdsZVBhcmFtZXRlclJvdyhkdGRsT2JqLHBhcmVudERPTSxyZWZyZXNoRFRETEYscGFyZW50RHRkbE9iaix0b3BMZXZlbCxkaWFsb2dPZmZzZXQpe1xyXG4gICAgdmFyIERPTSA9ICQoJzxkaXYgY2xhc3M9XCJ3My1jZWxsLXJvd1wiPjwvZGl2PicpXHJcbiAgICB2YXIgcGFyYW1ldGVyTmFtZUlucHV0PSQoJzxpbnB1dCB0eXBlPVwidGV4dFwiIHN0eWxlPVwib3V0bGluZTpub25lO2Rpc3BsYXk6aW5saW5lO3dpZHRoOjEwMHB4O3BhZGRpbmc6NHB4XCIgIHBsYWNlaG9sZGVyPVwicGFyYW1ldGVyIG5hbWVcIi8+JykuYWRkQ2xhc3MoXCJ3My1iYXItaXRlbSB3My1pbnB1dCB3My1ib3JkZXJcIik7XHJcbiAgICB2YXIgZW51bVZhbHVlSW5wdXQ9JCgnPGlucHV0IHR5cGU9XCJ0ZXh0XCIgc3R5bGU9XCJvdXRsaW5lOm5vbmU7ZGlzcGxheTppbmxpbmU7d2lkdGg6MTAwcHg7cGFkZGluZzo0cHhcIiAgcGxhY2Vob2xkZXI9XCJzdHIxLHN0cjIsLi4uXCIvPicpLmFkZENsYXNzKFwidzMtYmFyLWl0ZW0gdzMtaW5wdXQgdzMtYm9yZGVyXCIpO1xyXG4gICAgdmFyIGFkZEJ1dHRvbiA9ICQoJzxidXR0b24gY2xhc3M9XCJ3My1yaXBwbGUgdzMtYmFyLWl0ZW0gdzMtYnV0dG9uIHczLWhvdmVyLWFtYmVyXCIgc3R5bGU9XCJjb2xvcjpncmF5O21hcmdpbi1sZWZ0OjNweDttYXJnaW4tdG9wOjJweDtmb250LXNpemU6MS4yZW07cGFkZGluZzoycHhcIj48aSBjbGFzcz1cImZhIGZhLXBsdXMgZmEtbGdcIj48L2k+PC9idXR0b24+JylcclxuICAgIHZhciByZW1vdmVCdXR0b24gPSAkKCc8YnV0dG9uIGNsYXNzPVwidzMtYmFyLWl0ZW0gdzMtYnV0dG9uIHczLWhvdmVyLWFtYmVyXCIgc3R5bGU9XCJjb2xvcjpncmF5O21hcmdpbi1sZWZ0OjNweDttYXJnaW4tdG9wOjJweDtmb250LXNpemU6MS4yZW07cGFkZGluZzoycHhcIj48aSBjbGFzcz1cImZhIGZhLXRyYXNoIGZhLWxnXCI+PC9pPjwvYnV0dG9uPicpXHJcbiAgICB2YXIgcHR5cGVTZWxlY3Rvcj1uZXcgc2ltcGxlU2VsZWN0TWVudShcIiBcIix7d2l0aEJvcmRlcjoxLGZvbnRTaXplOlwiMWVtXCIsY29sb3JDbGFzczpcInczLWxpZ2h0LWdyYXkgdzMtYmFyLWl0ZW1cIixidXR0b25DU1M6e1wicGFkZGluZ1wiOlwiNHB4IDVweFwifSxcIm9wdGlvbkxpc3RIZWlnaHRcIjozMDAsXCJpc0NsaWNrYWJsZVwiOjEsXCJvcHRpb25MaXN0TWFyZ2luVG9wXCI6LTE1MCxcIm9wdGlvbkxpc3RNYXJnaW5MZWZ0XCI6NjAsXHJcbiAgICBcImFkanVzdFBvc2l0aW9uQW5jaG9yXCI6ZGlhbG9nT2Zmc2V0fSlcclxuICAgIHB0eXBlU2VsZWN0b3IuYWRkT3B0aW9uQXJyKFtcInN0cmluZ1wiLFwiZmxvYXRcIixcImludGVnZXJcIixcIkVudW1cIixcIk9iamVjdFwiLFwiZG91YmxlXCIsXCJib29sZWFuXCIsXCJkYXRlXCIsXCJkYXRlVGltZVwiLFwiZHVyYXRpb25cIixcImxvbmdcIixcInRpbWVcIl0pXHJcbiAgICBET00uYXBwZW5kKHBhcmFtZXRlck5hbWVJbnB1dCxwdHlwZVNlbGVjdG9yLkRPTSxlbnVtVmFsdWVJbnB1dCxhZGRCdXR0b24scmVtb3ZlQnV0dG9uKVxyXG5cclxuICAgIHJlbW92ZUJ1dHRvbi5vbihcImNsaWNrXCIsKCk9PntcclxuICAgICAgICBmb3IgKHZhciBpID0wO2k8IHBhcmVudER0ZGxPYmoubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHBhcmVudER0ZGxPYmpbaV0gPT09IGR0ZGxPYmopIHtcclxuICAgICAgICAgICAgICAgIHBhcmVudER0ZGxPYmouc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgRE9NLnJlbW92ZSgpXHJcbiAgICAgICAgcmVmcmVzaERURExGKClcclxuICAgIH0pXHJcbiAgICBcclxuICAgIHZhciBjb250ZW50RE9NPSQoJzxkaXYgc3R5bGU9XCJwYWRkaW5nLWxlZnQ6MTBweFwiPjwvZGl2PicpXHJcbiAgICBET00uYXBwZW5kKGNvbnRlbnRET00pXHJcbiAgICBwYXJlbnRET00uYXBwZW5kKERPTSlcclxuXHJcbiAgICBwYXJhbWV0ZXJOYW1lSW5wdXQudmFsKGR0ZGxPYmpbXCJuYW1lXCJdKVxyXG4gICAgcHR5cGVTZWxlY3Rvci5jYWxsQmFja19jbGlja09wdGlvbj0ob3B0aW9uVGV4dCxvcHRpb25WYWx1ZSxyZWFsTW91c2VDbGljayk9PntcclxuICAgICAgICBwdHlwZVNlbGVjdG9yLmNoYW5nZU5hbWUob3B0aW9uVGV4dClcclxuICAgICAgICBjb250ZW50RE9NLmVtcHR5KCkvL2NsZWFyIGFsbCBjb250ZW50IGRvbSBjb250ZW50XHJcbiAgICAgICAgaWYocmVhbE1vdXNlQ2xpY2spe1xyXG4gICAgICAgICAgICBmb3IodmFyIGluZCBpbiBkdGRsT2JqKSBkZWxldGUgZHRkbE9ialtpbmRdICAgIC8vY2xlYXIgYWxsIG9iamVjdCBjb250ZW50XHJcbiAgICAgICAgICAgIGlmKHRvcExldmVsKSBkdGRsT2JqW1wiQHR5cGVcIl09XCJQcm9wZXJ0eVwiXHJcbiAgICAgICAgICAgIGR0ZGxPYmpbXCJuYW1lXCJdPXBhcmFtZXRlck5hbWVJbnB1dC52YWwoKVxyXG4gICAgICAgIH0gXHJcbiAgICAgICAgaWYob3B0aW9uVGV4dD09XCJFbnVtXCIpe1xyXG4gICAgICAgICAgICBlbnVtVmFsdWVJbnB1dC52YWwoXCJcIilcclxuICAgICAgICAgICAgZW51bVZhbHVlSW5wdXQuc2hvdygpO1xyXG4gICAgICAgICAgICBhZGRCdXR0b24uaGlkZSgpXHJcbiAgICAgICAgICAgIGlmKHJlYWxNb3VzZUNsaWNrKSBkdGRsT2JqW1wic2NoZW1hXCJdPXtcIkB0eXBlXCI6IFwiRW51bVwiLFwidmFsdWVTY2hlbWFcIjogXCJzdHJpbmdcIn1cclxuICAgICAgICB9ZWxzZSBpZihvcHRpb25UZXh0PT1cIk9iamVjdFwiKXtcclxuICAgICAgICAgICAgZW51bVZhbHVlSW5wdXQuaGlkZSgpO1xyXG4gICAgICAgICAgICBhZGRCdXR0b24uc2hvdygpXHJcbiAgICAgICAgICAgIGlmKHJlYWxNb3VzZUNsaWNrKSBkdGRsT2JqW1wic2NoZW1hXCJdPXtcIkB0eXBlXCI6IFwiT2JqZWN0XCJ9XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIGlmKHJlYWxNb3VzZUNsaWNrKSBkdGRsT2JqW1wic2NoZW1hXCJdPW9wdGlvblRleHRcclxuICAgICAgICAgICAgZW51bVZhbHVlSW5wdXQuaGlkZSgpO1xyXG4gICAgICAgICAgICBhZGRCdXR0b24uaGlkZSgpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlZnJlc2hEVERMRigpXHJcbiAgICB9XHJcbiAgICBhZGRCdXR0b24ub24oXCJjbGlja1wiLCgpPT57XHJcbiAgICAgICAgaWYoISBkdGRsT2JqW1wic2NoZW1hXCJdW1wiZmllbGRzXCJdKSBkdGRsT2JqW1wic2NoZW1hXCJdW1wiZmllbGRzXCJdPVtdXHJcbiAgICAgICAgdmFyIG5ld09iaiA9IHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwibmV3UFwiLFxyXG4gICAgICAgICAgICBcInNjaGVtYVwiOiBcImRvdWJsZVwiXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGR0ZGxPYmpbXCJzY2hlbWFcIl1bXCJmaWVsZHNcIl0ucHVzaChuZXdPYmopXHJcbiAgICAgICAgbmV3IHNpbmdsZVBhcmFtZXRlclJvdyhuZXdPYmosY29udGVudERPTSxyZWZyZXNoRFRETEYsZHRkbE9ialtcInNjaGVtYVwiXVtcImZpZWxkc1wiXSxudWxsLGRpYWxvZ09mZnNldClcclxuICAgICAgICByZWZyZXNoRFRETEYoKVxyXG4gICAgfSlcclxuXHJcbiAgICBwYXJhbWV0ZXJOYW1lSW5wdXQub24oXCJjaGFuZ2VcIiwoKT0+e1xyXG4gICAgICAgIGR0ZGxPYmpbXCJuYW1lXCJdPXBhcmFtZXRlck5hbWVJbnB1dC52YWwoKVxyXG4gICAgICAgIHJlZnJlc2hEVERMRigpXHJcbiAgICB9KVxyXG4gICAgZW51bVZhbHVlSW5wdXQub24oXCJjaGFuZ2VcIiwoKT0+e1xyXG4gICAgICAgIHZhciB2YWx1ZUFycj1lbnVtVmFsdWVJbnB1dC52YWwoKS5zcGxpdChcIixcIilcclxuICAgICAgICBkdGRsT2JqW1wic2NoZW1hXCJdW1wiZW51bVZhbHVlc1wiXT1bXVxyXG4gICAgICAgIHZhbHVlQXJyLmZvckVhY2goYVZhbD0+e1xyXG4gICAgICAgICAgICBkdGRsT2JqW1wic2NoZW1hXCJdW1wiZW51bVZhbHVlc1wiXS5wdXNoKHtcclxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBhVmFsLnJlcGxhY2UoXCIgXCIsXCJcIiksIC8vcmVtb3ZlIGFsbCB0aGUgc3BhY2UgaW4gbmFtZVxyXG4gICAgICAgICAgICAgICAgXCJlbnVtVmFsdWVcIjogYVZhbFxyXG4gICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSlcclxuICAgICAgICByZWZyZXNoRFRETEYoKVxyXG4gICAgfSlcclxuICAgIGlmKHR5cGVvZihkdGRsT2JqW1wic2NoZW1hXCJdKSAhPSAnb2JqZWN0JykgdmFyIHNjaGVtYT1kdGRsT2JqW1wic2NoZW1hXCJdXHJcbiAgICBlbHNlIHNjaGVtYT1kdGRsT2JqW1wic2NoZW1hXCJdW1wiQHR5cGVcIl1cclxuICAgIHB0eXBlU2VsZWN0b3IudHJpZ2dlck9wdGlvblZhbHVlKHNjaGVtYSlcclxuICAgIGlmKHNjaGVtYT09XCJFbnVtXCIpe1xyXG4gICAgICAgIHZhciBlbnVtQXJyPWR0ZGxPYmpbXCJzY2hlbWFcIl1bXCJlbnVtVmFsdWVzXCJdXHJcbiAgICAgICAgaWYoZW51bUFyciE9bnVsbCl7XHJcbiAgICAgICAgICAgIHZhciBpbnB1dFN0cj1cIlwiXHJcbiAgICAgICAgICAgIGVudW1BcnIuZm9yRWFjaChvbmVFbnVtVmFsdWU9PntpbnB1dFN0cis9b25lRW51bVZhbHVlLmVudW1WYWx1ZStcIixcIn0pXHJcbiAgICAgICAgICAgIGlucHV0U3RyPWlucHV0U3RyLnNsaWNlKDAsIC0xKS8vcmVtb3ZlIHRoZSBsYXN0IFwiLFwiXHJcbiAgICAgICAgICAgIGVudW1WYWx1ZUlucHV0LnZhbChpbnB1dFN0cilcclxuICAgICAgICB9XHJcbiAgICB9ZWxzZSBpZihzY2hlbWE9PVwiT2JqZWN0XCIpe1xyXG4gICAgICAgIHZhciBmaWVsZHM9ZHRkbE9ialtcInNjaGVtYVwiXVtcImZpZWxkc1wiXVxyXG4gICAgICAgIGZpZWxkcy5mb3JFYWNoKG9uZUZpZWxkPT57XHJcbiAgICAgICAgICAgIG5ldyBzaW5nbGVQYXJhbWV0ZXJSb3cob25lRmllbGQsY29udGVudERPTSxyZWZyZXNoRFRETEYsZHRkbE9ialtcInNjaGVtYVwiXVtcImZpZWxkc1wiXSxudWxsLGRpYWxvZ09mZnNldClcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gaWRSb3coZHRkbE9iaixwYXJlbnRET00scmVmcmVzaERURExGKXtcclxuICAgIHZhciBET00gPSAkKCc8ZGl2IGNsYXNzPVwidzMtY2VsbC1yb3dcIj48L2Rpdj4nKVxyXG4gICAgdmFyIGxhYmVsMT0kKCc8ZGl2IGNsYXNzPVwidzMtb3BhY2l0eVwiIHN0eWxlPVwiZGlzcGxheTppbmxpbmVcIj5kdG1pOjwvZGl2PicpXHJcbiAgICB2YXIgZG9tYWluSW5wdXQ9JCgnPGlucHV0IHR5cGU9XCJ0ZXh0XCIgc3R5bGU9XCJvdXRsaW5lOm5vbmU7ZGlzcGxheTppbmxpbmU7d2lkdGg6ODhweDtwYWRkaW5nOjRweFwiICBwbGFjZWhvbGRlcj1cIk5hbWVzcGFjZVwiLz4nKS5hZGRDbGFzcyhcInczLWlucHV0IHczLWJvcmRlclwiKTtcclxuICAgIHZhciBtb2RlbElESW5wdXQ9JCgnPGlucHV0IHR5cGU9XCJ0ZXh0XCIgc3R5bGU9XCJvdXRsaW5lOm5vbmU7ZGlzcGxheTppbmxpbmU7d2lkdGg6MTMycHg7cGFkZGluZzo0cHhcIiAgcGxhY2Vob2xkZXI9XCJNb2RlbElEXCIvPicpLmFkZENsYXNzKFwidzMtaW5wdXQgdzMtYm9yZGVyXCIpO1xyXG4gICAgdmFyIHZlcnNpb25JbnB1dD0kKCc8aW5wdXQgdHlwZT1cInRleHRcIiBzdHlsZT1cIm91dGxpbmU6bm9uZTtkaXNwbGF5OmlubGluZTt3aWR0aDo2MHB4O3BhZGRpbmc6NHB4XCIgIHBsYWNlaG9sZGVyPVwidmVyc2lvblwiLz4nKS5hZGRDbGFzcyhcInczLWlucHV0IHczLWJvcmRlclwiKTtcclxuICAgIERPTS5hcHBlbmQobGFiZWwxLGRvbWFpbklucHV0LCQoJzxkaXYgY2xhc3M9XCJ3My1vcGFjaXR5XCIgc3R5bGU9XCJkaXNwbGF5OmlubGluZVwiPjo8L2Rpdj4nKSxtb2RlbElESW5wdXQsJCgnPGRpdiBjbGFzcz1cInczLW9wYWNpdHlcIiBzdHlsZT1cImRpc3BsYXk6aW5saW5lXCI+OzwvZGl2PicpLHZlcnNpb25JbnB1dClcclxuICAgIHBhcmVudERPTS5hcHBlbmQoRE9NKVxyXG5cclxuICAgIHZhciB2YWx1ZUNoYW5nZT0oKT0+e1xyXG4gICAgICAgIHZhciBzdHI9YGR0bWk6JHtkb21haW5JbnB1dC52YWwoKX06JHttb2RlbElESW5wdXQudmFsKCl9OyR7dmVyc2lvbklucHV0LnZhbCgpfWBcclxuICAgICAgICBkdGRsT2JqW1wiQGlkXCJdPXN0clxyXG4gICAgICAgIHJlZnJlc2hEVERMRigpXHJcbiAgICB9XHJcbiAgICBkb21haW5JbnB1dC5vbihcImNoYW5nZVwiLHZhbHVlQ2hhbmdlKVxyXG4gICAgbW9kZWxJRElucHV0Lm9uKFwiY2hhbmdlXCIsdmFsdWVDaGFuZ2UpXHJcbiAgICB2ZXJzaW9uSW5wdXQub24oXCJjaGFuZ2VcIix2YWx1ZUNoYW5nZSlcclxuXHJcbiAgICB2YXIgc3RyPWR0ZGxPYmpbXCJAaWRcIl1cclxuICAgIGlmKHN0ciE9XCJcIiAmJiBzdHIhPW51bGwpe1xyXG4gICAgICAgIHZhciBhcnIxPXN0ci5zcGxpdChcIjtcIilcclxuICAgICAgICBpZihhcnIxLmxlbmd0aCE9MikgcmV0dXJuO1xyXG4gICAgICAgIHZlcnNpb25JbnB1dC52YWwoYXJyMVsxXSlcclxuICAgICAgICB2YXIgYXJyMj1hcnIxWzBdLnNwbGl0KFwiOlwiKVxyXG4gICAgICAgIGRvbWFpbklucHV0LnZhbChhcnIyWzFdKVxyXG4gICAgICAgIGFycjIuc2hpZnQoKTsgYXJyMi5zaGlmdCgpXHJcbiAgICAgICAgbW9kZWxJRElucHV0LnZhbChhcnIyLmpvaW4oXCI6XCIpKVxyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBkaXNwbGF5TmFtZVJvdyhkdGRsT2JqLHBhcmVudERPTSxyZWZyZXNoRFRETEYpe1xyXG4gICAgdmFyIERPTSA9ICQoJzxkaXYgY2xhc3M9XCJ3My1jZWxsLXJvd1wiPjwvZGl2PicpXHJcbiAgICB2YXIgbGFiZWwxPSQoJzxkaXYgY2xhc3M9XCJ3My1vcGFjaXR5XCIgc3R5bGU9XCJkaXNwbGF5OmlubGluZVwiPkRpc3BsYXkgTmFtZTo8L2Rpdj4nKVxyXG4gICAgdmFyIG5hbWVJbnB1dD0kKCc8aW5wdXQgdHlwZT1cInRleHRcIiBzdHlsZT1cIm91dGxpbmU6bm9uZTtkaXNwbGF5OmlubGluZTt3aWR0aDoxNTBweDtwYWRkaW5nOjRweFwiICBwbGFjZWhvbGRlcj1cIk1vZGVsSURcIi8+JykuYWRkQ2xhc3MoXCJ3My1pbnB1dCB3My1ib3JkZXJcIik7XHJcbiAgICBET00uYXBwZW5kKGxhYmVsMSxuYW1lSW5wdXQpXHJcbiAgICBwYXJlbnRET00uYXBwZW5kKERPTSlcclxuICAgIHZhciB2YWx1ZUNoYW5nZT0oKT0+e1xyXG4gICAgICAgIGR0ZGxPYmpbXCJkaXNwbGF5TmFtZVwiXT1uYW1lSW5wdXQudmFsKClcclxuICAgICAgICByZWZyZXNoRFRETEYoKVxyXG4gICAgfVxyXG4gICAgbmFtZUlucHV0Lm9uKFwiY2hhbmdlXCIsdmFsdWVDaGFuZ2UpXHJcbiAgICB2YXIgc3RyPWR0ZGxPYmpbXCJkaXNwbGF5TmFtZVwiXVxyXG4gICAgaWYoc3RyIT1cIlwiICYmIHN0ciE9bnVsbCkgbmFtZUlucHV0LnZhbChzdHIpXHJcbn0iLCJjb25zdCBtb2RlbEFuYWx5emVyPXJlcXVpcmUoXCIuL21vZGVsQW5hbHl6ZXJcIilcclxuY29uc3Qgc2ltcGxlVHJlZT0gcmVxdWlyZShcIi4vc2ltcGxlVHJlZVwiKVxyXG5jb25zdCBzaW1wbGVDb25maXJtRGlhbG9nID0gcmVxdWlyZShcIi4vc2ltcGxlQ29uZmlybURpYWxvZ1wiKVxyXG5jb25zdCBtb2RlbEVkaXRvckRpYWxvZyA9IHJlcXVpcmUoXCIuL21vZGVsRWRpdG9yRGlhbG9nXCIpXHJcbmNvbnN0IGdsb2JhbENhY2hlID0gcmVxdWlyZShcIi4vZ2xvYmFsQ2FjaGVcIilcclxuY29uc3QgbXNhbEhlbHBlcj1yZXF1aXJlKFwiLi4vbXNhbEhlbHBlclwiKVxyXG5jb25zdCBzaW1wbGVFeHBhbmRhYmxlU2VjdGlvbj0gcmVxdWlyZShcIi4uL3NoYXJlZFNvdXJjZUZpbGVzL3NpbXBsZUV4cGFuZGFibGVTZWN0aW9uXCIpXHJcblxyXG5mdW5jdGlvbiBtb2RlbE1hbmFnZXJEaWFsb2coKSB7XHJcbiAgICBpZighdGhpcy5ET00pe1xyXG4gICAgICAgIHRoaXMuRE9NID0gJCgnPGRpdiBzdHlsZT1cInBvc2l0aW9uOmFic29sdXRlO3RvcDo1MCU7YmFja2dyb3VuZC1jb2xvcjp3aGl0ZTtsZWZ0OjUwJTt0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTUwJSkgdHJhbnNsYXRlWSgtNTAlKTt6LWluZGV4Ojk5XCIgY2xhc3M9XCJ3My1jYXJkLTJcIj48L2Rpdj4nKVxyXG4gICAgICAgIHRoaXMuRE9NLmNzcyhcIm92ZXJmbG93XCIsXCJoaWRkZW5cIilcclxuICAgICAgICAkKFwiYm9keVwiKS5hcHBlbmQodGhpcy5ET00pXHJcbiAgICAgICAgdGhpcy5ET00uaGlkZSgpXHJcbiAgICAgICAgZ2xvYmFsQ2FjaGUubWFrZURPTURyYWdnYWJsZSh0aGlzLkRPTSlcclxuICAgIH1cclxuICAgIHRoaXMuc2hvd1JlbGF0aW9uVmlzdWFsaXphdGlvblNldHRpbmdzPXRydWU7XHJcbn1cclxuXHJcbm1vZGVsTWFuYWdlckRpYWxvZy5wcm90b3R5cGUucG9wdXAgPSBhc3luYyBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuRE9NLnNob3coKVxyXG4gICAgdGhpcy5ET00uZW1wdHkoKVxyXG4gICAgdGhpcy5jb250ZW50RE9NID0gJCgnPGRpdiBzdHlsZT1cIndpZHRoOjcwMHB4XCI+PC9kaXY+JylcclxuICAgIHRoaXMuRE9NLmFwcGVuZCh0aGlzLmNvbnRlbnRET00pXHJcbiAgICB0aGlzLmNvbnRlbnRET00uYXBwZW5kKCQoJzxkaXYgc3R5bGU9XCJoZWlnaHQ6NDBweFwiIGNsYXNzPVwidzMtYmFyIHczLXJlZFwiPjxkaXYgY2xhc3M9XCJ3My1iYXItaXRlbVwiIHN0eWxlPVwiZm9udC1zaXplOjEuNWVtXCI+RGlnaXRhbCBUd2luIE1vZGVsczwvZGl2PjwvZGl2PicpKVxyXG4gICAgdmFyIGNsb3NlQnV0dG9uID0gJCgnPGJ1dHRvbiBjbGFzcz1cInczLWJhci1pdGVtIHczLWJ1dHRvbiB3My1yaWdodFwiIHN0eWxlPVwiZm9udC1zaXplOjJlbTtwYWRkaW5nLXRvcDo0cHhcIj7DlzwvYnV0dG9uPicpXHJcbiAgICB0aGlzLmNvbnRlbnRET00uY2hpbGRyZW4oJzpmaXJzdCcpLmFwcGVuZChjbG9zZUJ1dHRvbilcclxuICAgIGNsb3NlQnV0dG9uLm9uKFwiY2xpY2tcIiwgKCkgPT4geyB0aGlzLkRPTS5oaWRlKCkgfSlcclxuXHJcbiAgICB2YXIgaW1wb3J0TW9kZWxzQnRuID0gJCgnPGJ1dHRvbiBjbGFzcz1cInczLWJ1dHRvbiB3My1jYXJkIHczLWRlZXAtb3JhbmdlIHczLWhvdmVyLWxpZ2h0LWdyZWVuXCIgc3R5bGU9XCJoZWlnaHQ6MTAwJVwiPkltcG9ydDwvYnV0dG9uPicpXHJcbiAgICB2YXIgYWN0dWFsSW1wb3J0TW9kZWxzQnRuID0kKCc8aW5wdXQgdHlwZT1cImZpbGVcIiBuYW1lPVwibW9kZWxGaWxlc1wiIG11bHRpcGxlPVwibXVsdGlwbGVcIiBzdHlsZT1cImRpc3BsYXk6bm9uZVwiPjwvaW5wdXQ+JylcclxuICAgIHZhciBtb2RlbEVkaXRvckJ0biA9ICQoJzxidXR0b24gY2xhc3M9XCJ3My1idXR0b24gdzMtY2FyZCB3My1kZWVwLW9yYW5nZSB3My1ob3Zlci1saWdodC1ncmVlblwiIHN0eWxlPVwiaGVpZ2h0OjEwMCVcIj5DcmVhdGUvTW9kaWZ5IE1vZGVsPC9idXR0b24+JylcclxuICAgIHZhciBleHBvcnRNb2RlbEJ0biA9ICQoJzxidXR0b24gY2xhc3M9XCJ3My1yaXBwbGUgdzMtYnV0dG9uIHczLWNhcmQgdzMtZGVlcC1vcmFuZ2UgdzMtaG92ZXItbGlnaHQtZ3JlZW5cIiBzdHlsZT1cImhlaWdodDoxMDAlXCI+RXhwb3J0IEFsbCBNb2RlbHM8L2J1dHRvbj4nKVxyXG4gICAgdGhpcy5jb250ZW50RE9NLmNoaWxkcmVuKCc6Zmlyc3QnKS5hcHBlbmQoaW1wb3J0TW9kZWxzQnRuLGFjdHVhbEltcG9ydE1vZGVsc0J0biwgbW9kZWxFZGl0b3JCdG4sZXhwb3J0TW9kZWxCdG4pXHJcbiAgICBpbXBvcnRNb2RlbHNCdG4ub24oXCJjbGlja1wiLCAoKT0+e1xyXG4gICAgICAgIGFjdHVhbEltcG9ydE1vZGVsc0J0bi50cmlnZ2VyKCdjbGljaycpO1xyXG4gICAgfSk7XHJcbiAgICBhY3R1YWxJbXBvcnRNb2RlbHNCdG4uY2hhbmdlKGFzeW5jIChldnQpPT57XHJcbiAgICAgICAgdmFyIGZpbGVzID0gZXZ0LnRhcmdldC5maWxlczsgLy8gRmlsZUxpc3Qgb2JqZWN0XHJcbiAgICAgICAgYXdhaXQgdGhpcy5yZWFkTW9kZWxGaWxlc0NvbnRlbnRBbmRJbXBvcnQoZmlsZXMpXHJcbiAgICAgICAgYWN0dWFsSW1wb3J0TW9kZWxzQnRuLnZhbChcIlwiKVxyXG4gICAgfSlcclxuICAgIG1vZGVsRWRpdG9yQnRuLm9uKFwiY2xpY2tcIiwoKT0+e1xyXG4gICAgICAgIG1vZGVsRWRpdG9yRGlhbG9nLnBvcHVwKClcclxuICAgIH0pXHJcbiAgICBleHBvcnRNb2RlbEJ0bi5vbihcImNsaWNrXCIsICgpID0+IHtcclxuICAgICAgICB2YXIgbW9kZWxBcnI9W11cclxuICAgICAgICBmb3IodmFyIG1vZGVsSUQgaW4gbW9kZWxBbmFseXplci5EVERMTW9kZWxzKSBtb2RlbEFyci5wdXNoKEpTT04ucGFyc2UobW9kZWxBbmFseXplci5EVERMTW9kZWxzW21vZGVsSURdW1wib3JpZ2luYWxcIl0pKVxyXG4gICAgICAgIHZhciBwb20gPSAkKFwiPGE+PC9hPlwiKVxyXG4gICAgICAgIHBvbS5hdHRyKCdocmVmJywgJ2RhdGE6dGV4dC9wbGFpbjtjaGFyc2V0PXV0Zi04LCcgKyBlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkobW9kZWxBcnIpKSk7XHJcbiAgICAgICAgcG9tLmF0dHIoJ2Rvd25sb2FkJywgXCJleHBvcnRNb2RlbHMuanNvblwiKTtcclxuICAgICAgICBwb21bMF0uY2xpY2soKVxyXG4gICAgfSlcclxuXHJcbiAgICB2YXIgcm93Mj0kKCc8ZGl2IGNsYXNzPVwidzMtY2VsbC1yb3dcIiBzdHlsZT1cIm1hcmdpbi10b3A6MnB4XCI+PC9kaXY+JylcclxuICAgIHRoaXMuY29udGVudERPTS5hcHBlbmQocm93MilcclxuICAgIHZhciBsZWZ0U3Bhbj0kKCc8ZGl2IGNsYXNzPVwidzMtY2VsbFwiIHN0eWxlPVwid2lkdGg6MjQwcHg7cGFkZGluZy1yaWdodDo1cHhcIj48L2Rpdj4nKVxyXG4gICAgcm93Mi5hcHBlbmQobGVmdFNwYW4pXHJcbiAgICBsZWZ0U3Bhbi5hcHBlbmQoJCgnPGRpdiBzdHlsZT1cImhlaWdodDozMHB4XCIgY2xhc3M9XCJ3My1iYXIgdzMtcmVkXCI+PGRpdiBjbGFzcz1cInczLWJhci1pdGVtXCIgc3R5bGU9XCJcIj5Nb2RlbHM8L2Rpdj48L2Rpdj4nKSlcclxuICAgIFxyXG4gICAgdmFyIG1vZGVsTGlzdCA9ICQoJzx1bCBjbGFzcz1cInczLXVsIHczLWhvdmVyYWJsZVwiPicpXHJcbiAgICBtb2RlbExpc3QuY3NzKHtcIm92ZXJmbG93LXhcIjpcImhpZGRlblwiLFwib3ZlcmZsb3cteVwiOlwiYXV0b1wiLFwiaGVpZ2h0XCI6XCI0MjBweFwiLCBcImJvcmRlclwiOlwic29saWQgMXB4IGxpZ2h0Z3JheVwifSlcclxuICAgIGxlZnRTcGFuLmFwcGVuZChtb2RlbExpc3QpXHJcbiAgICB0aGlzLm1vZGVsTGlzdCA9IG1vZGVsTGlzdDtcclxuICAgIFxyXG4gICAgdmFyIHJpZ2h0U3Bhbj0kKCc8ZGl2IGNsYXNzPVwidzMtY29udGFpbmVyIHczLWNlbGxcIiBzdHlsZT1cInBhZGRpbmc6MHB4XCI+PC9kaXY+JylcclxuICAgIHJvdzIuYXBwZW5kKHJpZ2h0U3BhbikgXHJcbiAgICB2YXIgcGFuZWxDYXJkT3V0PSQoJzxkaXYgY2xhc3M9XCJ3My1jYXJkLTIgdzMtd2hpdGVcIiBzdHlsZT1cIm1hcmdpbi10b3A6MnB4XCI+PC9kaXY+JylcclxuXHJcbiAgICB0aGlzLm1vZGVsQnV0dG9uQmFyPSQoJzxkaXYgY2xhc3M9XCJ3My1iYXJcIiBzdHlsZT1cImhlaWdodDozNXB4XCI+PC9kaXY+JylcclxuICAgIHBhbmVsQ2FyZE91dC5hcHBlbmQodGhpcy5tb2RlbEJ1dHRvbkJhcilcclxuXHJcbiAgICByaWdodFNwYW4uYXBwZW5kKHBhbmVsQ2FyZE91dClcclxuICAgIHZhciBwYW5lbENhcmQ9JCgnPGRpdiBzdHlsZT1cIndpZHRoOjQ2MHB4O2hlaWdodDo0MTJweDtvdmVyZmxvdzphdXRvO21hcmdpbi10b3A6MnB4XCI+PC9kaXY+JylcclxuICAgIHBhbmVsQ2FyZE91dC5hcHBlbmQocGFuZWxDYXJkKVxyXG4gICAgdGhpcy5wYW5lbENhcmQ9cGFuZWxDYXJkO1xyXG5cclxuICAgIHRoaXMubW9kZWxCdXR0b25CYXIuZW1wdHkoKVxyXG4gICAgcGFuZWxDYXJkLmh0bWwoXCI8YSBzdHlsZT0nZGlzcGxheTpibG9jaztmb250LXN0eWxlOml0YWxpYztjb2xvcjpncmF5O3BhZGRpbmctbGVmdDo1cHgnPkNob29zZSBhIG1vZGVsIHRvIHZpZXcgaW5mb21yYXRpb248L2E+XCIpXHJcblxyXG4gICAgdGhpcy5saXN0TW9kZWxzKClcclxufVxyXG5cclxubW9kZWxNYW5hZ2VyRGlhbG9nLnByb3RvdHlwZS5yZXNpemVJbWdGaWxlID0gYXN5bmMgZnVuY3Rpb24odGhlRmlsZSxtYXhfc2l6ZSkge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcclxuICAgICAgICAgICAgdmFyIHRtcEltZyA9IG5ldyBJbWFnZSgpO1xyXG4gICAgICAgICAgICByZWFkZXIub25sb2FkID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdG1wSW1nLm9ubG9hZCA9ICAoKT0+IHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJylcclxuICAgICAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSB0bXBJbWcud2lkdGhcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gdG1wSW1nLmhlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAod2lkdGggPiBoZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdpZHRoID4gbWF4X3NpemUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodCAqPSBtYXhfc2l6ZSAvIHdpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBtYXhfc2l6ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoZWlnaHQgPiBtYXhfc2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggKj0gbWF4X3NpemUgLyBoZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSBtYXhfc2l6ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcclxuICAgICAgICAgICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLmRyYXdJbWFnZSh0bXBJbWcsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhVXJsID0gY2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvcG5nJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShkYXRhVXJsKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdG1wSW1nLnNyYyA9IHJlYWRlci5yZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwodGhlRmlsZSk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICByZWplY3QoZSlcclxuICAgICAgICB9XHJcbiAgICB9KVxyXG59XHJcblxyXG5tb2RlbE1hbmFnZXJEaWFsb2cucHJvdG90eXBlLmZpbGxSaWdodFNwYW49YXN5bmMgZnVuY3Rpb24obW9kZWxJRCl7XHJcbiAgICB0aGlzLnBhbmVsQ2FyZC5lbXB0eSgpXHJcbiAgICB0aGlzLm1vZGVsQnV0dG9uQmFyLmVtcHR5KClcclxuXHJcbiAgICB2YXIgZGVsQnRuID0gJCgnPGJ1dHRvbiBzdHlsZT1cIm1hcmdpbi1ib3R0b206MnB4XCIgY2xhc3M9XCJ3My1yaXBwbGUgdzMtYnV0dG9uIHczLWxpZ2h0LWdyYXkgdzMtaG92ZXItcGluayB3My1ib3JkZXItcmlnaHRcIj5EZWxldGUgTW9kZWw8L2J1dHRvbj4nKVxyXG4gICAgdGhpcy5tb2RlbEJ1dHRvbkJhci5hcHBlbmQoZGVsQnRuKVxyXG5cclxuXHJcbiAgICB2YXIgaW1wb3J0UGljQnRuID0gJCgnPGJ1dHRvbiBjbGFzcz1cInczLWJ1dHRvbiB3My1saWdodC1ncmF5IHczLWhvdmVyLWFtYmVyIHczLWJvcmRlci1yaWdodFwiPlVwbG9hZCBBdmFydGE8L2J1dHRvbj4nKVxyXG4gICAgdmFyIGFjdHVhbEltcG9ydFBpY0J0biA9ICQoJzxpbnB1dCB0eXBlPVwiZmlsZVwiIG5hbWU9XCJpbWdcIiBzdHlsZT1cImRpc3BsYXk6bm9uZVwiPjwvaW5wdXQ+JylcclxuICAgIHZhciBjaG9vc2VBdmFydGFCdG4gPSAkKCc8YnV0dG9uIGNsYXNzPVwidzMtcmlwcGxlIHczLWJ1dHRvbiB3My1saWdodC1ncmF5IHczLWhvdmVyLXBpbmsgdzMtYm9yZGVyLXJpZ2h0XCI+Q2hvb3NlIEEgU3ltYm9sPC9idXR0b24+JylcclxuICAgIFxyXG4gICAgdmFyIGNsZWFyQXZhcnRhQnRuID0gJCgnPGJ1dHRvbiBjbGFzcz1cInczLXJpcHBsZSB3My1idXR0b24gdzMtbGlnaHQtZ3JheSB3My1ob3Zlci1waW5rIHczLWJvcmRlci1yaWdodFwiPkNsZWFyIEF2YXJ0YTwvYnV0dG9uPicpXHJcbiAgICB0aGlzLm1vZGVsQnV0dG9uQmFyLmFwcGVuZChpbXBvcnRQaWNCdG4sIGFjdHVhbEltcG9ydFBpY0J0bixjaG9vc2VBdmFydGFCdG4sIGNsZWFyQXZhcnRhQnRuKVxyXG4gICAgaW1wb3J0UGljQnRuLm9uKFwiY2xpY2tcIiwgKCkgPT4ge1xyXG4gICAgICAgIGFjdHVhbEltcG9ydFBpY0J0bi50cmlnZ2VyKCdjbGljaycpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgYWN0dWFsSW1wb3J0UGljQnRuLmNoYW5nZShhc3luYyAoZXZ0KSA9PiB7XHJcbiAgICAgICAgdmFyIGZpbGVzID0gZXZ0LnRhcmdldC5maWxlczsgLy8gRmlsZUxpc3Qgb2JqZWN0XHJcbiAgICAgICAgdmFyIHRoZUZpbGUgPSBmaWxlc1swXVxyXG5cclxuICAgICAgICBpZiAodGhlRmlsZS50eXBlID09IFwiaW1hZ2Uvc3ZnK3htbFwiKSB7XHJcbiAgICAgICAgICAgIHZhciBzdHIgPSBhd2FpdCB0aGlzLnJlYWRPbmVGaWxlKHRoZUZpbGUpXHJcbiAgICAgICAgICAgIHZhciBkYXRhVXJsID0gJ2RhdGE6aW1hZ2Uvc3ZnK3htbDt1dGY4LCcgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHRoZUZpbGUudHlwZS5tYXRjaCgnaW1hZ2UuKicpKSB7XHJcbiAgICAgICAgICAgIHZhciBkYXRhVXJsID0gYXdhaXQgdGhpcy5yZXNpemVJbWdGaWxlKHRoZUZpbGUsIDI1NilcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgY29uZmlybURpYWxvZ0RpdiA9IG5ldyBzaW1wbGVDb25maXJtRGlhbG9nKClcclxuICAgICAgICAgICAgY29uZmlybURpYWxvZ0Rpdi5zaG93KHsgd2lkdGg6IFwiMjAwcHhcIiB9LFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcIk5vdGVcIlxyXG4gICAgICAgICAgICAgICAgICAgICwgY29udGVudDogXCJQbGVhc2UgaW1wb3J0IGltYWdlIGZpbGUgKHBuZyxqcGcsc3ZnIGFuZCBzbyBvbilcIlxyXG4gICAgICAgICAgICAgICAgICAgICwgYnV0dG9uczogW3sgY29sb3JDbGFzczogXCJ3My1ncmF5XCIsIHRleHQ6IFwiT2tcIiwgXCJjbGlja0Z1bmNcIjogKCkgPT4geyBjb25maXJtRGlhbG9nRGl2LmNsb3NlKCkgfSB9XVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudXBkYXRlQXZhcnRhRGF0YVVybChkYXRhVXJsLG1vZGVsSUQpXHJcbiAgICAgICAgYWN0dWFsSW1wb3J0UGljQnRuLnZhbChcIlwiKVxyXG4gICAgfSlcclxuXHJcbiAgICBjaG9vc2VBdmFydGFCdG4ub24oXCJjbGlja1wiLCgpPT57dGhpcy5jaG9vc2VBdmFydGEobW9kZWxJRCl9KVxyXG5cclxuICAgIGNsZWFyQXZhcnRhQnRuLm9uKFwiY2xpY2tcIiwgKCkgPT4ge1xyXG4gICAgICAgIHRoaXMudXBkYXRlQXZhcnRhRGF0YVVybChudWxsLG1vZGVsSUQpXHJcbiAgICB9KTtcclxuXHJcbiAgICBcclxuICAgIGRlbEJ0bi5vbihcImNsaWNrXCIsKCk9PntcclxuICAgICAgICB2YXIgcmVsYXRlZE1vZGVsSURzID1tb2RlbEFuYWx5emVyLmxpc3RNb2RlbHNGb3JEZWxldGVNb2RlbChtb2RlbElEKVxyXG4gICAgICAgIHZhciBkaWFsb2dTdHI9KHJlbGF0ZWRNb2RlbElEcy5sZW5ndGg9PTApPyAoXCJUaGlzIHdpbGwgREVMRVRFIG1vZGVsIFxcXCJcIiArIG1vZGVsSUQgKyBcIlxcXCIuXCIpOiBcclxuICAgICAgICAgICAgKG1vZGVsSUQgKyBcIiBpcyBiYXNlIG1vZGVsIG9mIFwiK3JlbGF0ZWRNb2RlbElEcy5qb2luKFwiLCBcIikrXCIuXCIpXHJcbiAgICAgICAgdmFyIGNvbmZpcm1EaWFsb2dEaXYgPSBuZXcgc2ltcGxlQ29uZmlybURpYWxvZygpXHJcblxyXG4gICAgICAgIC8vY2hlY2sgaG93IG1hbnkgdHdpbnMgYXJlIHVuZGVyIHRoaXMgbW9kZWwgSURcclxuICAgICAgICB2YXIgbnVtYmVyT2ZUd2lucz0wXHJcbiAgICAgICAgdmFyIGNoZWNrVHdpbnNNb2RlbEFycj1bbW9kZWxJRF0uY29uY2F0KHJlbGF0ZWRNb2RlbElEcylcclxuICAgICAgICBmb3IodmFyIG9uZVR3aW5JRCBpbiBnbG9iYWxDYWNoZS5EQlR3aW5zKXtcclxuICAgICAgICAgICAgdmFyIG9uZURCVHdpbiA9IGdsb2JhbENhY2hlLkRCVHdpbnNbb25lVHdpbklEXVxyXG4gICAgICAgICAgICB2YXIgdGhlSW5kZXg9Y2hlY2tUd2luc01vZGVsQXJyLmluZGV4T2Yob25lREJUd2luW1wibW9kZWxJRFwiXSlcclxuICAgICAgICAgICAgaWYodGhlSW5kZXghPS0xKSBudW1iZXJPZlR3aW5zKytcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRpYWxvZ1N0cis9XCIgKFRoZXJlIHdpbGwgYmUgXCIrKChudW1iZXJPZlR3aW5zPjEpPyhudW1iZXJPZlR3aW5zK1wiIHR3aW5zXCIpOihudW1iZXJPZlR3aW5zK1wiIHR3aW5cIikgKSArIFwiIGJlaW5nIGltcGFjdGVkKVwiXHJcbiAgICAgICAgY29uZmlybURpYWxvZ0Rpdi5zaG93KFxyXG4gICAgICAgICAgICB7IHdpZHRoOiBcIjM1MHB4XCIgfSxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGl0bGU6IFwiV2FybmluZ1wiXHJcbiAgICAgICAgICAgICAgICAsIGNvbnRlbnQ6IGRpYWxvZ1N0clxyXG4gICAgICAgICAgICAgICAgLCBidXR0b25zOiBbXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvckNsYXNzOiBcInczLXJlZCB3My1ob3Zlci1waW5rXCIsIHRleHQ6IFwiQ29uZmlybVwiLCBcImNsaWNrRnVuY1wiOiBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maXJtRGlhbG9nRGl2LmNsb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpcm1EZWxldGVNb2RlbChtb2RlbElEKSBcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvckNsYXNzOiBcInczLWdyYXlcIiwgdGV4dDogXCJDYW5jZWxcIiwgXCJjbGlja0Z1bmNcIjogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlybURpYWxvZ0Rpdi5jbG9zZSgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICApXHJcbiAgICAgICAgXHJcbiAgICB9KVxyXG4gICAgXHJcbiAgICB2YXIgVmlzdWFsaXphdGlvbkRPTT10aGlzLmFkZEFQYXJ0SW5SaWdodFNwYW4oXCJWaXN1YWxpemF0aW9uXCIse1wibWFyZ2luVG9wXCI6MH0pIFxyXG4gICAgdmFyIGVkaXRhYmxlUHJvcGVydGllc0RPTT10aGlzLmFkZEFQYXJ0SW5SaWdodFNwYW4oXCJFZGl0YWJsZSBQcm9wZXJ0aWVzIEFuZCBSZWxhdGlvbnNoaXBzXCIpXHJcbiAgICB2YXIgYmFzZUNsYXNzZXNET009dGhpcy5hZGRBUGFydEluUmlnaHRTcGFuKFwiQmFzZSBDbGFzc2VzXCIpXHJcbiAgICB2YXIgb3JpZ2luYWxEZWZpbml0aW9uRE9NPXRoaXMuYWRkQVBhcnRJblJpZ2h0U3BhbihcIk9yaWdpbmFsIERlZmluaXRpb25cIilcclxuXHJcbiAgICB2YXIgc3RyPUpTT04uc3RyaW5naWZ5KEpTT04ucGFyc2UobW9kZWxBbmFseXplci5EVERMTW9kZWxzW21vZGVsSURdW1wib3JpZ2luYWxcIl0pLG51bGwsMilcclxuICAgIG9yaWdpbmFsRGVmaW5pdGlvbkRPTS5hcHBlbmQoJCgnPHByZSBpZD1cImpzb25cIj4nK3N0cisnPC9wcmU+JykpXHJcblxyXG4gICAgdmFyIGVkaXR0YWJsZVByb3BlcnRpZXM9bW9kZWxBbmFseXplci5EVERMTW9kZWxzW21vZGVsSURdLmVkaXRhYmxlUHJvcGVydGllc1xyXG4gICAgdGhpcy5maWxsRWRpdGFibGVQcm9wZXJ0aWVzKGVkaXR0YWJsZVByb3BlcnRpZXMsZWRpdGFibGVQcm9wZXJ0aWVzRE9NKVxyXG4gICAgdmFyIHZhbGlkUmVsYXRpb25zaGlwcz1tb2RlbEFuYWx5emVyLkRURExNb2RlbHNbbW9kZWxJRF0udmFsaWRSZWxhdGlvbnNoaXBzXHJcbiAgICB0aGlzLmZpbGxSZWxhdGlvbnNoaXBJbmZvKHZhbGlkUmVsYXRpb25zaGlwcyxlZGl0YWJsZVByb3BlcnRpZXNET00pXHJcblxyXG4gICAgdGhpcy5maWxsVmlzdWFsaXphdGlvbihtb2RlbElELFZpc3VhbGl6YXRpb25ET00pXHJcblxyXG4gICAgdGhpcy5maWxsQmFzZUNsYXNzZXMobW9kZWxBbmFseXplci5EVERMTW9kZWxzW21vZGVsSURdLmFsbEJhc2VDbGFzc2VzLGJhc2VDbGFzc2VzRE9NKSBcclxufVxyXG5cclxubW9kZWxNYW5hZ2VyRGlhbG9nLnByb3RvdHlwZS51cGRhdGVBdmFydGFEYXRhVXJsID0gZnVuY3Rpb24gKGRhdGFVcmwsbW9kZWxJRCkge1xyXG4gICAgaWYgKCFkYXRhVXJsKXtcclxuICAgICAgICB2YXIgdmlzdWFsSnNvbiA9IGdsb2JhbENhY2hlLnZpc3VhbERlZmluaXRpb25bXCJkZWZhdWx0XCJdLmRldGFpbFxyXG4gICAgICAgIGlmICh2aXN1YWxKc29uW21vZGVsSURdKXtcclxuICAgICAgICAgICAgZGVsZXRlIHZpc3VhbEpzb25bbW9kZWxJRF0uYXZhcnRhXHJcbiAgICAgICAgICAgIGRlbGV0ZSB2aXN1YWxKc29uW21vZGVsSURdLmF2YXJ0YVdpZHRoXHJcbiAgICAgICAgICAgIGRlbGV0ZSB2aXN1YWxKc29uW21vZGVsSURdLmF2YXJ0YUhlaWdodFxyXG4gICAgICAgIH0gXHJcbiAgICAgICAgaWYgKHRoaXMuYXZhcnRhSW1nKSB0aGlzLmF2YXJ0YUltZy5yZW1vdmVBdHRyKCdzcmMnKTtcclxuICAgICAgICB0aGlzLnNhdmVWaXN1YWxEZWZpbml0aW9uKClcclxuICAgICAgICB0aGlzLmJyb2FkY2FzdE1lc3NhZ2UoeyBcIm1lc3NhZ2VcIjogXCJ2aXN1YWxEZWZpbml0aW9uQ2hhbmdlXCIsIFwibW9kZWxJRFwiOiBtb2RlbElELCBcIm5vQXZhcnRhXCI6IHRydWUgfSlcclxuICAgICAgICB0aGlzLnJlZnJlc2hNb2RlbFRyZWVMYWJlbCgpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfSBcclxuICAgIFxyXG4gICAgLy9pZiBpdCBpcyBzdmcsIGNoZWNrIGlmIHRoZSBzdmcgc2V0IGl0cyB3aWR0aCBhbmQgaGVpZ2h0IGF0dHJpYnV0ZSwgYXMgY3l0b3NjYXBlIGpzIGNhbiBub3QgaGFuZGxlIHN2ZyBzY2FsaW5nIHdpdGhvdXRoIHdpZHRoIGFuZCBoZWlnaCBhdHRyaWJ1dGVcclxuICAgIHZhciBkZWM9IGRlY29kZVVSSUNvbXBvbmVudChkYXRhVXJsKVxyXG4gICAgaWYoZGVjLnN0YXJ0c1dpdGgoXCJkYXRhOmltYWdlL3N2Zyt4bWxcIikpe1xyXG4gICAgICAgIHZhciBwb3M9ZGVjLmluZGV4T2YoXCI8c3ZnIFwiKVxyXG4gICAgICAgIHZhciBzdmdQYXJ0PWRlYy5zdWJzdHIocG9zKVxyXG4gICAgICAgIHZhciB0bXBPYmo9JChzdmdQYXJ0KVxyXG4gICAgICAgIGlmKHRtcE9iai5hdHRyKCd3aWR0aCcpPT1udWxsKXtcclxuICAgICAgICAgICAgdmFyIHNzPXRtcE9iai5hdHRyKCd2aWV3Qm94JylcclxuICAgICAgICAgICAgaWYoc3Mpe1xyXG4gICAgICAgICAgICAgICAgdmFyIGFycj1zcy5zcGxpdChcIiBcIilcclxuICAgICAgICAgICAgICAgIHRtcE9iai5hdHRyKFwid2lkdGhcIixhcnJbMl0tYXJyWzBdKVxyXG4gICAgICAgICAgICAgICAgdG1wT2JqLmF0dHIoXCJoZWlnaHRcIixhcnJbM10tYXJyWzFdKVxyXG4gICAgICAgICAgICAgICAgZGF0YVVybD1gZGF0YTppbWFnZS9zdmcreG1sO3V0ZjgsJHtlbmNvZGVVUklDb21wb25lbnQodG1wT2JqWzBdLm91dGVySFRNTCl9YFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLmF2YXJ0YUltZykgdGhpcy5hdmFydGFJbWcuYXR0cihcInNyY1wiLCBkYXRhVXJsKVxyXG5cclxuICAgIHZhciB2aXN1YWxKc29uID0gZ2xvYmFsQ2FjaGUudmlzdWFsRGVmaW5pdGlvbltcImRlZmF1bHRcIl0uZGV0YWlsIC8vY3VycmVudGx5IHRoZXJlIGlzIG9ubHkgb25lIHZpc3VhbCBkZWZpbml0aW9uOiBcImRlZmF1bHRcIlxyXG4gICAgaWYgKCF2aXN1YWxKc29uW21vZGVsSURdKSB2aXN1YWxKc29uW21vZGVsSURdID0ge31cclxuICAgIHZpc3VhbEpzb25bbW9kZWxJRF0uYXZhcnRhID0gZGF0YVVybFxyXG4gICAgXHJcbiAgICB2YXIgdGVzdEltZyA9ICQoYDxpbWcgc3JjPVwiJHtkYXRhVXJsfVwiLz5gKVxyXG4gICAgdGVzdEltZy5vbignbG9hZCcsICgpPT57XHJcbiAgICAgICAgdGVzdEltZy5jc3Moe1wiZGlzcGxheVwiOlwibm9uZVwifSkgLy90byBnZXQgdGhlIGltYWdlIHNpemUsIGFwcGVuZCBpdCB0byBib2R5IHRlbXBvcmFyaWx5XHJcbiAgICAgICAgJCgnYm9keScpLmFwcGVuZCh0ZXN0SW1nKVxyXG4gICAgICAgIHZpc3VhbEpzb25bbW9kZWxJRF0uYXZhcnRhV2lkdGg9dGVzdEltZy53aWR0aCgpXHJcbiAgICAgICAgdmlzdWFsSnNvblttb2RlbElEXS5hdmFydGFIZWlnaHQ9dGVzdEltZy5oZWlnaHQoKVxyXG4gICAgICAgIHRlc3RJbWcucmVtb3ZlKClcclxuICAgICAgICB0aGlzLnNhdmVWaXN1YWxEZWZpbml0aW9uKClcclxuICAgICAgICB0aGlzLmJyb2FkY2FzdE1lc3NhZ2UoeyBcIm1lc3NhZ2VcIjogXCJ2aXN1YWxEZWZpbml0aW9uQ2hhbmdlXCIsIFwibW9kZWxJRFwiOiBtb2RlbElELCBcImF2YXJ0YVwiOiBkYXRhVXJsIH0pXHJcbiAgICAgICAgdGhpcy5yZWZyZXNoTW9kZWxUcmVlTGFiZWwoKVxyXG4gICAgfSk7XHJcbn1cclxuXHJcbm1vZGVsTWFuYWdlckRpYWxvZy5wcm90b3R5cGUuY2hvb3NlQXZhcnRhPWZ1bmN0aW9uKG1vZGVsSUQpe1xyXG4gICAgdmFyIHBvcFdpbmRvdz1uZXcgc2ltcGxlQ29uZmlybURpYWxvZygpXHJcbiAgICBwb3BXaW5kb3cuc2hvdyh7XCJtYXgtd2lkdGhcIjpcIjQ1MHB4XCIsXCJtaW4td2lkdGhcIjpcIjMwMHB4XCJ9LHtcclxuICAgICAgICBcInRpdGxlXCI6XCJDaG9vc2UgU3ltYm9sIGFzIEF2YXJ0YVwiLFxyXG4gICAgICAgIFwiY3VzdG9tRHJhd2luZ1wiOihwYXJlbnRET00pPT57XHJcbiAgICAgICAgICAgIGZvcih2YXIgaW5kIGluIGdsb2JhbENhY2hlLnN5bWJvbExpYnMpIHZhciBzeW1ib2xMaXN0PWdsb2JhbENhY2hlLnN5bWJvbExpYnNbaW5kXSAvL1RPRE86bXVsdGlwbGUgbGlic1xyXG4gICAgICAgICAgICBmb3IodmFyIHN5bWJvbE5hbWUgaW4gc3ltYm9sTGlzdCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZVN5bWJvbERPTShpbmQsc3ltYm9sTmFtZSxtb2RlbElELHBhcmVudERPTSxwb3BXaW5kb3cpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KVxyXG59XHJcblxyXG5tb2RlbE1hbmFnZXJEaWFsb2cucHJvdG90eXBlLmNyZWF0ZVN5bWJvbERPTT1mdW5jdGlvbihsaWJOYW1lLHN5bWJvbE5hbWUsbW9kZWxJRCxwYXJlbnRET00scG9wV2luZG93KXtcclxuICAgIHZhciBzeW1ib2xTaXplPTgwXHJcbiAgICB2YXIgc3ltYm9sTGlzdD1nbG9iYWxDYWNoZS5zeW1ib2xMaWJzW2xpYk5hbWVdXHJcbiAgICB2YXIgYVN5bWJvbERPTT0kKFwiPGRpdiBjbGFzcz0ndzMtYnV0dG9uIHczLXdoaXRlJyBzdHlsZT0ncGFkZGluZzowcHg7d2lkdGg6XCIrc3ltYm9sU2l6ZStcInB4O2hlaWdodDpcIitzeW1ib2xTaXplK1wicHg7ZmxvYXQ6bGVmdCc+PC9kaXY+XCIpXHJcbiAgICB2YXIgc3ZnU3RyPXN5bWJvbExpc3Rbc3ltYm9sTmFtZV0ucmVwbGFjZUFsbChcIidcIiwnXCInKVxyXG4gICAgdmFyIGRhdGFVcmw9YGRhdGE6aW1hZ2Uvc3ZnK3htbDt1dGY4LCR7ZW5jb2RlVVJJQ29tcG9uZW50KHN2Z1N0cil9YFxyXG4gICAgdmFyIHN2Z0ltZz0kKGA8aW1nIHN0eWxlPSdtYXgtd2lkdGg6JHtzeW1ib2xTaXplfXB4O21heC1oZWlnaHQ6JHtzeW1ib2xTaXplfXB4JyBzcmM9JyR7ZGF0YVVybH0nPjwvaW1nPmApXHJcbiAgICBhU3ltYm9sRE9NLmFwcGVuZChzdmdJbWcpXHJcbiAgICBwYXJlbnRET00uYXBwZW5kKGFTeW1ib2xET00pXHJcbiAgICBhU3ltYm9sRE9NLm9uKFwiY2xpY2tcIiwoKT0+e1xyXG4gICAgICAgIHBvcFdpbmRvdy5jbG9zZSgpXHJcbiAgICAgICAgdGhpcy51cGRhdGVBdmFydGFEYXRhVXJsKGRhdGFVcmwsbW9kZWxJRClcclxuICAgIH0pXHJcbn1cclxuXHJcbm1vZGVsTWFuYWdlckRpYWxvZy5wcm90b3R5cGUuY29uZmlybURlbGV0ZU1vZGVsPWZ1bmN0aW9uKG1vZGVsSUQpe1xyXG4gICAgdmFyIGZ1bmNBZnRlckVhY2hTdWNjZXNzRGVsZXRlID0gKGVhY2hEZWxldGVkTW9kZWxJRCkgPT4ge1xyXG4gICAgICAgIHRoaXMudHJlZS5kZWxldGVMZWFmTm9kZShnbG9iYWxDYWNoZS5tb2RlbElETWFwVG9OYW1lW2VhY2hEZWxldGVkTW9kZWxJRF0pXHJcbiAgICAgICAgLy9UT0RPOiBjbGVhciB0aGUgdmlzdWFsaXphdGlvbiBzZXR0aW5nIG9mIHRoaXMgZGVsZXRlZCBtb2RlbCwgYnV0IGlmIGl0IGlzIHJlcGxhY2UsIHNob3VsZCBub3QsIHNvIEkgY29tbWVudCBvdXQgZmlyc3RcclxuICAgICAgICAvKlxyXG4gICAgICAgIGlmIChnbG9iYWxDYWNoZS52aXN1YWxEZWZpbml0aW9uW1wiZGVmYXVsdFwiXS5kZXRhaWxbbW9kZWxJRF0pIHtcclxuICAgICAgICAgICAgZGVsZXRlIGdsb2JhbENhY2hlLnZpc3VhbERlZmluaXRpb25bXCJkZWZhdWx0XCJdLmRldGFpbFttb2RlbElEXVxyXG4gICAgICAgICAgICB0aGlzLnNhdmVWaXN1YWxEZWZpbml0aW9uKClcclxuICAgICAgICB9Ki9cclxuICAgIH1cclxuICAgIHZhciBjb21wbGV0ZUZ1bmM9KCk9PnsgXHJcbiAgICAgICAgdGhpcy5icm9hZGNhc3RNZXNzYWdlKHsgXCJtZXNzYWdlXCI6IFwiQURUTW9kZWxzQ2hhbmdlXCJ9KVxyXG4gICAgICAgIHRoaXMucGFuZWxDYXJkLmVtcHR5KClcclxuICAgIH1cclxuXHJcbiAgICAvL2V2ZW4gbm90IGNvbXBsZXRlbHkgc3VjY2Vzc2Z1bCBkZWxldGluZywgaXQgd2lsbCBzdGlsbCBpbnZva2UgY29tcGxldGVGdW5jXHJcbiAgICBtb2RlbEFuYWx5emVyLmRlbGV0ZU1vZGVsKG1vZGVsSUQsZnVuY0FmdGVyRWFjaFN1Y2Nlc3NEZWxldGUsY29tcGxldGVGdW5jLGNvbXBsZXRlRnVuYylcclxufVxyXG5cclxubW9kZWxNYW5hZ2VyRGlhbG9nLnByb3RvdHlwZS5yZWZyZXNoTW9kZWxUcmVlTGFiZWw9ZnVuY3Rpb24oKXtcclxuICAgIGlmKHRoaXMudHJlZS5zZWxlY3RlZE5vZGVzLmxlbmd0aD4wKSB0aGlzLnRyZWUuc2VsZWN0ZWROb2Rlc1swXS5yZWRyYXdMYWJlbCgpXHJcbn1cclxuXHJcbm1vZGVsTWFuYWdlckRpYWxvZy5wcm90b3R5cGUuZmlsbEJhc2VDbGFzc2VzPWZ1bmN0aW9uKGJhc2VDbGFzc2VzLHBhcmVudERvbSl7XHJcbiAgICBmb3IodmFyIGluZCBpbiBiYXNlQ2xhc3Nlcyl7XHJcbiAgICAgICAgdmFyIGtleURpdj0gJChcIjxsYWJlbCBzdHlsZT0nZGlzcGxheTpibG9jaztwYWRkaW5nOi4xZW0nPlwiK2luZCtcIjwvbGFiZWw+XCIpXHJcbiAgICAgICAgcGFyZW50RG9tLmFwcGVuZChrZXlEaXYpXHJcbiAgICB9XHJcbn1cclxuXHJcbm1vZGVsTWFuYWdlckRpYWxvZy5wcm90b3R5cGUuZmlsbFZpc3VhbGl6YXRpb249ZnVuY3Rpb24obW9kZWxJRCxwYXJlbnREb20pe1xyXG4gICAgdmFyIG1vZGVsSnNvbj1tb2RlbEFuYWx5emVyLkRURExNb2RlbHNbbW9kZWxJRF07XHJcbiAgICB2YXIgYVRhYmxlPSQoXCI8dGFibGUgc3R5bGU9J3dpZHRoOjEwMCUnPjwvdGFibGU+XCIpXHJcbiAgICBhVGFibGUuaHRtbCgnPHRyPjx0ZD48L3RkPjx0ZCBhbGlnbj1cImNlbnRlclwiPjwvdGQ+PC90cj4nKVxyXG4gICAgcGFyZW50RG9tLmFwcGVuZChhVGFibGUpIFxyXG5cclxuICAgIHZhciBsZWZ0UGFydD1hVGFibGUuZmluZChcInRkOmZpcnN0XCIpXHJcbiAgICB2YXIgcmlnaHRQYXJ0PWFUYWJsZS5maW5kKFwidGQ6bnRoLWNoaWxkKDIpXCIpXHJcbiAgICByaWdodFBhcnQuY3NzKHtcIndpZHRoXCI6XCI1MHB4XCIsXCJoZWlnaHRcIjpcIjUwcHhcIixcImJvcmRlclwiOlwic29saWQgMXB4IGxpZ2h0R3JheVwifSlcclxuICAgIFxyXG4gICAgdmFyIGF2YXJ0YUltZz0kKFwiPGltZyBzdHlsZT0naGVpZ2h0OjQ1cHgnPjwvaW1nPlwiKVxyXG4gICAgcmlnaHRQYXJ0LmFwcGVuZChhdmFydGFJbWcpXHJcbiAgICB2YXIgdmlzdWFsSnNvbj1nbG9iYWxDYWNoZS52aXN1YWxEZWZpbml0aW9uW1wiZGVmYXVsdFwiXS5kZXRhaWxcclxuICAgIGlmKHZpc3VhbEpzb24gJiYgdmlzdWFsSnNvblttb2RlbElEXSAmJiB2aXN1YWxKc29uW21vZGVsSURdLmF2YXJ0YSkgYXZhcnRhSW1nLmF0dHIoJ3NyYycsdmlzdWFsSnNvblttb2RlbElEXS5hdmFydGEpXHJcbiAgICB0aGlzLmF2YXJ0YUltZz1hdmFydGFJbWc7XHJcbiAgICB0aGlzLmFkZE9uZVZpc3VhbGl6YXRpb25Sb3cobW9kZWxJRCxsZWZ0UGFydClcclxuXHJcbiAgICBpZih0aGlzLnNob3dSZWxhdGlvblZpc3VhbGl6YXRpb25TZXR0aW5ncyl7XHJcbiAgICAgICAgZm9yKHZhciBpbmQgaW4gbW9kZWxKc29uLnZhbGlkUmVsYXRpb25zaGlwcyl7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkT25lVmlzdWFsaXphdGlvblJvdyhtb2RlbElELGxlZnRQYXJ0LGluZClcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB0aGlzLmFkZExhYmVsVmlzdWFsaXphdGlvblJvdyhtb2RlbElELGxlZnRQYXJ0KVxyXG59XHJcblxyXG5tb2RlbE1hbmFnZXJEaWFsb2cucHJvdG90eXBlLmFkZExhYmVsVmlzdWFsaXphdGlvblJvdz1mdW5jdGlvbihtb2RlbElELHBhcmVudERvbSl7XHJcbiAgICB2YXIgY29udGFpbmVyRGl2PSQoXCI8ZGl2IHN0eWxlPSdwYWRkaW5nLWJvdHRvbTo4cHgnPjwvZGl2PlwiKVxyXG4gICAgcGFyZW50RG9tLmFwcGVuZChjb250YWluZXJEaXYpXHJcbiAgICB2YXIgY29udGVudERPTT0kKFwiPGxhYmVsIGNsYXNzPSd3My10ZXh0LWdyYXknIHN0eWxlPSdtYXJnaW4tcmlnaHQ6MTBweDtmb250LXN0eWxlOml0YWxpYzsgZm9udC13ZWlnaHQ6Ym9sZDtmb250LXNpemU6MC45ZW0nPlBvc2l0aW9uIExhYmVsPC9sYWJlbD5cIilcclxuICAgIGNvbnRhaW5lckRpdi5hcHBlbmQoY29udGVudERPTSlcclxuICAgIHZhciBkZWZpbmVkTGJsWD0wXHJcbiAgICB2YXIgZGVmaW5lZExibFk9MFxyXG4gICAgdmFyIHZpc3VhbEpzb249Z2xvYmFsQ2FjaGUudmlzdWFsRGVmaW5pdGlvbltcImRlZmF1bHRcIl0uZGV0YWlsXHJcbiAgICBpZih2aXN1YWxKc29uW21vZGVsSURdICYmIHZpc3VhbEpzb25bbW9kZWxJRF0ubGFiZWxYKSBkZWZpbmVkTGJsWD12aXN1YWxKc29uW21vZGVsSURdLmxhYmVsWFxyXG4gICAgaWYodmlzdWFsSnNvblttb2RlbElEXSAmJiB2aXN1YWxKc29uW21vZGVsSURdLmxhYmVsWSkgZGVmaW5lZExibFk9dmlzdWFsSnNvblttb2RlbElEXS5sYWJlbFlcclxuICAgIHZhciBsYmxYQWRqdXN0U2VsZWN0b3IgPSAkKCc8c2VsZWN0IGNsYXNzPVwidzMtYm9yZGVyXCIgc3R5bGU9XCJvdXRsaW5lOm5vbmU7d2lkdGg6MTEwcHhcIj48L3NlbGVjdD4nKVxyXG4gICAgZm9yKHZhciBmPS0yNTtmPD0zMDtmKz01KXtcclxuICAgICAgICB2YXIgdmFsPWYudG9GaXhlZCgwKStcIlwiXHJcbiAgICAgICAgbGJsWEFkanVzdFNlbGVjdG9yLmFwcGVuZCgkKFwiPG9wdGlvbiB2YWx1ZT1cIit2YWwrXCI+eG9mZjpcIit2YWwrXCI8L29wdGlvbj5cIikpXHJcbiAgICB9XHJcbiAgICBpZihkZWZpbmVkTGJsWCE9bnVsbCkgbGJsWEFkanVzdFNlbGVjdG9yLnZhbChkZWZpbmVkTGJsWClcclxuICAgIGVsc2UgbGJsWEFkanVzdFNlbGVjdG9yLnZhbChcIjBcIilcclxuICAgIGNvbnRhaW5lckRpdi5hcHBlbmQobGJsWEFkanVzdFNlbGVjdG9yKVxyXG4gICAgdmFyIGxibFlBZGp1c3RTZWxlY3RvciA9ICQoJzxzZWxlY3QgY2xhc3M9XCJ3My1ib3JkZXJcIiBzdHlsZT1cIm91dGxpbmU6bm9uZTt3aWR0aDoxMTBweFwiPjwvc2VsZWN0PicpXHJcbiAgICBmb3IodmFyIGY9LTI1O2Y8PTMwO2YrPTUpe1xyXG4gICAgICAgIHZhciB2YWw9Zi50b0ZpeGVkKDApK1wiXCJcclxuICAgICAgICBsYmxZQWRqdXN0U2VsZWN0b3IuYXBwZW5kKCQoXCI8b3B0aW9uIHZhbHVlPVwiK3ZhbCtcIj55b2ZmOlwiK3ZhbCtcIjwvb3B0aW9uPlwiKSlcclxuICAgIH1cclxuICAgIGlmKGRlZmluZWRMYmxZIT1udWxsKSBsYmxZQWRqdXN0U2VsZWN0b3IudmFsKGRlZmluZWRMYmxZKVxyXG4gICAgZWxzZSBsYmxZQWRqdXN0U2VsZWN0b3IudmFsKFwiMFwiKVxyXG4gICAgY29udGFpbmVyRGl2LmFwcGVuZChsYmxZQWRqdXN0U2VsZWN0b3IpXHJcblxyXG4gICAgbGJsWEFkanVzdFNlbGVjdG9yLmNoYW5nZSgoZXZlKT0+e1xyXG4gICAgICAgIHZhciBjaG9vc2VWYWw9ZXZlLnRhcmdldC52YWx1ZVxyXG4gICAgICAgIHRoaXMubW9kaWZ5TGJsT2Zmc2V0KFwibGFiZWxYXCIsY2hvb3NlVmFsLG1vZGVsSUQpXHJcbiAgICB9KVxyXG4gICAgbGJsWUFkanVzdFNlbGVjdG9yLmNoYW5nZSgoZXZlKT0+e1xyXG4gICAgICAgIHZhciBjaG9vc2VWYWw9ZXZlLnRhcmdldC52YWx1ZVxyXG4gICAgICAgIHRoaXMubW9kaWZ5TGJsT2Zmc2V0KFwibGFiZWxZXCIsY2hvb3NlVmFsLG1vZGVsSUQpXHJcbiAgICB9KVxyXG59XHJcblxyXG5tb2RlbE1hbmFnZXJEaWFsb2cucHJvdG90eXBlLm1vZGlmeUxibE9mZnNldCA9IGZ1bmN0aW9uIChYWSwgdmFsLG1vZGVsSUQpIHtcclxuICAgIHZhciB2aXN1YWxKc29uID0gZ2xvYmFsQ2FjaGUudmlzdWFsRGVmaW5pdGlvbltcImRlZmF1bHRcIl0uZGV0YWlsXHJcbiAgICBpZiAoIXZpc3VhbEpzb25bbW9kZWxJRF0pIHZpc3VhbEpzb25bbW9kZWxJRF0gPSB7fVxyXG4gICAgdmlzdWFsSnNvblttb2RlbElEXVtYWV0gPSB2YWxcclxuICAgIHRoaXMuYnJvYWRjYXN0TWVzc2FnZSh7IFwibWVzc2FnZVwiOiBcInZpc3VhbERlZmluaXRpb25DaGFuZ2VcIiwgXCJtb2RlbElEXCI6IG1vZGVsSUQsIFwibGFiZWxQb3NpdGlvblwiOnRydWUgfSlcclxuICAgIHRoaXMuc2F2ZVZpc3VhbERlZmluaXRpb24oKVxyXG59XHJcblxyXG5tb2RlbE1hbmFnZXJEaWFsb2cucHJvdG90eXBlLmFkZE9uZVZpc3VhbGl6YXRpb25Sb3c9ZnVuY3Rpb24obW9kZWxJRCxwYXJlbnREb20scmVsYXRpbnNoaXBOYW1lKXtcclxuICAgIGlmKHJlbGF0aW5zaGlwTmFtZT09bnVsbCkgdmFyIG5hbWVTdHI9XCLil69cIiAvL3Zpc3VhbCBmb3Igbm9kZVxyXG4gICAgZWxzZSBuYW1lU3RyPVwi4p+cIFwiK3JlbGF0aW5zaGlwTmFtZVxyXG4gICAgdmFyIGNvbnRhaW5lckRpdj0kKFwiPGRpdiBzdHlsZT0ncGFkZGluZy1ib3R0b206OHB4Jz48L2Rpdj5cIilcclxuICAgIHBhcmVudERvbS5hcHBlbmQoY29udGFpbmVyRGl2KVxyXG4gICAgdmFyIGNvbnRlbnRET009JChcIjxsYWJlbCBjbGFzcz0ndzMtdGV4dC1ncmF5JyBzdHlsZT0nbWFyZ2luLXJpZ2h0OjEwcHg7Zm9udC13ZWlnaHQ6Ym9sZDtmb250LXNpemU6MC45ZW0nPlwiK25hbWVTdHIrXCI8L2xhYmVsPlwiKVxyXG4gICAgY29udGFpbmVyRGl2LmFwcGVuZChjb250ZW50RE9NKVxyXG5cclxuICAgIHZhciBkZWZpbmVkQ29sb3I9bnVsbFxyXG4gICAgdmFyIGRlZmluZWRDb2xvcjI9bnVsbFxyXG4gICAgdmFyIGRlZmluZWRTaGFwZT1udWxsXHJcbiAgICB2YXIgZGVmaW5lZERpbWVuc2lvblJhdGlvPW51bGxcclxuICAgIHZhciBkZWZpbmVkRWRnZVdpZHRoPW51bGxcclxuICAgIHZhciB2aXN1YWxKc29uPWdsb2JhbENhY2hlLnZpc3VhbERlZmluaXRpb25bXCJkZWZhdWx0XCJdLmRldGFpbFxyXG4gICAgaWYocmVsYXRpbnNoaXBOYW1lPT1udWxsKXtcclxuICAgICAgICBpZih2aXN1YWxKc29uW21vZGVsSURdICYmIHZpc3VhbEpzb25bbW9kZWxJRF0uY29sb3IpIGRlZmluZWRDb2xvcj12aXN1YWxKc29uW21vZGVsSURdLmNvbG9yXHJcbiAgICAgICAgaWYodmlzdWFsSnNvblttb2RlbElEXSAmJiB2aXN1YWxKc29uW21vZGVsSURdLnNlY29uZENvbG9yKSBkZWZpbmVkQ29sb3IyPXZpc3VhbEpzb25bbW9kZWxJRF0uc2Vjb25kQ29sb3JcclxuICAgICAgICBpZih2aXN1YWxKc29uW21vZGVsSURdICYmIHZpc3VhbEpzb25bbW9kZWxJRF0uc2hhcGUpIGRlZmluZWRTaGFwZT12aXN1YWxKc29uW21vZGVsSURdLnNoYXBlXHJcbiAgICAgICAgaWYodmlzdWFsSnNvblttb2RlbElEXSAmJiB2aXN1YWxKc29uW21vZGVsSURdLmRpbWVuc2lvblJhdGlvKSBkZWZpbmVkRGltZW5zaW9uUmF0aW89dmlzdWFsSnNvblttb2RlbElEXS5kaW1lbnNpb25SYXRpb1xyXG4gICAgfWVsc2V7XHJcbiAgICAgICAgaWYgKHZpc3VhbEpzb25bbW9kZWxJRF0gJiYgdmlzdWFsSnNvblttb2RlbElEXVtcInJlbHNcIl0gJiYgdmlzdWFsSnNvblttb2RlbElEXVtcInJlbHNcIl1bcmVsYXRpbnNoaXBOYW1lXSkge1xyXG4gICAgICAgICAgICBpZiAodmlzdWFsSnNvblttb2RlbElEXVtcInJlbHNcIl1bcmVsYXRpbnNoaXBOYW1lXS5jb2xvcikgZGVmaW5lZENvbG9yID0gdmlzdWFsSnNvblttb2RlbElEXVtcInJlbHNcIl1bcmVsYXRpbnNoaXBOYW1lXS5jb2xvclxyXG4gICAgICAgICAgICBpZiAodmlzdWFsSnNvblttb2RlbElEXVtcInJlbHNcIl1bcmVsYXRpbnNoaXBOYW1lXS5zaGFwZSkgZGVmaW5lZFNoYXBlID0gdmlzdWFsSnNvblttb2RlbElEXVtcInJlbHNcIl1bcmVsYXRpbnNoaXBOYW1lXS5zaGFwZVxyXG4gICAgICAgICAgICBpZih2aXN1YWxKc29uW21vZGVsSURdW1wicmVsc1wiXVtyZWxhdGluc2hpcE5hbWVdLmVkZ2VXaWR0aCkgZGVmaW5lZEVkZ2VXaWR0aD12aXN1YWxKc29uW21vZGVsSURdW1wicmVsc1wiXVtyZWxhdGluc2hpcE5hbWVdLmVkZ2VXaWR0aFxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgY3JlYXRlQUNvbG9yU2VsZWN0b3I9KHByZWRlZmluZWRDb2xvcixuYW1lT2ZDb2xvckZpZWxkKT0+e1xyXG4gICAgICAgIHZhciBjb2xvclNlbGVjdG9yPSQoJzxzZWxlY3QgY2xhc3M9XCJ3My1ib3JkZXJcIiBzdHlsZT1cIm91dGxpbmU6bm9uZTt3aWR0aDo3NXB4XCI+PC9zZWxlY3Q+JylcclxuICAgICAgICBjb250YWluZXJEaXYuYXBwZW5kKGNvbG9yU2VsZWN0b3IpXHJcblxyXG4gICAgICAgIHZhciBjb2xvckFycj1bXCJkYXJrR3JheVwiLFwiQmxhY2tcIixcIkxpZ2h0R3JheVwiLFwiUmVkXCIsXCJHcmVlblwiLFwiQmx1ZVwiLFwiQmlzcXVlXCIsXCJCcm93blwiLFwiQ29yYWxcIixcIkNyaW1zb25cIixcIkRvZGdlckJsdWVcIixcIkdvbGRcIl1cclxuICAgICAgICBjb2xvckFyci5mb3JFYWNoKChvbmVDb2xvckNvZGUpPT57XHJcbiAgICAgICAgICAgIHZhciBhbk9wdGlvbj0kKFwiPG9wdGlvbiB2YWx1ZT0nXCIrb25lQ29sb3JDb2RlK1wiJz5cIitvbmVDb2xvckNvZGUrXCLilqc8L29wdGlvbj5cIilcclxuICAgICAgICAgICAgY29sb3JTZWxlY3Rvci5hcHBlbmQoYW5PcHRpb24pXHJcbiAgICAgICAgICAgIGFuT3B0aW9uLmNzcyhcImNvbG9yXCIsb25lQ29sb3JDb2RlKVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIGlmKHJlbGF0aW5zaGlwTmFtZT09bnVsbCl7XHJcbiAgICAgICAgICAgIHZhciBhbk9wdGlvbj0kKFwiPG9wdGlvbiB2YWx1ZT0nbm9uZSc+bm9uZTwvb3B0aW9uPlwiKVxyXG4gICAgICAgICAgICBhbk9wdGlvbi5jc3MoXCJjb2xvclwiLFwiZGFya0dyYXlcIilcclxuICAgICAgICAgICAgY29sb3JTZWxlY3Rvci5hcHBlbmQoYW5PcHRpb24pXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZihuYW1lT2ZDb2xvckZpZWxkPT1cInNlY29uZENvbG9yXCIpe1xyXG4gICAgICAgICAgICBpZihwcmVkZWZpbmVkQ29sb3I9PW51bGwpIHByZWRlZmluZWRDb2xvcj1cIm5vbmVcIlxyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICBpZihwcmVkZWZpbmVkQ29sb3I9PW51bGwpIHByZWRlZmluZWRDb2xvcj1cImRhcmtHcmF5XCJcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbG9yU2VsZWN0b3IudmFsKHByZWRlZmluZWRDb2xvcilcclxuICAgICAgICBpZihwcmVkZWZpbmVkQ29sb3IhPVwibm9uZVwiKSB7XHJcbiAgICAgICAgICAgIGNvbG9yU2VsZWN0b3IuY3NzKFwiY29sb3JcIixwcmVkZWZpbmVkQ29sb3IpXHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIGNvbG9yU2VsZWN0b3IuY3NzKFwiY29sb3JcIixcImRhcmtHcmF5XCIpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbG9yU2VsZWN0b3IuY2hhbmdlKChldmUpPT57XHJcbiAgICAgICAgICAgIHZhciBzZWxlY3RDb2xvckNvZGU9ZXZlLnRhcmdldC52YWx1ZVxyXG4gICAgICAgICAgICBpZihzZWxlY3RDb2xvckNvZGU9PVwibm9uZVwiKSBjb2xvclNlbGVjdG9yLmNzcyhcImNvbG9yXCIsXCJkYXJrR3JheVwiKVxyXG4gICAgICAgICAgICBlbHNlIGNvbG9yU2VsZWN0b3IuY3NzKFwiY29sb3JcIixzZWxlY3RDb2xvckNvZGUpXHJcbiAgICAgICAgICAgIHZhciB2aXN1YWxKc29uPWdsb2JhbENhY2hlLnZpc3VhbERlZmluaXRpb25bXCJkZWZhdWx0XCJdLmRldGFpbFxyXG4gICAgXHJcbiAgICAgICAgICAgIGlmKCF2aXN1YWxKc29uW21vZGVsSURdKSB2aXN1YWxKc29uW21vZGVsSURdPXt9XHJcbiAgICAgICAgICAgIGlmKCFyZWxhdGluc2hpcE5hbWUpIHtcclxuICAgICAgICAgICAgICAgIGlmKHNlbGVjdENvbG9yQ29kZT09XCJub25lXCIgJiYgbmFtZU9mQ29sb3JGaWVsZD09XCJzZWNvbmRDb2xvclwiKSBkZWxldGUgdmlzdWFsSnNvblttb2RlbElEXVtcInNlY29uZENvbG9yXCJdXHJcbiAgICAgICAgICAgICAgICBlbHNlIHZpc3VhbEpzb25bbW9kZWxJRF1bbmFtZU9mQ29sb3JGaWVsZF09c2VsZWN0Q29sb3JDb2RlXHJcbiAgICAgICAgICAgICAgICB0aGlzLmJyb2FkY2FzdE1lc3NhZ2UoeyBcIm1lc3NhZ2VcIjogXCJ2aXN1YWxEZWZpbml0aW9uQ2hhbmdlXCIsIFwibW9kZWxJRFwiOm1vZGVsSURcclxuICAgICAgICAgICAgICAgICAgICAsXCJjb2xvclwiOnZpc3VhbEpzb25bbW9kZWxJRF1bXCJjb2xvclwiXSxcInNlY29uZENvbG9yXCI6dmlzdWFsSnNvblttb2RlbElEXVtcInNlY29uZENvbG9yXCJdIH0pXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2hNb2RlbFRyZWVMYWJlbCgpXHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgaWYoIXZpc3VhbEpzb25bbW9kZWxJRF1bXCJyZWxzXCJdKSB2aXN1YWxKc29uW21vZGVsSURdW1wicmVsc1wiXT17fVxyXG4gICAgICAgICAgICAgICAgaWYoIXZpc3VhbEpzb25bbW9kZWxJRF1bXCJyZWxzXCJdW3JlbGF0aW5zaGlwTmFtZV0pIHZpc3VhbEpzb25bbW9kZWxJRF1bXCJyZWxzXCJdW3JlbGF0aW5zaGlwTmFtZV09e31cclxuICAgICAgICAgICAgICAgIHZpc3VhbEpzb25bbW9kZWxJRF1bXCJyZWxzXCJdW3JlbGF0aW5zaGlwTmFtZV0uY29sb3I9c2VsZWN0Q29sb3JDb2RlXHJcbiAgICAgICAgICAgICAgICB0aGlzLmJyb2FkY2FzdE1lc3NhZ2UoeyBcIm1lc3NhZ2VcIjogXCJ2aXN1YWxEZWZpbml0aW9uQ2hhbmdlXCIsIFwic3JjTW9kZWxJRFwiOm1vZGVsSUQsXCJyZWxhdGlvbnNoaXBOYW1lXCI6cmVsYXRpbnNoaXBOYW1lLFwiY29sb3JcIjpzZWxlY3RDb2xvckNvZGUgfSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnNhdmVWaXN1YWxEZWZpbml0aW9uKClcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIGNyZWF0ZUFDb2xvclNlbGVjdG9yKGRlZmluZWRDb2xvcixcImNvbG9yXCIpXHJcbiAgICBpZihyZWxhdGluc2hpcE5hbWU9PW51bGwpIGNyZWF0ZUFDb2xvclNlbGVjdG9yKGRlZmluZWRDb2xvcjIsXCJzZWNvbmRDb2xvclwiKVxyXG5cclxuXHJcbiAgICB2YXIgc2hhcGVTZWxlY3RvciA9ICQoJzxzZWxlY3QgY2xhc3M9XCJ3My1ib3JkZXJcIiBzdHlsZT1cIm91dGxpbmU6bm9uZVwiPjwvc2VsZWN0PicpXHJcbiAgICBjb250YWluZXJEaXYuYXBwZW5kKHNoYXBlU2VsZWN0b3IpXHJcbiAgICBpZihyZWxhdGluc2hpcE5hbWU9PW51bGwpe1xyXG4gICAgICAgIHNoYXBlU2VsZWN0b3IuYXBwZW5kKCQoXCI8b3B0aW9uIHZhbHVlPSdlbGxpcHNlJz7il688L29wdGlvbj5cIikpXHJcbiAgICAgICAgc2hhcGVTZWxlY3Rvci5hcHBlbmQoJChcIjxvcHRpb24gdmFsdWU9J3JlY3RhbmdsZScgc3R5bGU9J2ZvbnQtc2l6ZToxMjAlJz7ilqI8L29wdGlvbj5cIikpXHJcbiAgICAgICAgc2hhcGVTZWxlY3Rvci5hcHBlbmQoJChcIjxvcHRpb24gdmFsdWU9J2hleGFnb24nIHN0eWxlPSdmb250LXNpemU6MTMwJSc+4qyhPC9vcHRpb24+XCIpKVxyXG4gICAgfWVsc2V7XHJcbiAgICAgICAgc2hhcGVTZWxlY3Rvci5hcHBlbmQoJChcIjxvcHRpb24gdmFsdWU9J3NvbGlkJz7ihpI8L29wdGlvbj5cIikpXHJcbiAgICAgICAgc2hhcGVTZWxlY3Rvci5hcHBlbmQoJChcIjxvcHRpb24gdmFsdWU9J2RvdHRlZCc+4oeiPC9vcHRpb24+XCIpKVxyXG4gICAgfVxyXG4gICAgaWYoZGVmaW5lZFNoYXBlIT1udWxsKSB7XHJcbiAgICAgICAgc2hhcGVTZWxlY3Rvci52YWwoZGVmaW5lZFNoYXBlKVxyXG4gICAgfVxyXG4gICAgc2hhcGVTZWxlY3Rvci5jaGFuZ2UoKGV2ZSk9PntcclxuICAgICAgICB2YXIgc2VsZWN0U2hhcGU9ZXZlLnRhcmdldC52YWx1ZVxyXG4gICAgICAgIHZhciB2aXN1YWxKc29uID0gZ2xvYmFsQ2FjaGUudmlzdWFsRGVmaW5pdGlvbltcImRlZmF1bHRcIl0uZGV0YWlsXHJcblxyXG4gICAgICAgIGlmKCF2aXN1YWxKc29uW21vZGVsSURdKSB2aXN1YWxKc29uW21vZGVsSURdPXt9XHJcbiAgICAgICAgaWYoIXJlbGF0aW5zaGlwTmFtZSkge1xyXG4gICAgICAgICAgICB2aXN1YWxKc29uW21vZGVsSURdLnNoYXBlPXNlbGVjdFNoYXBlXHJcbiAgICAgICAgICAgIHRoaXMuYnJvYWRjYXN0TWVzc2FnZSh7IFwibWVzc2FnZVwiOiBcInZpc3VhbERlZmluaXRpb25DaGFuZ2VcIiwgXCJtb2RlbElEXCI6bW9kZWxJRCxcInNoYXBlXCI6c2VsZWN0U2hhcGUgfSlcclxuICAgICAgICAgICAgdGhpcy5yZWZyZXNoTW9kZWxUcmVlTGFiZWwoKVxyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICBpZighdmlzdWFsSnNvblttb2RlbElEXVtcInJlbHNcIl0pIHZpc3VhbEpzb25bbW9kZWxJRF1bXCJyZWxzXCJdPXt9XHJcbiAgICAgICAgICAgIGlmKCF2aXN1YWxKc29uW21vZGVsSURdW1wicmVsc1wiXVtyZWxhdGluc2hpcE5hbWVdKSB2aXN1YWxKc29uW21vZGVsSURdW1wicmVsc1wiXVtyZWxhdGluc2hpcE5hbWVdPXt9XHJcbiAgICAgICAgICAgIHZpc3VhbEpzb25bbW9kZWxJRF1bXCJyZWxzXCJdW3JlbGF0aW5zaGlwTmFtZV0uc2hhcGU9c2VsZWN0U2hhcGVcclxuICAgICAgICAgICAgdGhpcy5icm9hZGNhc3RNZXNzYWdlKHsgXCJtZXNzYWdlXCI6IFwidmlzdWFsRGVmaW5pdGlvbkNoYW5nZVwiLCBcInNyY01vZGVsSURcIjptb2RlbElELFwicmVsYXRpb25zaGlwTmFtZVwiOnJlbGF0aW5zaGlwTmFtZSxcInNoYXBlXCI6c2VsZWN0U2hhcGUgfSlcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zYXZlVmlzdWFsRGVmaW5pdGlvbigpXHJcbiAgICB9KVxyXG5cclxuICAgIHZhciBzaXplQWRqdXN0U2VsZWN0b3IgPSAkKCc8c2VsZWN0IGNsYXNzPVwidzMtYm9yZGVyXCIgc3R5bGU9XCJvdXRsaW5lOm5vbmU7d2lkdGg6MTEwcHhcIj48L3NlbGVjdD4nKVxyXG4gICAgaWYocmVsYXRpbnNoaXBOYW1lPT1udWxsKXtcclxuICAgICAgICBmb3IodmFyIGY9MC4yO2Y8PTM7Zis9MC40KXtcclxuICAgICAgICAgICAgdmFyIHZhbD1mLnRvRml4ZWQoMSkrXCJcIlxyXG4gICAgICAgICAgICBzaXplQWRqdXN0U2VsZWN0b3IuYXBwZW5kKCQoXCI8b3B0aW9uIHZhbHVlPVwiK3ZhbCtcIj5kaW1lbnNpb24qXCIrdmFsK1wiPC9vcHRpb24+XCIpKVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZihkZWZpbmVkRGltZW5zaW9uUmF0aW8hPW51bGwpIHNpemVBZGp1c3RTZWxlY3Rvci52YWwoZGVmaW5lZERpbWVuc2lvblJhdGlvKVxyXG4gICAgICAgIGVsc2Ugc2l6ZUFkanVzdFNlbGVjdG9yLnZhbChcIjEuMFwiKVxyXG4gICAgfWVsc2V7XHJcbiAgICAgICAgc2l6ZUFkanVzdFNlbGVjdG9yLmNzcyhcIndpZHRoXCIsXCI4MHB4XCIpXHJcbiAgICAgICAgZm9yKHZhciBmPTAuNTtmPD00O2YrPTAuNSl7XHJcbiAgICAgICAgICAgIHZhciB2YWw9Zi50b0ZpeGVkKDEpK1wiXCJcclxuICAgICAgICAgICAgc2l6ZUFkanVzdFNlbGVjdG9yLmFwcGVuZCgkKFwiPG9wdGlvbiB2YWx1ZT1cIit2YWwrXCI+d2lkdGggKlwiK3ZhbCtcIjwvb3B0aW9uPlwiKSlcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoZGVmaW5lZEVkZ2VXaWR0aCE9bnVsbCkgc2l6ZUFkanVzdFNlbGVjdG9yLnZhbChkZWZpbmVkRWRnZVdpZHRoKVxyXG4gICAgICAgIGVsc2Ugc2l6ZUFkanVzdFNlbGVjdG9yLnZhbChcIjIuMFwiKVxyXG4gICAgfVxyXG4gICAgY29udGFpbmVyRGl2LmFwcGVuZChzaXplQWRqdXN0U2VsZWN0b3IpXHJcblxyXG4gICAgXHJcbiAgICBzaXplQWRqdXN0U2VsZWN0b3IuY2hhbmdlKChldmUpPT57XHJcbiAgICAgICAgdmFyIGNob29zZVZhbD1ldmUudGFyZ2V0LnZhbHVlXHJcbiAgICAgICAgdmFyIHZpc3VhbEpzb24gPSBnbG9iYWxDYWNoZS52aXN1YWxEZWZpbml0aW9uW1wiZGVmYXVsdFwiXS5kZXRhaWxcclxuXHJcbiAgICAgICAgaWYoIXJlbGF0aW5zaGlwTmFtZSkge1xyXG4gICAgICAgICAgICBpZighdmlzdWFsSnNvblttb2RlbElEXSkgdmlzdWFsSnNvblttb2RlbElEXT17fVxyXG4gICAgICAgICAgICB2aXN1YWxKc29uW21vZGVsSURdLmRpbWVuc2lvblJhdGlvPWNob29zZVZhbFxyXG4gICAgICAgICAgICB0aGlzLmJyb2FkY2FzdE1lc3NhZ2UoeyBcIm1lc3NhZ2VcIjogXCJ2aXN1YWxEZWZpbml0aW9uQ2hhbmdlXCIsIFwibW9kZWxJRFwiOm1vZGVsSUQsXCJkaW1lbnNpb25SYXRpb1wiOmNob29zZVZhbCB9KVxyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICBpZighdmlzdWFsSnNvblttb2RlbElEXVtcInJlbHNcIl0pIHZpc3VhbEpzb25bbW9kZWxJRF1bXCJyZWxzXCJdPXt9XHJcbiAgICAgICAgICAgIGlmKCF2aXN1YWxKc29uW21vZGVsSURdW1wicmVsc1wiXVtyZWxhdGluc2hpcE5hbWVdKSB2aXN1YWxKc29uW21vZGVsSURdW1wicmVsc1wiXVtyZWxhdGluc2hpcE5hbWVdPXt9XHJcbiAgICAgICAgICAgIHZpc3VhbEpzb25bbW9kZWxJRF1bXCJyZWxzXCJdW3JlbGF0aW5zaGlwTmFtZV0uZWRnZVdpZHRoPWNob29zZVZhbFxyXG4gICAgICAgICAgICB0aGlzLmJyb2FkY2FzdE1lc3NhZ2UoeyBcIm1lc3NhZ2VcIjogXCJ2aXN1YWxEZWZpbml0aW9uQ2hhbmdlXCIsIFwic3JjTW9kZWxJRFwiOm1vZGVsSUQsXCJyZWxhdGlvbnNoaXBOYW1lXCI6cmVsYXRpbnNoaXBOYW1lLFwiZWRnZVdpZHRoXCI6Y2hvb3NlVmFsIH0pXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2F2ZVZpc3VhbERlZmluaXRpb24oKVxyXG4gICAgfSlcclxuICAgIFxyXG59XHJcblxyXG5tb2RlbE1hbmFnZXJEaWFsb2cucHJvdG90eXBlLnNhdmVWaXN1YWxEZWZpbml0aW9uPWFzeW5jIGZ1bmN0aW9uKCl7XHJcbiAgICB0cnl7XHJcbiAgICAgICAgYXdhaXQgbXNhbEhlbHBlci5jYWxsQVBJKFwiZGlnaXRhbHR3aW4vc2F2ZVZpc3VhbERlZmluaXRpb25cIiwgXCJQT1NUXCIsIHtcInZpc3VhbERlZmluaXRpb25Kc29uXCI6SlNPTi5zdHJpbmdpZnkoZ2xvYmFsQ2FjaGUudmlzdWFsRGVmaW5pdGlvbltcImRlZmF1bHRcIl0uZGV0YWlsKX0sXCJ3aXRoUHJvamVjdElEXCIpXHJcbiAgICB9Y2F0Y2goZSl7XHJcbiAgICAgICAgY29uc29sZS5sb2coZSlcclxuICAgICAgICBpZihlLnJlc3BvbnNlVGV4dCkgYWxlcnQoZS5yZXNwb25zZVRleHQpXHJcbiAgICB9XHJcbn1cclxuXHJcbm1vZGVsTWFuYWdlckRpYWxvZy5wcm90b3R5cGUuZmlsbFJlbGF0aW9uc2hpcEluZm89ZnVuY3Rpb24odmFsaWRSZWxhdGlvbnNoaXBzLHBhcmVudERvbSl7XHJcbiAgICBmb3IodmFyIGluZCBpbiB2YWxpZFJlbGF0aW9uc2hpcHMpe1xyXG4gICAgICAgIHZhciBrZXlEaXY9ICQoXCI8bGFiZWwgc3R5bGU9J2Rpc3BsYXk6aW5saW5lO3BhZGRpbmc6LjFlbSAuM2VtIC4xZW0gLjNlbTttYXJnaW4tcmlnaHQ6LjNlbSc+XCIraW5kK1wiPC9sYWJlbD5cIilcclxuICAgICAgICBwYXJlbnREb20uYXBwZW5kKGtleURpdilcclxuICAgICAgICBrZXlEaXYuY3NzKFwicGFkZGluZy10b3BcIixcIi4xZW1cIilcclxuICAgICAgICB2YXIgbGFiZWw9JChcIjxsYWJlbCBjbGFzcz0ndzMtbGltZScgc3R5bGU9J2Rpc3BsYXk6aW5saW5lO2ZvbnQtc2l6ZTo5cHg7cGFkZGluZzoycHgnPjwvbGFiZWw+XCIpXHJcbiAgICAgICAgbGFiZWwudGV4dChcIlJlbGF0aW9uc2hpcFwiKVxyXG4gICAgICAgIHBhcmVudERvbS5hcHBlbmQobGFiZWwpXHJcbiAgICAgICAgaWYodmFsaWRSZWxhdGlvbnNoaXBzW2luZF0udGFyZ2V0KXtcclxuICAgICAgICAgICAgdmFyIGxhYmVsMT0kKFwiPGxhYmVsIGNsYXNzPSd3My1saW1lJyBzdHlsZT0nZGlzcGxheTppbmxpbmU7Zm9udC1zaXplOjlweDtwYWRkaW5nOjJweDttYXJnaW4tbGVmdDoycHgnPjwvbGFiZWw+XCIpXHJcbiAgICAgICAgICAgIGxhYmVsMS50ZXh0KHZhbGlkUmVsYXRpb25zaGlwc1tpbmRdLnRhcmdldClcclxuICAgICAgICAgICAgcGFyZW50RG9tLmFwcGVuZChsYWJlbDEpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjb250ZW50RE9NPSQoXCI8bGFiZWw+PC9sYWJlbD5cIilcclxuICAgICAgICBjb250ZW50RE9NLmNzcyhcImRpc3BsYXlcIixcImJsb2NrXCIpXHJcbiAgICAgICAgY29udGVudERPTS5jc3MoXCJwYWRkaW5nLWxlZnRcIixcIjFlbVwiKVxyXG4gICAgICAgIHBhcmVudERvbS5hcHBlbmQoY29udGVudERPTSlcclxuICAgICAgICB0aGlzLmZpbGxFZGl0YWJsZVByb3BlcnRpZXModmFsaWRSZWxhdGlvbnNoaXBzW2luZF0uZWRpdGFibGVSZWxhdGlvbnNoaXBQcm9wZXJ0aWVzLCBjb250ZW50RE9NKVxyXG4gICAgfVxyXG59XHJcblxyXG5tb2RlbE1hbmFnZXJEaWFsb2cucHJvdG90eXBlLmZpbGxFZGl0YWJsZVByb3BlcnRpZXM9ZnVuY3Rpb24oanNvbkluZm8scGFyZW50RG9tKXtcclxuICAgIGZvcih2YXIgaW5kIGluIGpzb25JbmZvKXtcclxuICAgICAgICB2YXIga2V5RGl2PSAkKFwiPGxhYmVsIHN0eWxlPSdkaXNwbGF5OmJsb2NrJz48bGFiZWwgc3R5bGU9J2Rpc3BsYXk6aW5saW5lO3BhZGRpbmc6LjFlbSAuM2VtIC4xZW0gLjNlbTttYXJnaW4tcmlnaHQ6LjNlbSc+XCIraW5kK1wiPC9sYWJlbD48L2xhYmVsPlwiKVxyXG4gICAgICAgIHBhcmVudERvbS5hcHBlbmQoa2V5RGl2KVxyXG4gICAgICAgIGtleURpdi5jc3MoXCJwYWRkaW5nLXRvcFwiLFwiLjFlbVwiKVxyXG5cclxuICAgICAgICBpZihBcnJheS5pc0FycmF5KGpzb25JbmZvW2luZF0pKXtcclxuICAgICAgICAgICAgdmFyIGNvbnRlbnRET009JChcIjxsYWJlbCBjbGFzcz0ndzMtZGFyay1ncmF5JyA+PC9sYWJlbD5cIilcclxuICAgICAgICAgICAgY29udGVudERPTS50ZXh0KFwiZW51bVwiKVxyXG4gICAgICAgICAgICBjb250ZW50RE9NLmNzcyh7XCJmb250U2l6ZVwiOlwiOXB4XCIsXCJwYWRkaW5nXCI6JzJweCd9KVxyXG4gICAgICAgICAgICBrZXlEaXYuYXBwZW5kKGNvbnRlbnRET00pXHJcblxyXG4gICAgICAgICAgICB2YXIgdmFsdWVBcnI9W11cclxuICAgICAgICAgICAganNvbkluZm9baW5kXS5mb3JFYWNoKGVsZT0+e3ZhbHVlQXJyLnB1c2goZWxlLmVudW1WYWx1ZSl9KVxyXG4gICAgICAgICAgICB2YXIgbGFiZWwxPSQoXCI8bGFiZWwgY2xhc3M9J3czLWRhcmstZ3JheScgPjwvbGFiZWw+XCIpXHJcbiAgICAgICAgICAgIGxhYmVsMS5jc3Moe1wiZm9udFNpemVcIjpcIjlweFwiLFwicGFkZGluZ1wiOicycHgnLFwibWFyZ2luLWxlZnRcIjpcIjJweFwifSlcclxuICAgICAgICAgICAgbGFiZWwxLnRleHQodmFsdWVBcnIuam9pbigpKVxyXG4gICAgICAgICAgICBrZXlEaXYuYXBwZW5kKGxhYmVsMSlcclxuICAgICAgICB9ZWxzZSBpZih0eXBlb2YoanNvbkluZm9baW5kXSk9PT1cIm9iamVjdFwiKSB7XHJcbiAgICAgICAgICAgIHZhciBjb250ZW50RE9NPSQoXCI8bGFiZWw+PC9sYWJlbD5cIilcclxuICAgICAgICAgICAgY29udGVudERPTS5jc3MoXCJkaXNwbGF5XCIsXCJibG9ja1wiKVxyXG4gICAgICAgICAgICBjb250ZW50RE9NLmNzcyhcInBhZGRpbmctbGVmdFwiLFwiMWVtXCIpXHJcbiAgICAgICAgICAgIHRoaXMuZmlsbEVkaXRhYmxlUHJvcGVydGllcyhqc29uSW5mb1tpbmRdLGNvbnRlbnRET00pXHJcbiAgICAgICAgICAgIGtleURpdi5hcHBlbmQoY29udGVudERPTSlcclxuICAgICAgICB9ZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBjb250ZW50RE9NPSQoXCI8bGFiZWwgY2xhc3M9J3czLWRhcmstZ3JheScgPjwvbGFiZWw+XCIpXHJcbiAgICAgICAgICAgIGNvbnRlbnRET00udGV4dChqc29uSW5mb1tpbmRdKVxyXG4gICAgICAgICAgICBjb250ZW50RE9NLmNzcyh7XCJmb250U2l6ZVwiOlwiOXB4XCIsXCJwYWRkaW5nXCI6JzJweCd9KVxyXG4gICAgICAgICAgICBrZXlEaXYuYXBwZW5kKGNvbnRlbnRET00pXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5cclxubW9kZWxNYW5hZ2VyRGlhbG9nLnByb3RvdHlwZS5hZGRBUGFydEluUmlnaHRTcGFuPWZ1bmN0aW9uKHBhcnROYW1lLG9wdGlvbnMpe1xyXG4gICAgb3B0aW9ucz1vcHRpb25zfHx7fVxyXG4gICAgdmFyIHNlY3Rpb249IG5ldyBzaW1wbGVFeHBhbmRhYmxlU2VjdGlvbihwYXJ0TmFtZSx0aGlzLnBhbmVsQ2FyZCxvcHRpb25zKVxyXG4gICAgc2VjdGlvbi5leHBhbmQoKVxyXG4gICAgcmV0dXJuIHNlY3Rpb24ubGlzdERPTTtcclxufVxyXG5cclxubW9kZWxNYW5hZ2VyRGlhbG9nLnByb3RvdHlwZS5yZWFkTW9kZWxGaWxlc0NvbnRlbnRBbmRJbXBvcnQ9YXN5bmMgZnVuY3Rpb24oZmlsZXMpe1xyXG4gICAgLy8gZmlsZXMgaXMgYSBGaWxlTGlzdCBvZiBGaWxlIG9iamVjdHMuIExpc3Qgc29tZSBwcm9wZXJ0aWVzLlxyXG4gICAgdmFyIGZpbGVDb250ZW50QXJyPVtdXHJcbiAgICBmb3IgKHZhciBpID0gMDtpPCBmaWxlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciBmPWZpbGVzW2ldXHJcbiAgICAgICAgLy8gT25seSBwcm9jZXNzIGpzb24gZmlsZXMuXHJcbiAgICAgICAgaWYgKGYudHlwZSE9XCJhcHBsaWNhdGlvbi9qc29uXCIpIGNvbnRpbnVlO1xyXG4gICAgICAgIHRyeXtcclxuICAgICAgICAgICAgdmFyIHN0cj0gYXdhaXQgdGhpcy5yZWFkT25lRmlsZShmKVxyXG4gICAgICAgICAgICB2YXIgb2JqPUpTT04ucGFyc2Uoc3RyKVxyXG4gICAgICAgICAgICBpZihBcnJheS5pc0FycmF5KG9iaikpIGZpbGVDb250ZW50QXJyPWZpbGVDb250ZW50QXJyLmNvbmNhdChvYmopXHJcbiAgICAgICAgICAgIGVsc2UgZmlsZUNvbnRlbnRBcnIucHVzaChvYmopXHJcbiAgICAgICAgfWNhdGNoKGVycil7XHJcbiAgICAgICAgICAgIGFsZXJ0KGVycilcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZihmaWxlQ29udGVudEFyci5sZW5ndGg9PTApIHJldHVybjtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgYXdhaXQgbXNhbEhlbHBlci5jYWxsQVBJKFwiZGlnaXRhbHR3aW4vaW1wb3J0TW9kZWxzXCIsIFwiUE9TVFwiLCB7XCJtb2RlbHNcIjpKU09OLnN0cmluZ2lmeShmaWxlQ29udGVudEFycil9LFwid2l0aFByb2plY3RJRFwiKVxyXG4gICAgICAgIHRoaXMubGlzdE1vZGVscyhcInNob3VsZEJyb2FkQ2FzdFwiKVxyXG4gICAgfWNhdGNoKGUpe1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGUpXHJcbiAgICAgICAgaWYoZS5yZXNwb25zZVRleHQpIGFsZXJ0KGUucmVzcG9uc2VUZXh0KVxyXG4gICAgfSAgXHJcbn1cclxuXHJcbm1vZGVsTWFuYWdlckRpYWxvZy5wcm90b3R5cGUucmVhZE9uZUZpbGU9IGFzeW5jIGZ1bmN0aW9uKGFGaWxlKXtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgdHJ5e1xyXG4gICAgICAgICAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcclxuICAgICAgICAgICAgcmVhZGVyLm9ubG9hZCA9ICgpPT4ge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZWFkZXIucmVzdWx0KVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZWFkZXIucmVhZEFzVGV4dChhRmlsZSk7XHJcbiAgICAgICAgfWNhdGNoKGUpe1xyXG4gICAgICAgICAgICByZWplY3QoZSlcclxuICAgICAgICB9XHJcbiAgICB9KVxyXG59XHJcblxyXG5cclxubW9kZWxNYW5hZ2VyRGlhbG9nLnByb3RvdHlwZS5saXN0TW9kZWxzPWFzeW5jIGZ1bmN0aW9uKHNob3VsZEJyb2FkY2FzdCl7XHJcbiAgICB0aGlzLm1vZGVsTGlzdC5lbXB0eSgpXHJcbiAgICB0aGlzLnBhbmVsQ2FyZC5lbXB0eSgpXHJcbiAgICB0cnl7XHJcbiAgICAgICAgdmFyIHJlcz1hd2FpdCBtc2FsSGVscGVyLmNhbGxBUEkoXCJkaWdpdGFsdHdpbi9mZXRjaFByb2plY3RNb2RlbHNEYXRhXCIsXCJQT1NUXCIsbnVsbCxcIndpdGhQcm9qZWN0SURcIilcclxuICAgICAgICBnbG9iYWxDYWNoZS5zdG9yZVByb2plY3RNb2RlbHNEYXRhKHJlcy5EQk1vZGVscyxyZXMuYWR0TW9kZWxzKVxyXG4gICAgICAgIG1vZGVsQW5hbHl6ZXIuY2xlYXJBbGxNb2RlbHMoKTtcclxuICAgICAgICBtb2RlbEFuYWx5emVyLmFkZE1vZGVscyhyZXMuYWR0TW9kZWxzKVxyXG4gICAgICAgIG1vZGVsQW5hbHl6ZXIuYW5hbHl6ZSgpO1xyXG4gICAgfWNhdGNoKGUpe1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGUpXHJcbiAgICAgICAgaWYoZS5yZXNwb25zZVRleHQpIGFsZXJ0KGUucmVzcG9uc2VUZXh0KVxyXG4gICAgICAgIHJldHVyblxyXG4gICAgfVxyXG5cclxuICAgIGlmKCQuaXNFbXB0eU9iamVjdChtb2RlbEFuYWx5emVyLkRURExNb2RlbHMpKXtcclxuICAgICAgICB2YXIgemVyb01vZGVsSXRlbT0kKCc8bGkgc3R5bGU9XCJmb250LXNpemU6MC45ZW1cIj56ZXJvIG1vZGVsIHJlY29yZC4gUGxlYXNlIGltcG9ydC4uLjwvbGk+JylcclxuICAgICAgICB0aGlzLm1vZGVsTGlzdC5hcHBlbmQoemVyb01vZGVsSXRlbSlcclxuICAgICAgICB6ZXJvTW9kZWxJdGVtLmNzcyhcImN1cnNvclwiLFwiZGVmYXVsdFwiKVxyXG4gICAgfWVsc2V7XHJcbiAgICAgICAgdGhpcy50cmVlID0gbmV3IHNpbXBsZVRyZWUodGhpcy5tb2RlbExpc3QsIHtcclxuICAgICAgICAgICAgXCJsZWFmTmFtZVByb3BlcnR5XCI6IFwiZGlzcGxheU5hbWVcIlxyXG4gICAgICAgICAgICAsIFwibm9NdWx0aXBsZVNlbGVjdEFsbG93ZWRcIjogdHJ1ZSwgXCJoaWRlRW1wdHlHcm91cFwiOiB0cnVlXHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgdGhpcy50cmVlLm9wdGlvbnMubGVhZk5vZGVJY29uRnVuYyA9IChsbikgPT4ge1xyXG4gICAgICAgICAgICB2YXIgbW9kZWxDbGFzcyA9IGxuLmxlYWZJbmZvW1wiQGlkXCJdXHJcbiAgICAgICAgICAgIHZhciBkYk1vZGVsSW5mbz1nbG9iYWxDYWNoZS5nZXRTaW5nbGVEQk1vZGVsQnlJRChtb2RlbENsYXNzKVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIGNvbG9yQ29kZSA9IFwiZGFya0dyYXlcIlxyXG4gICAgICAgICAgICB2YXIgc2hhcGUgPSBcImVsbGlwc2VcIlxyXG4gICAgICAgICAgICB2YXIgYXZhcnRhID0gbnVsbFxyXG4gICAgICAgICAgICB2YXIgZGltZW5zaW9uPTIwO1xyXG4gICAgICAgICAgICBpZiAoZ2xvYmFsQ2FjaGUudmlzdWFsRGVmaW5pdGlvbltcImRlZmF1bHRcIl0uZGV0YWlsW21vZGVsQ2xhc3NdKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmlzdWFsSnNvbiA9IGdsb2JhbENhY2hlLnZpc3VhbERlZmluaXRpb25bXCJkZWZhdWx0XCJdLmRldGFpbFttb2RlbENsYXNzXVxyXG4gICAgICAgICAgICAgICAgdmFyIGNvbG9yQ29kZSA9IHZpc3VhbEpzb24uY29sb3IgfHwgXCJkYXJrR3JheVwiXHJcbiAgICAgICAgICAgICAgICB2YXIgc2Vjb25kQ29sb3IgPSB2aXN1YWxKc29uLnNlY29uZENvbG9yXHJcbiAgICAgICAgICAgICAgICB2YXIgc2hhcGUgPSB2aXN1YWxKc29uLnNoYXBlIHx8IFwiZWxsaXBzZVwiXHJcbiAgICAgICAgICAgICAgICB2YXIgYXZhcnRhID0gdmlzdWFsSnNvbi5hdmFydGFcclxuICAgICAgICAgICAgICAgIGlmKHZpc3VhbEpzb24uZGltZW5zaW9uUmF0aW8pIGRpbWVuc2lvbio9cGFyc2VGbG9hdCh2aXN1YWxKc29uLmRpbWVuc2lvblJhdGlvKVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgaWNvbkRPTT0kKFwiPGRpdiBzdHlsZT0nd2lkdGg6XCIrZGltZW5zaW9uK1wicHg7aGVpZ2h0OlwiK2RpbWVuc2lvbitcInB4O2Zsb2F0OmxlZnQ7cG9zaXRpb246cmVsYXRpdmUnPjwvZGl2PlwiKVxyXG4gICAgICAgICAgICBpZihkYk1vZGVsSW5mby5pc0lvVERldmljZU1vZGVsKXtcclxuICAgICAgICAgICAgICAgIHZhciBpb3REaXY9JChcIjxkaXYgY2xhc3M9J3czLWJvcmRlcicgc3R5bGU9J3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0Oi01cHg7cGFkZGluZzowcHggMnB4O3RvcDotOXB4O2JvcmRlci1yYWRpdXM6IDNweDtmb250LXNpemU6N3B4Jz5Jb1Q8L2Rpdj5cIilcclxuICAgICAgICAgICAgICAgIGljb25ET00uYXBwZW5kKGlvdERpdilcclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgIHZhciBpbWdTcmM9ZW5jb2RlVVJJQ29tcG9uZW50KGdsb2JhbENhY2hlLnNoYXBlU3ZnKHNoYXBlLGNvbG9yQ29kZSxzZWNvbmRDb2xvcikpXHJcbiAgICAgICAgICAgIGljb25ET00uYXBwZW5kKCQoXCI8aW1nIHNyYz0nZGF0YTppbWFnZS9zdmcreG1sO3V0ZjgsXCIraW1nU3JjK1wiJz48L2ltZz5cIikpXHJcbiAgICAgICAgICAgIGlmKGF2YXJ0YSl7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXZhcnRhaW1nPSQoYDxpbWcgc3R5bGU9J21heC13aWR0aDoke2RpbWVuc2lvbiowLjc1fXB4O21heC1oZWlnaHQ6JHtkaW1lbnNpb24qMC43NX1weDtwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OjUwJTt0b3A6NTAlO3RyYW5zZm9ybTp0cmFuc2xhdGVYKC01MCUpIHRyYW5zbGF0ZVkoLTUwJSknIHNyYz0nJHthdmFydGF9Jz48L2ltZz5gKVxyXG4gICAgICAgICAgICAgICAgaWNvbkRPTS5hcHBlbmQoYXZhcnRhaW1nKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBpY29uRE9NXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnRyZWUuY2FsbGJhY2tfYWZ0ZXJTZWxlY3ROb2RlcyA9IChub2Rlc0FyciwgbW91c2VDbGlja0RldGFpbCkgPT4ge1xyXG4gICAgICAgICAgICB2YXIgdGhlTm9kZSA9IG5vZGVzQXJyWzBdXHJcbiAgICAgICAgICAgIHRoaXMuZmlsbFJpZ2h0U3Bhbih0aGVOb2RlLmxlYWZJbmZvW1wiQGlkXCJdKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGdyb3VwTmFtZUxpc3QgPSB7fVxyXG4gICAgICAgIGZvciAodmFyIG1vZGVsSUQgaW4gbW9kZWxBbmFseXplci5EVERMTW9kZWxzKSBncm91cE5hbWVMaXN0W3RoaXMubW9kZWxOYW1lVG9Hcm91cE5hbWUobW9kZWxJRCldID0gMVxyXG4gICAgICAgIHZhciBtb2RlbGdyb3VwU29ydEFyciA9IE9iamVjdC5rZXlzKGdyb3VwTmFtZUxpc3QpXHJcbiAgICAgICAgbW9kZWxncm91cFNvcnRBcnIuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS50b0xvd2VyQ2FzZSgpLmxvY2FsZUNvbXBhcmUoYi50b0xvd2VyQ2FzZSgpKSB9KTtcclxuICAgICAgICBtb2RlbGdyb3VwU29ydEFyci5mb3JFYWNoKG9uZUdyb3VwTmFtZSA9PiB7XHJcbiAgICAgICAgICAgIHZhciBnbj10aGlzLnRyZWUuYWRkR3JvdXBOb2RlKHsgZGlzcGxheU5hbWU6IG9uZUdyb3VwTmFtZSB9KVxyXG4gICAgICAgICAgICBnbi5leHBhbmQoKVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIGZvciAodmFyIG1vZGVsSUQgaW4gbW9kZWxBbmFseXplci5EVERMTW9kZWxzKSB7XHJcbiAgICAgICAgICAgIHZhciBnbiA9IHRoaXMubW9kZWxOYW1lVG9Hcm91cE5hbWUobW9kZWxJRClcclxuICAgICAgICAgICAgdGhpcy50cmVlLmFkZExlYWZub2RlVG9Hcm91cChnbiwgSlNPTi5wYXJzZShtb2RlbEFuYWx5emVyLkRURExNb2RlbHNbbW9kZWxJRF1bXCJvcmlnaW5hbFwiXSkpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnRyZWUuc29ydEFsbExlYXZlcygpXHJcbiAgICB9XHJcbiAgICBcclxuICAgIGlmKHNob3VsZEJyb2FkY2FzdCkgdGhpcy5icm9hZGNhc3RNZXNzYWdlKHsgXCJtZXNzYWdlXCI6IFwiQURUTW9kZWxzQ2hhbmdlXCJ9KVxyXG59XHJcblxyXG5tb2RlbE1hbmFnZXJEaWFsb2cucHJvdG90eXBlLm1vZGVsTmFtZVRvR3JvdXBOYW1lPWZ1bmN0aW9uKG1vZGVsTmFtZSl7XHJcbiAgICB2YXIgbmFtZVBhcnRzPW1vZGVsTmFtZS5zcGxpdChcIjpcIilcclxuICAgIGlmKG5hbWVQYXJ0cy5sZW5ndGg+PTIpICByZXR1cm4gbmFtZVBhcnRzWzFdXHJcbiAgICBlbHNlIHJldHVybiBcIk90aGVyc1wiXHJcbn1cclxuXHJcbm1vZGVsTWFuYWdlckRpYWxvZy5wcm90b3R5cGUucnhNZXNzYWdlPWZ1bmN0aW9uKG1zZ1BheWxvYWQpe1xyXG4gICAgaWYobXNnUGF5bG9hZC5tZXNzYWdlPT1cIkFEVE1vZGVsRWRpdGVkXCIpIHRoaXMubGlzdE1vZGVscyhcInNob3VsZEJyb2FkY2FzdFwiKVxyXG59XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBuZXcgbW9kZWxNYW5hZ2VyRGlhbG9nKCk7IiwiY29uc3QgZ2xvYmFsQXBwU2V0dGluZ3M9cmVxdWlyZShcIi4uL2dsb2JhbEFwcFNldHRpbmdzXCIpXHJcblxyXG5mdW5jdGlvbiBtb2R1bGVTd2l0Y2hEaWFsb2coKXtcclxuICAgIHRoaXMubW9kdWxlc1NpZGViYXI9JCgnPGRpdiBjbGFzcz1cInczLXNpZGViYXIgdzMtYmFyLWJsb2NrIHczLXdoaXRlIHczLWFuaW1hdGUtbGVmdCB3My1jYXJkLTRcIiBzdHlsZT1cImRpc3BsYXk6bm9uZTtoZWlnaHQ6MTk1cHg7d2lkdGg6MjQwcHg7b3ZlcmZsb3c6aGlkZGVuXCI+PGRpdiBzdHlsZT1cImhlaWdodDo0MHB4XCIgY2xhc3M9XCJ3My1iYXIgdzMtcmVkXCI+PGJ1dHRvbiBjbGFzcz1cInczLWJhci1pdGVtIHczLWJ1dHRvbiB3My1sZWZ0IHczLWhvdmVyLWFtYmVyXCIgc3R5bGU9XCJmb250LXNpemU6MmVtO3BhZGRpbmctdG9wOjRweDt3aWR0aDo1NXB4XCI+4piwPC9idXR0b24+PGRpdiBjbGFzcz1cInczLWJhci1pdGVtXCIgc3R5bGU9XCJmb250LXNpemU6MS41ZW07d2lkdGg6NzBweDtmbG9hdDpsZWZ0O2N1cnNvcjpkZWZhdWx0XCI+T3BlbjwvZGl2PjwvZGl2PjxhIGhyZWY9XCIjXCIgY2xhc3M9XCJ3My1iYXItaXRlbSB3My1idXR0b24gdzMtbWVkaXVtXCI+PGltZyBzcmM9XCJmYXZpY29uaW90aHViLmljb1wiIHN0eWxlPVwid2lkdGg6MjVweDttYXJnaW4tcmlnaHQ6MTBweFwiPjwvaW1nPkRldmljZSBNYW5hZ2VtZW50PC9hPjxhIGhyZWY9XCIjXCIgY2xhc3M9XCJ3My1iYXItaXRlbSB3My1idXR0b24gdzMtbWVkaXVtXCI+PGltZyBzcmM9XCJmYXZpY29uZGlnaXRhbHR3aW4uaWNvXCIgc3R5bGU9XCJ3aWR0aDoyNXB4O21hcmdpbi1yaWdodDoxMHB4XCI+PC9pbWc+RGlnaXRhbCBUd2luPC9hPjxhIGhyZWY9XCIjXCIgY2xhc3M9XCJ3My1iYXItaXRlbSB3My1idXR0b24gdzMtbWVkaXVtXCI+PGltZyBzcmM9XCJmYXZpY29uZXZlbnRsb2cuaWNvXCIgc3R5bGU9XCJ3aWR0aDoyNXB4O21hcmdpbi1yaWdodDoxMHB4XCI+PC9pbWc+RXZlbnQgTG9nPC9hPjxhIGhyZWY9XCIjXCIgY2xhc3M9XCJ3My1iYXItaXRlbSB3My1idXR0b24gdzMtbWVkaXVtXCI+TG9nIG91dDwvYT48L2Rpdj4nKVxyXG4gICAgXHJcbiAgICB0aGlzLm1vZHVsZXNTd2l0Y2hCdXR0b249JCgnPGEgY2xhc3M9XCJ3My1iYXItaXRlbSB3My1idXR0b25cIiBocmVmPVwiI1wiPuKYsDwvYT4nKVxyXG4gICAgXHJcbiAgICB0aGlzLm1vZHVsZXNTd2l0Y2hCdXR0b24ub24oXCJjbGlja1wiLCgpPT57IHRoaXMubW9kdWxlc1NpZGViYXIuY3NzKFwiZGlzcGxheVwiLFwiYmxvY2tcIikgfSlcclxuICAgIHRoaXMubW9kdWxlc1NpZGViYXIuY2hpbGRyZW4oJzpmaXJzdCcpLm9uKFwiY2xpY2tcIiwoKT0+e3RoaXMubW9kdWxlc1NpZGViYXIuY3NzKFwiZGlzcGxheVwiLFwibm9uZVwiKX0pXHJcbiAgICBcclxuICAgIHZhciBhbGxNb2RldWxzPXRoaXMubW9kdWxlc1NpZGViYXIuY2hpbGRyZW4oXCJhXCIpXHJcbiAgICAkKGFsbE1vZGV1bHNbMF0pLm9uKFwiY2xpY2tcIiwoKT0+e1xyXG4gICAgICAgIHdpbmRvdy5vcGVuKFwiZGV2aWNlbWFuYWdlbWVudC5odG1sXCIsIFwiX2JsYW5rXCIpXHJcbiAgICAgICAgdGhpcy5tb2R1bGVzU2lkZWJhci5jc3MoXCJkaXNwbGF5XCIsXCJub25lXCIpXHJcbiAgICB9KVxyXG4gICAgJChhbGxNb2RldWxzWzFdKS5vbihcImNsaWNrXCIsKCk9PntcclxuICAgICAgICB3aW5kb3cub3BlbihcImRpZ2l0YWx0d2lubW9kdWxlLmh0bWxcIiwgXCJfYmxhbmtcIilcclxuICAgICAgICB0aGlzLm1vZHVsZXNTaWRlYmFyLmNzcyhcImRpc3BsYXlcIixcIm5vbmVcIilcclxuICAgIH0pXHJcbiAgICAkKGFsbE1vZGV1bHNbMl0pLm9uKFwiY2xpY2tcIiwoKT0+e1xyXG4gICAgICAgIHdpbmRvdy5vcGVuKFwiZXZlbnRsb2dtb2R1bGUuaHRtbFwiLCBcIl9ibGFua1wiKVxyXG4gICAgICAgIHRoaXMubW9kdWxlc1NpZGViYXIuY3NzKFwiZGlzcGxheVwiLFwibm9uZVwiKVxyXG4gICAgfSlcclxuICAgICQoYWxsTW9kZXVsc1szXSkub24oXCJjbGlja1wiLCgpPT57XHJcbiAgICAgICAgY29uc3QgbG9nb3V0UmVxdWVzdCA9IHtcclxuICAgICAgICAgICAgcG9zdExvZ291dFJlZGlyZWN0VXJpOiBnbG9iYWxBcHBTZXR0aW5ncy5sb2dvdXRSZWRpcmVjdFVyaSxcclxuICAgICAgICAgICAgbWFpbldpbmRvd1JlZGlyZWN0VXJpOiBnbG9iYWxBcHBTZXR0aW5ncy5sb2dvdXRSZWRpcmVjdFVyaVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIG15TVNBTE9iaiA9IG5ldyBtc2FsLlB1YmxpY0NsaWVudEFwcGxpY2F0aW9uKGdsb2JhbEFwcFNldHRpbmdzLm1zYWxDb25maWcpO1xyXG4gICAgICAgIG15TVNBTE9iai5sb2dvdXRQb3B1cChsb2dvdXRSZXF1ZXN0KTtcclxuICAgIH0pXHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gbmV3IG1vZHVsZVN3aXRjaERpYWxvZygpOyIsImNvbnN0IG1vZGVsQW5hbHl6ZXI9cmVxdWlyZShcIi4vbW9kZWxBbmFseXplclwiKVxyXG5jb25zdCBzaW1wbGVTZWxlY3RNZW51PSByZXF1aXJlKFwiLi9zaW1wbGVTZWxlY3RNZW51XCIpXHJcbmNvbnN0IG1zYWxIZWxwZXI9cmVxdWlyZShcIi4uL21zYWxIZWxwZXJcIilcclxuY29uc3QgZ2xvYmFsQ2FjaGU9cmVxdWlyZShcIi4vZ2xvYmFsQ2FjaGVcIilcclxuXHJcbmZ1bmN0aW9uIG5ld1R3aW5EaWFsb2coKSB7XHJcbiAgICBpZighdGhpcy5ET00pe1xyXG4gICAgICAgIHRoaXMuRE9NID0gJCgnPGRpdiBzdHlsZT1cInBvc2l0aW9uOmFic29sdXRlO3RvcDo1MCU7YmFja2dyb3VuZC1jb2xvcjp3aGl0ZTtsZWZ0OjUwJTt0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTUwJSkgdHJhbnNsYXRlWSgtNTAlKTt6LWluZGV4Ojk5XCIgY2xhc3M9XCJ3My1jYXJkLTJcIj48L2Rpdj4nKVxyXG4gICAgICAgICQoXCJib2R5XCIpLmFwcGVuZCh0aGlzLkRPTSlcclxuICAgICAgICB0aGlzLkRPTS5oaWRlKClcclxuICAgICAgICBnbG9iYWxDYWNoZS5tYWtlRE9NRHJhZ2dhYmxlKHRoaXMuRE9NKVxyXG4gICAgfVxyXG59XHJcblxyXG5uZXdUd2luRGlhbG9nLnByb3RvdHlwZS5wb3B1cCA9IGFzeW5jIGZ1bmN0aW9uKHR3aW5JbmZvKSB7XHJcbiAgICB0aGlzLm9yaWdpbmFsVHdpbkluZm89SlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0d2luSW5mbykpXHJcbiAgICB0aGlzLnR3aW5JbmZvPXR3aW5JbmZvXHJcbiAgICB0aGlzLkRPTS5zaG93KClcclxuICAgIHRoaXMuRE9NLmVtcHR5KClcclxuICAgIHRoaXMuY29udGVudERPTSA9ICQoJzxkaXYgc3R5bGU9XCJ3aWR0aDo1MjBweFwiPjwvZGl2PicpXHJcbiAgICB0aGlzLkRPTS5hcHBlbmQodGhpcy5jb250ZW50RE9NKVxyXG4gICAgdGhpcy5jb250ZW50RE9NLmFwcGVuZCgkKCc8ZGl2IHN0eWxlPVwiaGVpZ2h0OjQwcHhcIiBjbGFzcz1cInczLWJhciB3My1yZWRcIj48ZGl2IGNsYXNzPVwidzMtYmFyLWl0ZW1cIiBzdHlsZT1cImZvbnQtc2l6ZToxLjVlbVwiPkRpZ2l0YWwgVHdpbiBFZGl0b3I8L2Rpdj48L2Rpdj4nKSlcclxuICAgIHZhciBjbG9zZUJ1dHRvbiA9ICQoJzxidXR0b24gY2xhc3M9XCJ3My1iYXItaXRlbSB3My1idXR0b24gdzMtcmlnaHRcIiBzdHlsZT1cImZvbnQtc2l6ZToyZW07cGFkZGluZy10b3A6NHB4XCI+w5c8L2J1dHRvbj4nKVxyXG4gICAgdGhpcy5jb250ZW50RE9NLmNoaWxkcmVuKCc6Zmlyc3QnKS5hcHBlbmQoY2xvc2VCdXR0b24pXHJcbiAgICBjbG9zZUJ1dHRvbi5vbihcImNsaWNrXCIsICgpID0+IHsgdGhpcy5ET00uaGlkZSgpIH0pXHJcblxyXG4gICAgdmFyIGFkZEJ1dHRvbiA9ICQoJzxidXR0b24gY2xhc3M9XCJ3My1yaXBwbGUgdzMtYnV0dG9uIHczLWNhcmQgdzMtZ3JlZW4gdzMtaG92ZXItbGlnaHQtZ3JlZW5cIiBzdHlsZT1cImhlaWdodDoxMDAlXCI+QWRkPC9idXR0b24+JylcclxuICAgIHRoaXMuY29udGVudERPTS5jaGlsZHJlbignOmZpcnN0JykuYXBwZW5kKGFkZEJ1dHRvbilcclxuICAgIGFkZEJ1dHRvbi5vbihcImNsaWNrXCIsIGFzeW5jICgpID0+IHsgdGhpcy5hZGROZXdUd2luKCkgfSlcclxuICAgIFxyXG4gICAgdmFyIGFkZEFuZENsb3NlQnV0dG9uID0gJCgnPGJ1dHRvbiBjbGFzcz1cInczLWJ1dHRvbiB3My1jYXJkIHczLWdyZWVuIHczLWhvdmVyLWxpZ2h0LWdyZWVuXCIgc3R5bGU9XCJoZWlnaHQ6MTAwJTttYXJnaW4tbGVmdDo1cHhcIj5BZGQgJiBDbG9zZTwvYnV0dG9uPicpICAgIFxyXG4gICAgdGhpcy5jb250ZW50RE9NLmNoaWxkcmVuKCc6Zmlyc3QnKS5hcHBlbmQoYWRkQW5kQ2xvc2VCdXR0b24pXHJcbiAgICBhZGRBbmRDbG9zZUJ1dHRvbi5vbihcImNsaWNrXCIsIGFzeW5jICgpID0+IHt0aGlzLmFkZE5ld1R3aW4oXCJDbG9zZURpYWxvZ1wiKX0pXHJcbiAgICAgICAgXHJcbiAgICB2YXIgSURMYWJsZURpdj0gJChcIjxkaXYgY2xhc3M9J3czLXBhZGRpbmcnIHN0eWxlPSdkaXNwbGF5OmlubGluZTtmb250LXdlaWdodDpib2xkO2NvbG9yOmJsYWNrJz5Ud2luIElEPC9kaXY+XCIpXHJcbiAgICB2YXIgSURJbnB1dD0kKCc8aW5wdXQgdHlwZT1cInRleHRcIiBzdHlsZT1cIm1hcmdpbjo4cHggMDtwYWRkaW5nOjJweDt3aWR0aDoxNTBweDtvdXRsaW5lOm5vbmU7ZGlzcGxheTppbmxpbmVcIiBwbGFjZWhvbGRlcj1cIklEXCIvPicpLmFkZENsYXNzKFwidzMtaW5wdXQgdzMtYm9yZGVyXCIpO1xyXG4gICAgdGhpcy5JRElucHV0PUlESW5wdXQgXHJcbiAgICB2YXIgbW9kZWxJRD10d2luSW5mb1tcIiRtZXRhZGF0YVwiXVtcIiRtb2RlbFwiXVxyXG4gICAgdmFyIG1vZGVsTGFibGVEaXY9ICQoXCI8ZGl2IGNsYXNzPSd3My1wYWRkaW5nJyBzdHlsZT0nZGlzcGxheTppbmxpbmU7Zm9udC13ZWlnaHQ6Ym9sZDtjb2xvcjpibGFjayc+TW9kZWw8L2Rpdj5cIilcclxuICAgIHZhciBtb2RlbElucHV0PSQoJzxsYWJlbCB0eXBlPVwidGV4dFwiIHN0eWxlPVwibWFyZ2luOjhweCAwO3BhZGRpbmc6MnB4O2Rpc3BsYXk6aW5saW5lXCIvPicpLnRleHQobW9kZWxJRCk7ICBcclxuICAgIHRoaXMuY29udGVudERPTS5hcHBlbmQoJChcIjxkaXYvPlwiKS5hcHBlbmQoSURMYWJsZURpdixJRElucHV0KSlcclxuICAgIHRoaXMuY29udGVudERPTS5hcHBlbmQoJChcIjxkaXYgc3R5bGU9J3BhZGRpbmc6OHB4IDBweCcvPlwiKS5hcHBlbmQobW9kZWxMYWJsZURpdixtb2RlbElucHV0KSlcclxuICAgIElESW5wdXQuY2hhbmdlKChlKT0+e1xyXG4gICAgICAgIHRoaXMudHdpbkluZm9bXCIkZHRJZFwiXT0kKGUudGFyZ2V0KS52YWwoKVxyXG4gICAgfSlcclxuXHJcbiAgICB2YXIgZGlhbG9nRE9NPSQoJzxkaXYgLz4nKVxyXG4gICAgdGhpcy5jb250ZW50RE9NLmFwcGVuZChkaWFsb2dET00pICAgIFxyXG4gICAgdmFyIHRpdGxlVGFibGU9JCgnPHRhYmxlIHN0eWxlPVwid2lkdGg6MTAwJVwiIGNlbGxzcGFjaW5nPVwiMHB4XCIgY2VsbHBhZGRpbmc9XCIwcHhcIj48L3RhYmxlPicpXHJcbiAgICB0aXRsZVRhYmxlLmFwcGVuZCgkKCc8dHI+PHRkIHN0eWxlPVwiZm9udC13ZWlnaHQ6Ym9sZFwiPlByb3BlcnRpZXMgVHJlZTwvdGQ+PC90cj4nKSlcclxuICAgIGRpYWxvZ0RPTS5hcHBlbmQoJChcIjxkaXYgY2xhc3M9J3czLWNvbnRhaW5lcicvPlwiKS5hcHBlbmQodGl0bGVUYWJsZSkpXHJcblxyXG4gICAgdmFyIHNldHRpbmdzRGl2PSQoXCI8ZGl2IGNsYXNzPSd3My1jb250YWluZXIgdzMtYm9yZGVyJyBzdHlsZT0nd2lkdGg6MTAwJTttYXgtaGVpZ2h0OjMxMHB4O292ZXJmbG93OmF1dG8nPjwvZGl2PlwiKVxyXG4gICAgdGhpcy5zZXR0aW5nc0Rpdj1zZXR0aW5nc0RpdlxyXG4gICAgZGlhbG9nRE9NLmFwcGVuZChzZXR0aW5nc0RpdilcclxuICAgIHRoaXMuZHJhd01vZGVsU2V0dGluZ3MoKVxyXG59XHJcblxyXG5uZXdUd2luRGlhbG9nLnByb3RvdHlwZS5hZGROZXdUd2luID0gYXN5bmMgZnVuY3Rpb24oY2xvc2VEaWFsb2cpIHtcclxuICAgIHZhciBtb2RlbElEPXRoaXMudHdpbkluZm9bXCIkbWV0YWRhdGFcIl1bXCIkbW9kZWxcIl1cclxuICAgIHZhciBEQk1vZGVsSW5mbz1nbG9iYWxDYWNoZS5nZXRTaW5nbGVEQk1vZGVsQnlJRChtb2RlbElEKVxyXG5cclxuICAgIGlmKCF0aGlzLnR3aW5JbmZvW1wiJGR0SWRcIl18fHRoaXMudHdpbkluZm9bXCIkZHRJZFwiXT09XCJcIil7XHJcbiAgICAgICAgYWxlcnQoXCJQbGVhc2UgZmlsbCBpbiBuYW1lIGZvciB0aGUgbmV3IGRpZ2l0YWwgdHdpblwiKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHZhciBjb21wb25lbnRzTmFtZUFycj1tb2RlbEFuYWx5emVyLkRURExNb2RlbHNbbW9kZWxJRF0uaW5jbHVkZWRDb21wb25lbnRzXHJcbiAgICBjb21wb25lbnRzTmFtZUFyci5mb3JFYWNoKG9uZUNvbXBvbmVudE5hbWU9PnsgLy9hZHQgc2VydmljZSByZXF1ZXN0aW5nIGFsbCBjb21wb25lbnQgYXBwZWFyIGJ5IG1hbmRhdG9yeVxyXG4gICAgICAgIGlmKHRoaXMudHdpbkluZm9bb25lQ29tcG9uZW50TmFtZV09PW51bGwpdGhpcy50d2luSW5mb1tvbmVDb21wb25lbnROYW1lXT17fVxyXG4gICAgICAgIHRoaXMudHdpbkluZm9bb25lQ29tcG9uZW50TmFtZV1bXCIkbWV0YWRhdGFcIl09IHt9XHJcbiAgICB9KVxyXG5cclxuICAgIC8vYXNrIHRhc2ttYXN0ZXIgdG8gYWRkIHRoZSB0d2luXHJcbiAgICB0cnl7XHJcbiAgICAgICAgdmFyIHBvc3RCb2R5PSB7XCJuZXdUd2luSnNvblwiOkpTT04uc3RyaW5naWZ5KHRoaXMudHdpbkluZm8pfVxyXG4gICAgICAgIHZhciBkYXRhID0gYXdhaXQgbXNhbEhlbHBlci5jYWxsQVBJKFwiZGlnaXRhbHR3aW4vdXBzZXJ0RGlnaXRhbFR3aW5cIiwgXCJQT1NUXCIsIHBvc3RCb2R5LFwid2l0aFByb2plY3RJRFwiIClcclxuICAgIH1jYXRjaChlKXtcclxuICAgICAgICBjb25zb2xlLmxvZyhlKVxyXG4gICAgICAgIGlmKGUucmVzcG9uc2VUZXh0KSBhbGVydChlLnJlc3BvbnNlVGV4dClcclxuICAgIH1cclxuXHJcbiAgICBnbG9iYWxDYWNoZS5zdG9yZVNpbmdsZURCVHdpbihkYXRhLkRCVHdpbikgICAgXHJcbiAgICBnbG9iYWxDYWNoZS5zdG9yZVNpbmdsZUFEVFR3aW4oZGF0YS5BRFRUd2luKVxyXG5cclxuXHJcbiAgICAvL2FzayB0YXNrbWFzdGVyIHRvIHByb3Zpc2lvbiB0aGUgdHdpbiB0byBpb3QgaHViIGlmIHRoZSBtb2RlbCBpcyBhIGlvdCBkZXZpY2UgbW9kZWxcclxuICAgIGlmKERCTW9kZWxJbmZvLmlzSW9URGV2aWNlTW9kZWwpe1xyXG4gICAgICAgIHRyeXtcclxuICAgICAgICAgICAgdmFyIHBvc3RCb2R5PSB7XCJEQlR3aW5cIjpkYXRhLkRCVHdpbixcImRlc2lyZWRJbkRldmljZVR3aW5cIjp7fX1cclxuICAgICAgICAgICAgREJNb2RlbEluZm8uZGVzaXJlZFByb3BlcnRpZXMuZm9yRWFjaChlbGU9PntcclxuICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eU5hbWU9ZWxlLnBhdGhbZWxlLnBhdGgubGVuZ3RoLTFdXHJcbiAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHlTYW1wbGVWPSBcIlwiXHJcbiAgICAgICAgICAgICAgICBwb3N0Qm9keS5kZXNpcmVkSW5EZXZpY2VUd2luW3Byb3BlcnR5TmFtZV09cHJvcGVydHlTYW1wbGVWXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIHZhciBwcm92aXNpb25lZERvY3VtZW50ID0gYXdhaXQgbXNhbEhlbHBlci5jYWxsQVBJKFwiZGV2aWNlbWFuYWdlbWVudC9wcm92aXNpb25Jb1REZXZpY2VUd2luXCIsIFwiUE9TVFwiLCBwb3N0Qm9keSxcIndpdGhQcm9qZWN0SURcIiApXHJcbiAgICAgICAgfWNhdGNoKGUpe1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlKVxyXG4gICAgICAgICAgICBpZihlLnJlc3BvbnNlVGV4dCkgYWxlcnQoZS5yZXNwb25zZVRleHQpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRhdGEuREJUd2luPXByb3Zpc2lvbmVkRG9jdW1lbnRcclxuICAgICAgICBnbG9iYWxDYWNoZS5zdG9yZVNpbmdsZURCVHdpbihwcm92aXNpb25lZERvY3VtZW50KSAgIFxyXG4gICAgfVxyXG5cclxuICAgIC8vaXQgc2hvdWxkIHNlbGVjdCB0aGUgbmV3IG5vZGUgaW4gdGhlIHRyZWUsIGFuZCBtb3ZlIHRvcG9sb2d5IHZpZXcgdG8gc2hvdyB0aGUgbmV3IG5vZGUgKG5vdGUgcGFuIHRvIGEgcGxhY2UgdGhhdCBpcyBub3QgYmxvY2tlZCBieSB0aGUgZGlhbG9nIGl0c2VsZilcclxuICAgIHRoaXMuYnJvYWRjYXN0TWVzc2FnZSh7IFwibWVzc2FnZVwiOiBcImFkZE5ld1R3aW5cIiwgXCJ0d2luSW5mb1wiOiBkYXRhLkFEVFR3aW4sIFwiREJUd2luSW5mb1wiOmRhdGEuREJUd2lufSlcclxuXHJcbiAgICBpZihjbG9zZURpYWxvZyl0aGlzLkRPTS5oaWRlKClcclxuICAgIGVsc2V7XHJcbiAgICAgICAgLy9jbGVhciB0aGUgaW5wdXQgZWRpdGJveFxyXG4gICAgICAgIHRoaXMucG9wdXAodGhpcy5vcmlnaW5hbFR3aW5JbmZvKVxyXG4gICAgfVxyXG59XHJcblxyXG5uZXdUd2luRGlhbG9nLnByb3RvdHlwZS5kcmF3TW9kZWxTZXR0aW5ncyA9IGFzeW5jIGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIG1vZGVsSUQ9dGhpcy50d2luSW5mb1tcIiRtZXRhZGF0YVwiXVtcIiRtb2RlbFwiXVxyXG4gICAgdmFyIG1vZGVsRGV0YWlsPSBtb2RlbEFuYWx5emVyLkRURExNb2RlbHNbbW9kZWxJRF1cclxuICAgIHZhciBjb3B5TW9kZWxFZGl0YWJsZVByb3BlcnR5PUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobW9kZWxEZXRhaWwuZWRpdGFibGVQcm9wZXJ0aWVzKSlcclxuICAgIFxyXG4gICAgaWYoJC5pc0VtcHR5T2JqZWN0KGNvcHlNb2RlbEVkaXRhYmxlUHJvcGVydHkpKXtcclxuICAgICAgICB0aGlzLnNldHRpbmdzRGl2LnRleHQoXCJUaGVyZSBpcyBubyBlZGl0YWJsZSBwcm9wZXJ0eVwiKVxyXG4gICAgICAgIHRoaXMuc2V0dGluZ3NEaXYuYWRkQ2xhc3MoXCJ3My10ZXh0LWdyYXlcIilcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9ICAgXHJcblxyXG4gICAgdmFyIHNldHRpbmdzVGFibGU9JCgnPHRhYmxlIHN0eWxlPVwid2lkdGg6MTAwJVwiIGNlbGxzcGFjaW5nPVwiMHB4XCIgY2VsbHBhZGRpbmc9XCIwcHhcIj48L3RhYmxlPicpXHJcbiAgICB0aGlzLnNldHRpbmdzRGl2LmFwcGVuZChzZXR0aW5nc1RhYmxlKVxyXG5cclxuICAgIHZhciBpbml0aWFsUGF0aEFycj1bXVxyXG4gICAgdmFyIGxhc3RSb290Tm9kZVJlY29yZD1bXVxyXG4gICAgdGhpcy5kcmF3RWRpdGFibGUoc2V0dGluZ3NUYWJsZSxjb3B5TW9kZWxFZGl0YWJsZVByb3BlcnR5LGluaXRpYWxQYXRoQXJyLGxhc3RSb290Tm9kZVJlY29yZClcclxufVxyXG5cclxuXHJcbm5ld1R3aW5EaWFsb2cucHJvdG90eXBlLmRyYXdFZGl0YWJsZSA9IGFzeW5jIGZ1bmN0aW9uKHBhcmVudFRhYmxlLGpzb25JbmZvLHBhdGhBcnIsbGFzdFJvb3ROb2RlUmVjb3JkKSB7XHJcbiAgICBpZihqc29uSW5mbz09bnVsbCkgcmV0dXJuO1xyXG4gICAgdmFyIGFycj1bXVxyXG4gICAgZm9yKHZhciBpbmQgaW4ganNvbkluZm8pIGFyci5wdXNoKGluZClcclxuXHJcbiAgICBmb3IodmFyIHRoZUluZGV4PTA7dGhlSW5kZXg8YXJyLmxlbmd0aDt0aGVJbmRleCsrKXtcclxuICAgICAgICBpZih0aGVJbmRleD09YXJyLmxlbmd0aC0xKSBsYXN0Um9vdE5vZGVSZWNvcmRbcGF0aEFyci5sZW5ndGhdID10cnVlO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBpbmQgPSBhcnJbdGhlSW5kZXhdXHJcbiAgICAgICAgdmFyIHRyPSQoXCI8dHIvPlwiKVxyXG4gICAgICAgIHZhciByaWdodFREPSQoXCI8dGQgc3R5bGU9J2hlaWdodDozMHB4Jy8+XCIpXHJcbiAgICAgICAgdHIuYXBwZW5kKHJpZ2h0VEQpXHJcbiAgICAgICAgcGFyZW50VGFibGUuYXBwZW5kKHRyKVxyXG4gICAgICAgIFxyXG4gICAgICAgIGZvcih2YXIgaT0wO2k8cGF0aEFyci5sZW5ndGg7aSsrKXtcclxuICAgICAgICAgICAgaWYoIWxhc3RSb290Tm9kZVJlY29yZFtpXSkgcmlnaHRURC5hcHBlbmQodGhpcy50cmVlTGluZURpdigyKSlcclxuICAgICAgICAgICAgZWxzZSByaWdodFRELmFwcGVuZCh0aGlzLnRyZWVMaW5lRGl2KDQpKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYodGhlSW5kZXg9PWFyci5sZW5ndGgtMSkgcmlnaHRURC5hcHBlbmQodGhpcy50cmVlTGluZURpdigzKSlcclxuICAgICAgICBlbHNlIHJpZ2h0VEQuYXBwZW5kKHRoaXMudHJlZUxpbmVEaXYoMSkpXHJcblxyXG4gICAgICAgIHZhciBwTmFtZURpdj0kKFwiPGRpdiBzdHlsZT0nZmxvYXQ6bGVmdDtsaW5lLWhlaWdodDoyOHB4O21hcmdpbi1sZWZ0OjNweCc+XCIraW5kK1wiPC9kaXY+XCIpXHJcbiAgICAgICAgcmlnaHRURC5hcHBlbmQocE5hbWVEaXYpXHJcbiAgICAgICAgdmFyIG5ld1BhdGg9cGF0aEFyci5jb25jYXQoW2luZF0pXHJcblxyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGpzb25JbmZvW2luZF0pKSB7IC8vaXQgaXMgYSBlbnVtZXJhdG9yXHJcbiAgICAgICAgICAgIHRoaXMuZHJhd0Ryb3BEb3duQm94KHJpZ2h0VEQsbmV3UGF0aCxqc29uSW5mb1tpbmRdKVxyXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIChqc29uSW5mb1tpbmRdKT09PVwib2JqZWN0XCIpIHtcclxuICAgICAgICAgICAgdGhpcy5kcmF3RWRpdGFibGUocGFyZW50VGFibGUsanNvbkluZm9baW5kXSxuZXdQYXRoLGxhc3RSb290Tm9kZVJlY29yZClcclxuICAgICAgICB9ZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBhSW5wdXQ9JCgnPGlucHV0IHR5cGU9XCJ0ZXh0XCIgc3R5bGU9XCJtYXJnaW4tbGVmdDo1cHg7cGFkZGluZzoycHg7d2lkdGg6MjAwcHg7b3V0bGluZTpub25lO2Rpc3BsYXk6aW5saW5lXCIgcGxhY2Vob2xkZXI9XCJ0eXBlOiAnK2pzb25JbmZvW2luZF0rJ1wiLz4nKS5hZGRDbGFzcyhcInczLWlucHV0IHczLWJvcmRlclwiKTsgIFxyXG4gICAgICAgICAgICByaWdodFRELmFwcGVuZChhSW5wdXQpXHJcbiAgICAgICAgICAgIGFJbnB1dC5kYXRhKFwicGF0aFwiLCBuZXdQYXRoKVxyXG4gICAgICAgICAgICBhSW5wdXQuZGF0YShcImRhdGFUeXBlXCIsIGpzb25JbmZvW2luZF0pXHJcbiAgICAgICAgICAgIGFJbnB1dC5jaGFuZ2UoKGUpPT57XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZU9yaWdpbk9iamVjdFZhbHVlKCQoZS50YXJnZXQpLmRhdGEoXCJwYXRoXCIpLCQoZS50YXJnZXQpLnZhbCgpLCQoZS50YXJnZXQpLmRhdGEoXCJkYXRhVHlwZVwiKSlcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9IFxyXG4gICAgfVxyXG59XHJcblxyXG5uZXdUd2luRGlhbG9nLnByb3RvdHlwZS5kcmF3RHJvcERvd25Cb3g9ZnVuY3Rpb24ocmlnaHRURCxuZXdQYXRoLHZhbHVlQXJyKXtcclxuICAgIHZhciBhU2VsZWN0TWVudSA9IG5ldyBzaW1wbGVTZWxlY3RNZW51KFwiXCJcclxuICAgICAgICAsIHsgd2lkdGg6IFwiMjAwXCIgXHJcbiAgICAgICAgICAgICxidXR0b25DU1M6IHsgXCJwYWRkaW5nXCI6IFwiNHB4IDE2cHhcIn1cclxuICAgICAgICAgICAgLCBcIm9wdGlvbkxpc3RNYXJnaW5Ub3BcIjogMjUvLyxcIm9wdGlvbkxpc3RNYXJnaW5MZWZ0XCI6MjEwXHJcbiAgICAgICAgICAgICwgXCJhZGp1c3RQb3NpdGlvbkFuY2hvclwiOiB0aGlzLkRPTS5vZmZzZXQoKVxyXG4gICAgICAgIH0pXHJcblxyXG5cclxuICAgIHJpZ2h0VEQuYXBwZW5kKGFTZWxlY3RNZW51LnJvd0RPTSkgIC8vdXNlIHJvd0RPTSBpbnN0ZWFkIG9mIERPTSB0byBhbGxvdyBzZWxlY3Qgb3B0aW9uIHdpbmRvdyBmbG9hdCBhYm92ZSBkaWFsb2dcclxuICAgIGFTZWxlY3RNZW51LkRPTS5kYXRhKFwicGF0aFwiLCBuZXdQYXRoKVxyXG4gICAgdmFsdWVBcnIuZm9yRWFjaCgob25lT3B0aW9uKSA9PiB7XHJcbiAgICAgICAgdmFyIHN0ciA9IG9uZU9wdGlvbltcImRpc3BsYXlOYW1lXCJdIHx8IG9uZU9wdGlvbltcImVudW1WYWx1ZVwiXVxyXG4gICAgICAgIGFTZWxlY3RNZW51LmFkZE9wdGlvbihzdHIpXHJcbiAgICB9KVxyXG4gICAgYVNlbGVjdE1lbnUuY2FsbEJhY2tfY2xpY2tPcHRpb24gPSAob3B0aW9uVGV4dCwgb3B0aW9uVmFsdWUsIHJlYWxNb3VzZUNsaWNrKSA9PiB7XHJcbiAgICAgICAgYVNlbGVjdE1lbnUuY2hhbmdlTmFtZShvcHRpb25UZXh0KVxyXG4gICAgICAgIGlmIChyZWFsTW91c2VDbGljaykgdGhpcy51cGRhdGVPcmlnaW5PYmplY3RWYWx1ZShhU2VsZWN0TWVudS5ET00uZGF0YShcInBhdGhcIiksIG9wdGlvblZhbHVlLCBcInN0cmluZ1wiKVxyXG4gICAgfVxyXG59XHJcblxyXG5uZXdUd2luRGlhbG9nLnByb3RvdHlwZS51cGRhdGVPcmlnaW5PYmplY3RWYWx1ZT1mdW5jdGlvbihwYXRoQXJyLG5ld1ZhbCxkYXRhVHlwZSl7XHJcbiAgICBpZihbXCJkb3VibGVcIixcImJvb2xlYW5cIixcImZsb2F0XCIsXCJpbnRlZ2VyXCIsXCJsb25nXCJdLmluY2x1ZGVzKGRhdGFUeXBlKSkgbmV3VmFsPU51bWJlcihuZXdWYWwpXHJcbiAgICBpZihwYXRoQXJyLmxlbmd0aD09MCkgcmV0dXJuO1xyXG4gICAgdmFyIHRoZUpzb249dGhpcy50d2luSW5mb1xyXG4gICAgZm9yKHZhciBpPTA7aTxwYXRoQXJyLmxlbmd0aDtpKyspe1xyXG4gICAgICAgIHZhciBrZXk9cGF0aEFycltpXVxyXG5cclxuICAgICAgICBpZihpPT1wYXRoQXJyLmxlbmd0aC0xKXtcclxuICAgICAgICAgICAgdGhlSnNvbltrZXldPW5ld1ZhbFxyXG4gICAgICAgICAgICBicmVha1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZih0aGVKc29uW2tleV09PW51bGwpIHRoZUpzb25ba2V5XT17fVxyXG4gICAgICAgIHRoZUpzb249dGhlSnNvbltrZXldXHJcbiAgICB9XHJcbn1cclxuXHJcbm5ld1R3aW5EaWFsb2cucHJvdG90eXBlLnRyZWVMaW5lRGl2ID0gZnVuY3Rpb24odHlwZU51bWJlcikge1xyXG4gICAgdmFyIHJlRGl2PSQoJzxkaXYgc3R5bGU9XCJtYXJnaW4tbGVmdDoxMHB4O3dpZHRoOjE1cHg7aGVpZ2h0OiAxMDAlO2Zsb2F0OiBsZWZ0XCI+PC9kaXY+JylcclxuICAgIGlmKHR5cGVOdW1iZXI9PTEpe1xyXG4gICAgICAgIHJlRGl2LmFwcGVuZCgkKCc8ZGl2IGNsYXNzPVwidzMtYm9yZGVyLWJvdHRvbSB3My1ib3JkZXItbGVmdFwiIHN0eWxlPVwid2lkdGg6MTAwJTtoZWlnaHQ6NTAlO1wiPjwvZGl2PjxkaXYgY2xhc3M9XCJ3My1ib3JkZXItbGVmdFwiIHN0eWxlPVwid2lkdGg6MTAwJTtoZWlnaHQ6NTAlO1wiPjwvZGl2PicpKVxyXG4gICAgfWVsc2UgaWYodHlwZU51bWJlcj09Mil7XHJcbiAgICAgICAgcmVEaXYuYXBwZW5kKCQoJzxkaXYgY2xhc3M9XCJ3My1ib3JkZXItbGVmdFwiIHN0eWxlPVwid2lkdGg6MTAwJTtoZWlnaHQ6NTAlO1wiPjwvZGl2PjxkaXYgY2xhc3M9XCJ3My1ib3JkZXItbGVmdFwiIHN0eWxlPVwid2lkdGg6MTAwJTtoZWlnaHQ6NTAlO1wiPjwvZGl2PicpKVxyXG4gICAgfWVsc2UgaWYodHlwZU51bWJlcj09Myl7XHJcbiAgICAgICAgcmVEaXYuYXBwZW5kKCQoJzxkaXYgY2xhc3M9XCJ3My1ib3JkZXItYm90dG9tIHczLWJvcmRlci1sZWZ0XCIgc3R5bGU9XCJ3aWR0aDoxMDAlO2hlaWdodDo1MCU7XCI+JykpXHJcbiAgICB9ZWxzZSBpZih0eXBlTnVtYmVyPT00KXtcclxuICAgICAgICBcclxuICAgIH1cclxuICAgIHJldHVybiByZURpdlxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBuZXdUd2luRGlhbG9nKCk7IiwiY29uc3QgbXNhbEhlbHBlcj1yZXF1aXJlKFwiLi4vbXNhbEhlbHBlclwiKVxyXG5jb25zdCBnbG9iYWxDYWNoZSA9IHJlcXVpcmUoXCIuLi9zaGFyZWRTb3VyY2VGaWxlcy9nbG9iYWxDYWNoZVwiKTtcclxuXHJcbmZ1bmN0aW9uIHNlcnZpY2VXb3JrZXJIZWxwZXIoKXtcclxuICAgIHRoaXMucHJvamVjdElEPW51bGxcclxuICAgIHRoaXMuYWxsTGl2ZU1vbml0b3I9e31cclxuICAgIHNldEludGVydmFsKCgpPT57XHJcbiAgICAgICAgaWYodGhpcy5wcm9qZWN0SUQ9PW51bGwpIHJldHVybjtcclxuICAgICAgICB0aGlzLnN1YnNjcmliZUltcG9ydGFudEV2ZW50KHRoaXMucHJvamVjdElEKVxyXG5cclxuICAgICAgICBmb3IodmFyIGluZCBpbiB0aGlzLmFsbExpdmVNb25pdG9yKXtcclxuICAgICAgICAgICAgdmFyIGFMaXZlUHJvcGVydHk9dGhpcy5hbGxMaXZlTW9uaXRvcltpbmRdXHJcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlTGl2ZVByb3BlcnR5KGFMaXZlUHJvcGVydHkudHdpbklELGFMaXZlUHJvcGVydHkucHJvcGVydHlQYXRoKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LDgqNjAqMTAwMCkgLy9ldmVyeSA4IG1pbnV0ZSByZW5ldyB0aGUgc2VydmljZSB3b3JrZXIgc3Vic2NyaXB0aW9uXHJcbn1cclxuXHJcbnNlcnZpY2VXb3JrZXJIZWxwZXIucHJvdG90eXBlLnN1YnNjcmliZUltcG9ydGFudEV2ZW50ID0gYXN5bmMgZnVuY3Rpb24gKHByb2plY3RJRCkgeyAgICBcclxuICAgIHZhciBzdWJzY3JpcHRpb249YXdhaXQgdGhpcy5jcmVhdGVTdWJzY3JpcHRpb24oKVxyXG4gICAgaWYoc3Vic2NyaXB0aW9uPT1udWxsKSByZXR1cm47XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHZhciBwYXlsb2FkPXtcclxuICAgICAgICAgICAgdHlwZTonZXZlbnRzJyxcclxuICAgICAgICAgICAgc2VydmljZVdvcmtlclN1YnNjcmlwdGlvbjpKU09OLnN0cmluZ2lmeShzdWJzY3JpcHRpb24pXHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1zYWxIZWxwZXIuY2FsbEFQSShcImRpZ2l0YWx0d2luL3NlcnZpY2VXb3JrZXJTdWJzY3JpcHRpb25cIiwgXCJQT1NUXCIsIHBheWxvYWQsIFwid2l0aFByb2plY3RJRFwiKVxyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGUpXHJcbiAgICB9XHJcbn1cclxuXHJcbnNlcnZpY2VXb3JrZXJIZWxwZXIucHJvdG90eXBlLnN1YnNjcmliZUxpdmVQcm9wZXJ0eSA9IGFzeW5jIGZ1bmN0aW9uICh0d2luSUQscHJvcGVydHlQYXRoKSB7ICAgIFxyXG4gICAgdmFyIHN1YnNjcmlwdGlvbj1hd2FpdCB0aGlzLmNyZWF0ZVN1YnNjcmlwdGlvbigpXHJcbiAgICBpZihzdWJzY3JpcHRpb249PW51bGwpIHJldHVybjtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgdmFyIHBheWxvYWQ9e1xyXG4gICAgICAgICAgICB0eXBlOidwcm9wZXJ0eVZhbHVlJyxcclxuICAgICAgICAgICAgc2VydmljZVdvcmtlclN1YnNjcmlwdGlvbjpKU09OLnN0cmluZ2lmeShzdWJzY3JpcHRpb24pLFxyXG4gICAgICAgICAgICB0d2luSUQ6dHdpbklELFxyXG4gICAgICAgICAgICBwcm9wZXJ0eVBhdGg6cHJvcGVydHlQYXRoXHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1zYWxIZWxwZXIuY2FsbEFQSShcImRpZ2l0YWx0d2luL3NlcnZpY2VXb3JrZXJTdWJzY3JpcHRpb25cIiwgXCJQT1NUXCIsIHBheWxvYWQsIFwid2l0aFByb2plY3RJRFwiKVxyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGUpIFxyXG4gICAgfVxyXG59XHJcblxyXG5zZXJ2aWNlV29ya2VySGVscGVyLnByb3RvdHlwZS51bnN1YnNjcmliZUxpdmVQcm9wZXJ0eSA9IGFzeW5jIGZ1bmN0aW9uICh0d2luSUQscHJvcGVydHlQYXRoKSB7ICAgIFxyXG4gICAgdHJ5IHtcclxuICAgICAgICBtc2FsSGVscGVyLmNhbGxBUEkoXCJkaWdpdGFsdHdpbi9zZXJ2aWNlV29ya2VyVW5zdWJzY3JpcHRpb25cIiwgXCJQT1NUXCIsIHt0d2luSUQ6dHdpbklELHByb3BlcnR5UGF0aDpwcm9wZXJ0eVBhdGh9LCBcIndpdGhQcm9qZWN0SURcIilcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhlKVxyXG4gICAgfVxyXG59XHJcblxyXG5zZXJ2aWNlV29ya2VySGVscGVyLnByb3RvdHlwZS5jcmVhdGVTdWJzY3JpcHRpb24gPSBhc3luYyBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAoISgnc2VydmljZVdvcmtlcicgaW4gbmF2aWdhdG9yKSkgcmV0dXJuIG51bGw7XHJcbiAgICAvL3RoaXMgcHVibGljIGtleSBzaG91bGQgYmUgdGhlIG9uZSB1c2VkIGluIGJhY2tlbmQgc2VydmVyIHNpZGUgZm9yIHB1c2hpbmcgbWVzc2FnZSAoaW4gYXp1cmVpb3Ryb2Nrc2Z1bmN0aW9uKVxyXG4gICAgY29uc3QgcHVibGljVmFwaWRLZXkgPSAnQkN4dkZxazBjeklrQ1RibEFNeTgwZk1XVGoyV2FBa2VYQ3lwOTgtUzJNaVZyVEw1OXUwNDZlTFJyVEJJbW85WkNXQVEzWXFqXzdQd0VPdXloRG1DLVdZJztcclxuICAgIHZhciBzdWJzY3JpcHRpb24gPSBudWxsXHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHJlZ2lzdHJhdGlvbiA9IGF3YWl0IG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLnJlZ2lzdGVyKCcvd29ya2VyLmpzJywgeyBzY29wZTogJy8nIH0pO1xyXG4gICAgICAgIHN1YnNjcmlwdGlvbiA9IGF3YWl0IHJlZ2lzdHJhdGlvbi5wdXNoTWFuYWdlci5zdWJzY3JpYmUoe1xyXG4gICAgICAgICAgICB1c2VyVmlzaWJsZU9ubHk6IHRydWUsXHJcbiAgICAgICAgICAgIGFwcGxpY2F0aW9uU2VydmVyS2V5OiBwdWJsaWNWYXBpZEtleVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLm9ubWVzc2FnZSA9IChlKT0+IHtcclxuICAgICAgICAgICAgdGhpcy5wcm9jZXNzTGl2ZU1lc3NhZ2UoZS5kYXRhKVxyXG4gICAgICAgICAgICB0aGlzLmJyb2FkY2FzdE1lc3NhZ2UoeyBcIm1lc3NhZ2VcIjogXCJsaXZlRGF0YVwiLFwiYm9keVwiOmUuZGF0YSB9KVxyXG4gICAgICAgIH07XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coZSlcclxuICAgIH1cclxuICAgIHJldHVybiBzdWJzY3JpcHRpb247XHJcbn1cclxuXHJcbnNlcnZpY2VXb3JrZXJIZWxwZXIucHJvdG90eXBlLnByb2Nlc3NMaXZlTWVzc2FnZT1mdW5jdGlvbihtc2dCb2R5KXtcclxuICAgIC8vY29uc29sZS5sb2cobXNnQm9keSlcclxuICAgIGlmKG1zZ0JvZHkuY29ubmVjdGlvblN0YXRlICYmIG1zZ0JvZHkucHJvamVjdElEPT1nbG9iYWxDYWNoZS5jdXJyZW50UHJvamVjdElEKXtcclxuICAgICAgICB2YXIgdHdpbklEPW1zZ0JvZHkudHdpbklEXHJcbiAgICAgICAgdmFyIHR3aW5EQkluZm89Z2xvYmFsQ2FjaGUuREJUd2luc1t0d2luSURdXHJcbiAgICAgICAgaWYobXNnQm9keS5jb25uZWN0aW9uU3RhdGU9PVwiZGV2aWNlQ29ubmVjdGVkXCIpIHR3aW5EQkluZm8uY29ubmVjdFN0YXRlPXRydWVcclxuICAgICAgICBlbHNlIHR3aW5EQkluZm8uY29ubmVjdFN0YXRlPWZhbHNlXHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyhtc2dCb2R5KVxyXG4gICAgfWVsc2UgaWYobXNnQm9keS5wcm9wZXJ0eVBhdGgpe1xyXG4gICAgICAgIHZhciB0d2luSW5mbz1nbG9iYWxDYWNoZS5zdG9yZWRUd2luc1ttc2dCb2R5LnR3aW5JRF1cclxuICAgICAgICB0aGlzLnVwZGF0ZU9yaWdpbk9iamVjdFZhbHVlKHR3aW5JbmZvLG1zZ0JvZHkucHJvcGVydHlQYXRoLG1zZ0JvZHkudmFsdWUpXHJcbiAgICB9XHJcbn1cclxuXHJcbnNlcnZpY2VXb3JrZXJIZWxwZXIucHJvdG90eXBlLnVwZGF0ZU9yaWdpbk9iamVjdFZhbHVlPWZ1bmN0aW9uKG5vZGVJbmZvLCBwYXRoQXJyLCBuZXdWYWwpIHtcclxuICAgIGlmIChwYXRoQXJyLmxlbmd0aCA9PSAwKSByZXR1cm47XHJcbiAgICB2YXIgdGhlSnNvbiA9IG5vZGVJbmZvXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGhBcnIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIga2V5ID0gcGF0aEFycltpXVxyXG5cclxuICAgICAgICBpZiAoaSA9PSBwYXRoQXJyLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgdGhlSnNvbltrZXldID0gbmV3VmFsXHJcbiAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGVKc29uW2tleV0gPT0gbnVsbCkgdGhlSnNvbltrZXldID0ge31cclxuICAgICAgICB0aGVKc29uID0gdGhlSnNvbltrZXldXHJcbiAgICB9XHJcbn1cclxuXHJcbnNlcnZpY2VXb3JrZXJIZWxwZXIucHJvdG90eXBlLnJ4TWVzc2FnZT1mdW5jdGlvbihtc2dQYXlsb2FkKXtcclxuICAgIGlmKG1zZ1BheWxvYWQubWVzc2FnZT09XCJwcm9qZWN0SXNDaGFuZ2VkXCIpe1xyXG4gICAgICAgIGZvcih2YXIgaW5kIGluIHRoaXMuYWxsTGl2ZU1vbml0b3IpIGRlbGV0ZSB0aGlzLmFsbExpdmVNb25pdG9yW2luZF1cclxuICAgICAgICB0aGlzLnByb2plY3RJRD1tc2dQYXlsb2FkLnByb2plY3RJRFxyXG4gICAgICAgIHRoaXMuc3Vic2NyaWJlSW1wb3J0YW50RXZlbnQobXNnUGF5bG9hZC5wcm9qZWN0SUQpXHJcbiAgICB9ZWxzZSBpZihtc2dQYXlsb2FkLm1lc3NhZ2U9PVwiYWRkTGl2ZU1vbml0b3JcIil7XHJcbiAgICAgICAgdmFyIHN0cj10aGlzLmdlbmVyYXRlSUQobXNnUGF5bG9hZC50d2luSUQsbXNnUGF5bG9hZC5wcm9wZXJ0eVBhdGgpXHJcbiAgICAgICAgdGhpcy5hbGxMaXZlTW9uaXRvcltzdHJdPW1zZ1BheWxvYWRcclxuICAgICAgICB0aGlzLnN1YnNjcmliZUxpdmVQcm9wZXJ0eShtc2dQYXlsb2FkLnR3aW5JRCxtc2dQYXlsb2FkLnByb3BlcnR5UGF0aClcclxuICAgIH1lbHNlIGlmKG1zZ1BheWxvYWQubWVzc2FnZT09XCJyZW1vdmVMaXZlTW9uaXRvclwiKXtcclxuICAgICAgICB2YXIgc3RyPXRoaXMuZ2VuZXJhdGVJRChtc2dQYXlsb2FkLnR3aW5JRCxtc2dQYXlsb2FkLnByb3BlcnR5UGF0aClcclxuICAgICAgICBkZWxldGUgdGhpcy5hbGxMaXZlTW9uaXRvcltzdHJdXHJcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZUxpdmVQcm9wZXJ0eShtc2dQYXlsb2FkLnR3aW5JRCxtc2dQYXlsb2FkLnByb3BlcnR5UGF0aClcclxuICAgIH1cclxufVxyXG5cclxuc2VydmljZVdvcmtlckhlbHBlci5wcm90b3R5cGUuZ2VuZXJhdGVJRD1mdW5jdGlvbih0d2luSUQscHJvcGVydHlQYXRoKXtcclxuICAgIHJldHVybiB0d2luSUQrXCIuXCIrcHJvcGVydHlQYXRoLmpvaW4oXCIuXCIpXHJcbn1cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBzZXJ2aWNlV29ya2VySGVscGVyKCk7IiwiZnVuY3Rpb24gc2ltcGxlQ2hhcnQocGFyZW50RG9tLHhMZW5ndGgsY3NzT3B0aW9ucyxjdXN0b21EcmF3aW5nKXtcclxuICAgIHRoaXMuY2hhcnRET009JChcIjxkaXYvPlwiKVxyXG4gICAgcGFyZW50RG9tLmFwcGVuZCh0aGlzLmNoYXJ0RE9NKVxyXG4gICAgaWYoY3VzdG9tRHJhd2luZyl7XHJcbiAgICAgICAgY3VzdG9tRHJhd2luZyh0aGlzLmNoYXJ0RE9NKVxyXG4gICAgfVxyXG4gICAgdGhpcy5jYW52YXMgPSAkKCc8Y2FudmFzPjwvY2FudmFzPicpXHJcbiAgICB0aGlzLmNhbnZhcy5jc3MoY3NzT3B0aW9ucylcclxuICAgIHRoaXMuY2hhcnRET00uYXBwZW5kKHRoaXMuY2FudmFzKVxyXG4gICAgXHJcbiAgICB0aGlzLmNoYXJ0PW5ldyBDaGFydCh0aGlzLmNhbnZhcywge1xyXG4gICAgICAgIHR5cGU6IFwibGluZVwiLFxyXG4gICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgbGFiZWxzOiBbXSxcclxuICAgICAgICAgICAgZGF0YXNldHM6IFt7c3RlcHBlZDp0cnVlLCBkYXRhOiBbXX1dXHJcbiAgICAgICAgfSxcclxuICAgICAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgICAgIGFuaW1hdGlvbjogZmFsc2UsXHJcbiAgICAgICAgICAgIGRhdGFzZXRzOiB7XHJcbiAgICAgICAgICAgICAgICBsaW5lOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3BhbkdhcHM6dHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogXCJyZ2JhKDAsMCwyNTUsMC43KVwiLFxyXG4gICAgICAgICAgICAgICAgICAgIGJvcmRlcldpZHRoOjEsXHJcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRSYWRpdXM6MFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBwbHVnaW5zOntcclxuICAgICAgICAgICAgICAgIGxlZ2VuZDogeyBkaXNwbGF5OiBmYWxzZSB9LFxyXG4gICAgICAgICAgICAgICAgdG9vbHRpcDp7ZW5hYmxlZDpmYWxzZX1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2NhbGVzOiB7XHJcbiAgICAgICAgICAgICAgICB4OntncmlkOntkaXNwbGF5OmZhbHNlfSx0aWNrczp7ZGlzcGxheTpmYWxzZX19XHJcbiAgICAgICAgICAgICAgICAseTp7Z3JpZDp7dGlja0xlbmd0aDowfSx0aWNrczp7Zm9udDp7c2l6ZTo5fX19XHJcbiAgICAgICAgICAgICAgICAseDI6IHtwb3NpdGlvbjondG9wJyxncmlkOntkaXNwbGF5OmZhbHNlfSx0aWNrczp7ZGlzcGxheTpmYWxzZX19XHJcbiAgICAgICAgICAgICAgICAseTI6IHtwb3NpdGlvbjoncmlnaHQnLGdyaWQ6e2Rpc3BsYXk6ZmFsc2V9LHRpY2tzOntkaXNwbGF5OmZhbHNlfX0gICAgIFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgdGhpcy5zZXRYTGVuZ3RoKHhMZW5ndGgpXHJcbn1cclxuXHJcbnNpbXBsZUNoYXJ0LnByb3RvdHlwZS5zZXREYXRhQXJyPWZ1bmN0aW9uKGRhdGFBcnIpe1xyXG4gICAgdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzWzBdLmRhdGE9ZGF0YUFyclxyXG4gICAgdGhpcy5jaGFydC51cGRhdGUoKVxyXG59XHJcblxyXG5zaW1wbGVDaGFydC5wcm90b3R5cGUuYWRkRGF0YVZhbHVlPWZ1bmN0aW9uKGRhdGFJbmRleCx2YWx1ZSl7XHJcbiAgICB2YXIgZGF0YUFycj10aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbMF0uZGF0YVxyXG5cclxuICAgIHZhciB0b3RhbFBvaW50cz1kYXRhQXJyLmxlbmd0aFxyXG5cclxuICAgIGlmKHRoaXMubGFzdERhdGFJbmRleD09bnVsbCkgdGhpcy5sYXN0RGF0YUluZGV4PWRhdGFJbmRleC0xXHJcbiAgICBpZihkYXRhSW5kZXg8dGhpcy5sYXN0RGF0YUluZGV4KXtcclxuICAgICAgICBpZih0aGlzLmxhc3REYXRhSW5kZXgtZGF0YUluZGV4Pj10b3RhbFBvaW50cykgcmV0dXJuOyAvL2lnbm9yZSByZWNlaXZpbmcgdG9vIG9sZCBwb2ludHNcclxuICAgICAgICB2YXIgZGlmZj10aGlzLmxhc3REYXRhSW5kZXggLSBkYXRhSW5kZXhcclxuICAgICAgICBkYXRhQXJyW3RvdGFsUG9pbnRzLTEtZGlmZl09dmFsdWVcclxuICAgIH1lbHNle1xyXG4gICAgICAgIHZhciBudW1PZlBhc3NlZFBvaW50cz1kYXRhSW5kZXgtdGhpcy5sYXN0RGF0YUluZGV4XHJcbiAgICAgICAgZGF0YUFycj1kYXRhQXJyLnNsaWNlKG51bU9mUGFzc2VkUG9pbnRzKVxyXG4gICAgICAgIGRhdGFBcnJbdG90YWxQb2ludHMtMV09dmFsdWVcclxuICAgIH1cclxuICAgIHRoaXMuc2V0RGF0YUFycihkYXRhQXJyKVxyXG4gICAgdGhpcy5sYXN0RGF0YUluZGV4PWRhdGFJbmRleFxyXG59XHJcblxyXG5zaW1wbGVDaGFydC5wcm90b3R5cGUuc2V0WExlbmd0aD1mdW5jdGlvbih4bGVuKXtcclxuICAgIHZhciBsYWJlbHM9dGhpcy5jaGFydC5kYXRhLmxhYmVsc1xyXG4gICAgbGFiZWxzLmxlbmd0aD0wXHJcbiAgICBmb3IodmFyIGk9MDtpPHhsZW47aSsrKSBsYWJlbHMucHVzaChpKVxyXG4gICAgLy9zaG9ydGVuIG9yIGV4cGFuZCB0aGUgbGVuZ3RoIG9mIGRhdGEgYXJyYXlcclxuICAgIHZhciBkYXRhQXJyPXRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1swXS5kYXRhXHJcbiAgICBpZihkYXRhQXJyLmxlbmd0aD54bGVuKSBkYXRhQXJyPWRhdGFBcnIuc2xpY2UoZGF0YUFyci5sZW5ndGgteGxlbilcclxuICAgIGVsc2UgaWYoZGF0YUFyci5sZW5ndGg8eGxlbil7XHJcbiAgICAgICAgdmFyIG51bWJlclRvQWRkPXhsZW4tZGF0YUFyci5sZW5ndGhcclxuICAgICAgICB2YXIgdG1wQXJyPVtdXHJcbiAgICAgICAgdG1wQXJyW251bWJlclRvQWRkLTFdPW51bGxcclxuICAgICAgICBkYXRhQXJyPXRtcEFyci5jb25jYXQoZGF0YUFycilcclxuICAgIH1cclxuICAgIHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1swXS5kYXRhPWRhdGFBcnJcclxuICAgIHRoaXMuY2hhcnQudXBkYXRlKClcclxufVxyXG5cclxuc2ltcGxlQ2hhcnQucHJvdG90eXBlLmRlc3Ryb3k9ZnVuY3Rpb24oKXtcclxuICAgIHRoaXMuY2hhcnRET00ucmVtb3ZlKClcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBzaW1wbGVDaGFydDsiLCJjb25zdCBnbG9iYWxDYWNoZT1yZXF1aXJlKCcuL2dsb2JhbENhY2hlJylcclxuZnVuY3Rpb24gc2ltcGxlQ29uZmlybURpYWxvZygpe1xyXG4gICAgdGhpcy5ET00gPSAkKCc8ZGl2IHN0eWxlPVwicG9zaXRpb246YWJzb2x1dGU7dG9wOjUwJTtiYWNrZ3JvdW5kLWNvbG9yOndoaXRlO2xlZnQ6NTAlO3RyYW5zZm9ybTogdHJhbnNsYXRlWCgtNTAlKSB0cmFuc2xhdGVZKC01MCUpO3otaW5kZXg6MTAyXCIgY2xhc3M9XCJ3My1jYXJkLTRcIj48L2Rpdj4nKVxyXG4gICAgZ2xvYmFsQ2FjaGUubWFrZURPTURyYWdnYWJsZSh0aGlzLkRPTSlcclxuICAgIC8vdGhpcy5ET00uY3NzKFwib3ZlcmZsb3dcIixcImhpZGRlblwiKVxyXG59XHJcblxyXG5zaW1wbGVDb25maXJtRGlhbG9nLnByb3RvdHlwZS5zaG93PWZ1bmN0aW9uKGNzc09wdGlvbnMsb3RoZXJPcHRpb25zKXtcclxuICAgIHRoaXMuRE9NLmNzcyhjc3NPcHRpb25zKVxyXG4gICAgdGhpcy5ET00uYXBwZW5kKCQoJzxkaXYgc3R5bGU9XCJoZWlnaHQ6NDBweFwiIGNsYXNzPVwidzMtYmFyIHczLXJlZFwiPjxkaXYgY2xhc3M9XCJ3My1iYXItaXRlbVwiIHN0eWxlPVwiZm9udC1zaXplOjEuMmVtXCI+JyArIG90aGVyT3B0aW9ucy50aXRsZSArICc8L2Rpdj48L2Rpdj4nKSlcclxuICAgIHZhciBjbG9zZUJ1dHRvbiA9ICQoJzxidXR0b24gY2xhc3M9XCJ3My1iYXItaXRlbSB3My1idXR0b24gdzMtcmlnaHRcIiBzdHlsZT1cImZvbnQtc2l6ZToyZW07cGFkZGluZy10b3A6NHB4XCI+w5c8L2J1dHRvbj4nKVxyXG4gICAgdGhpcy5ET00uY2hpbGRyZW4oJzpmaXJzdCcpLmFwcGVuZChjbG9zZUJ1dHRvbilcclxuICAgIGNsb3NlQnV0dG9uLm9uKFwiY2xpY2tcIiwgKCkgPT4geyB0aGlzLmNsb3NlKCkgfSlcclxuXHJcbiAgICB2YXIgZGlhbG9nRGl2PSQoJzxkaXYgY2xhc3M9XCJ3My1jb250YWluZXJcIiBzdHlsZT1cIm1hcmdpbi10b3A6MTBweDttYXJnaW4tYm90dG9tOjEwcHhcIj48L2Rpdj4nKVxyXG4gICAgaWYob3RoZXJPcHRpb25zLmN1c3RvbURyYXdpbmcpe1xyXG4gICAgICAgIG90aGVyT3B0aW9ucy5jdXN0b21EcmF3aW5nKGRpYWxvZ0RpdilcclxuICAgIH1lbHNle1xyXG4gICAgICAgIGRpYWxvZ0Rpdi50ZXh0KG90aGVyT3B0aW9ucy5jb250ZW50KVxyXG4gICAgfVxyXG4gICAgdGhpcy5ET00uYXBwZW5kKGRpYWxvZ0RpdilcclxuICAgIHRoaXMuZGlhbG9nRGl2PWRpYWxvZ0RpdlxyXG5cclxuICAgIHRoaXMuYm90dG9tQmFyPSQoJzxkaXYgY2xhc3M9XCJ3My1iYXJcIj48L2Rpdj4nKVxyXG4gICAgdGhpcy5ET00uYXBwZW5kKHRoaXMuYm90dG9tQmFyKVxyXG5cclxuICAgIGlmKCFvdGhlck9wdGlvbnMuYnV0dG9ucykgb3RoZXJPcHRpb25zLmJ1dHRvbnM9W11cclxuICAgIG90aGVyT3B0aW9ucy5idXR0b25zLmZvckVhY2goYnRuPT57XHJcbiAgICAgICAgdmFyIGFCdXR0b249JCgnPGJ1dHRvbiBjbGFzcz1cInczLXJpcHBsZSB3My1idXR0b24gdzMtcmlnaHQgJysoYnRuLmNvbG9yQ2xhc3N8fFwiXCIpKydcIiBzdHlsZT1cIm1hcmdpbi1yaWdodDoycHg7bWFyZ2luLWxlZnQ6MnB4XCI+JytidG4udGV4dCsnPC9idXR0b24+JylcclxuICAgICAgICBhQnV0dG9uLm9uKFwiY2xpY2tcIiwoKT0+IHsgYnRuLmNsaWNrRnVuYygpICB9ICApXHJcbiAgICAgICAgdGhpcy5ib3R0b21CYXIuYXBwZW5kKGFCdXR0b24pICAgIFxyXG4gICAgfSlcclxuICAgICQoXCJib2R5XCIpLmFwcGVuZCh0aGlzLkRPTSlcclxufVxyXG5cclxuc2ltcGxlQ29uZmlybURpYWxvZy5wcm90b3R5cGUuY2xvc2U9ZnVuY3Rpb24oKXtcclxuICAgIHRoaXMuRE9NLnJlbW92ZSgpXHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gc2ltcGxlQ29uZmlybURpYWxvZzsiLCJmdW5jdGlvbiBzaW1wbGVFeHBhbmRhYmxlU2VjdGlvbih0aXRsZVN0cixwYXJlbnRET00sb3B0aW9ucykge1xyXG4gICAgdGhpcy5leHBhbmRTdGF0dXM9ZmFsc2VcclxuICAgIG9wdGlvbnM9b3B0aW9uc3x8e31cclxuICAgIHZhciBtYXJnaW5Ub3A9MTBcclxuICAgIGlmKG9wdGlvbnMubWFyZ2luVG9wIT1udWxsKSBtYXJnaW5Ub3A9b3B0aW9ucy5tYXJnaW5Ub3BcclxuICAgIHRoaXMuaGVhZGVyRE9NID0gJChgPGJ1dHRvbiBjbGFzcz1cInczLWJ1dHRvbiB3My1ibG9jayB3My1saWdodC1ncmV5IHczLWxlZnQtYWxpZ24gdzMtYm9yZGVyLWJvdHRvbSB3My1ob3Zlci1hbWJlciB3My10ZXh0LWdyYXlcIiBzdHlsZT1cIm1hcmdpbi10b3A6JHttYXJnaW5Ub3B9cHg7Zm9udC13ZWlnaHQ6Ym9sZFwiPjxhPiR7dGl0bGVTdHJ9PC9hPjxpIGNsYXNzPVwidzMtbWFyZ2luLWxlZnQgZmFzIGZhLWNhcmV0LXVwXCI+PC9pPjwvYnV0dG9uPmApXHJcbiAgICB0aGlzLmxpc3RET00gPSAkKCc8ZGl2IGNsYXNzPVwidzMtY29udGFpbmVyIHczLWhpZGVcIiBzdHlsZT1cInBhZGRpbmctdG9wOjJweFwiPjwvZGl2PicpXHJcblxyXG4gICAgdGhpcy5oZWFkZXJUZXh0RE9NPXRoaXMuaGVhZGVyRE9NLmNoaWxkcmVuKFwiOmZpcnN0XCIpXHJcblxyXG4gICAgdGhpcy50cmlhbmdsZT10aGlzLmhlYWRlckRPTS5jaGlsZHJlbignaScpLmVxKDApXHJcbiAgICBwYXJlbnRET00uYXBwZW5kKHRoaXMuaGVhZGVyRE9NLCB0aGlzLmxpc3RET00pXHJcbiAgICB0aGlzLmhlYWRlckRPTS5vbihcImNsaWNrXCIsIChldnQpID0+IHtcclxuICAgICAgICBpZih0aGlzLmV4cGFuZFN0YXR1cykgdGhpcy5zaHJpbmsoKVxyXG4gICAgICAgIGVsc2UgdGhpcy5leHBhbmQoKVxyXG4gICAgICAgIHRoaXMuY2FsbEJhY2tfY2hhbmdlKHRoaXMuZXhwYW5kU3RhdHVzKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH0pO1xyXG4gICAgdGhpcy5jYWxsQmFja19jaGFuZ2U9KHN0YXR1cyk9Pnt9XHJcbn1cclxuXHJcbnNpbXBsZUV4cGFuZGFibGVTZWN0aW9uLnByb3RvdHlwZS5leHBhbmQ9ZnVuY3Rpb24oKXtcclxuICAgIHRoaXMubGlzdERPTS5hZGRDbGFzcyhcInczLXNob3dcIilcclxuICAgIHRoaXMudHJpYW5nbGUuYWRkQ2xhc3MoXCJmYS1jYXJldC1kb3duXCIpXHJcbiAgICB0aGlzLnRyaWFuZ2xlLnJlbW92ZUNsYXNzKFwiZmEtY2FyZXQtdXBcIilcclxuICAgIHRoaXMuZXhwYW5kU3RhdHVzID0gdHJ1ZVxyXG59XHJcblxyXG5zaW1wbGVFeHBhbmRhYmxlU2VjdGlvbi5wcm90b3R5cGUuc2hyaW5rPWZ1bmN0aW9uKCl7XHJcbiAgICB0aGlzLmxpc3RET00ucmVtb3ZlQ2xhc3MoXCJ3My1zaG93XCIpXHJcbiAgICB0aGlzLnRyaWFuZ2xlLnJlbW92ZUNsYXNzKFwiZmEtY2FyZXQtZG93blwiKVxyXG4gICAgdGhpcy50cmlhbmdsZS5hZGRDbGFzcyhcImZhLWNhcmV0LXVwXCIpXHJcbiAgICB0aGlzLmV4cGFuZFN0YXR1cyA9IGZhbHNlXHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gc2ltcGxlRXhwYW5kYWJsZVNlY3Rpb247IiwiZnVuY3Rpb24gc2ltcGxlU2VsZWN0TWVudShidXR0b25OYW1lLG9wdGlvbnMpe1xyXG4gICAgb3B0aW9ucz1vcHRpb25zfHx7fSAvL3tpc0NsaWNrYWJsZToxLHdpdGhCb3JkZXI6MSxmb250U2l6ZTpcIlwiLGNvbG9yQ2xhc3M6XCJcIixidXR0b25DU1M6XCJcIn1cclxuICAgIGlmKG9wdGlvbnMuaXNDbGlja2FibGUpe1xyXG4gICAgICAgIHRoaXMuaXNDbGlja2FibGU9dHJ1ZVxyXG4gICAgICAgIHRoaXMuRE9NPSQoJzxkaXYgY2xhc3M9XCJ3My1kcm9wZG93bi1jbGlja1wiPjwvZGl2PicpXHJcbiAgICB9ZWxzZXtcclxuICAgICAgICB0aGlzLkRPTT0kKCc8ZGl2IGNsYXNzPVwidzMtZHJvcGRvd24taG92ZXIgXCI+PC9kaXY+JylcclxuICAgICAgICB0aGlzLkRPTS5vbihcIm1vdXNlb3ZlclwiLChlKT0+e1xyXG4gICAgICAgICAgICB0aGlzLmFkanVzdERyb3BEb3duUG9zaXRpb24oKVxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vaXQgc2VlbXMgdGhhdCB0aGUgc2VsZWN0IG1lbnUgb25seSBjYW4gc2hvdyBvdXRzaWRlIG9mIGEgcGFyZW50IHNjcm9sbGFibGUgZG9tIHdoZW4gaXQgaXMgaW5zaWRlIGEgdzMtYmFyIGl0ZW0uLi4gbm90IHZlcnkgc3VyZSBhYm91dCB3aHkgXHJcbiAgICB2YXIgcm93RE9NPSQoJzxkaXYgY2xhc3M9XCJ3My1iYXJcIiBzdHlsZT1cImRpc3BsYXk6aW5saW5lLWJsb2NrO21hcmdpbi1sZWZ0OjVweFwiPjwvZGl2PicpXHJcbiAgICByb3dET00uY3NzKFwid2lkdGhcIiwob3B0aW9ucy53aWR0aHx8MTAwKStcInB4XCIpXHJcbiAgICB0aGlzLnJvd0RPTT1yb3dET01cclxuICAgIHRoaXMucm93RE9NLmFwcGVuZCh0aGlzLkRPTSlcclxuICAgIFxyXG4gICAgdGhpcy5idXR0b249JCgnPGJ1dHRvbiBjbGFzcz1cInczLWJ1dHRvblwiIHN0eWxlPVwib3V0bGluZTogbm9uZTtcIj48YT4nK2J1dHRvbk5hbWUrJzwvYT48YSBzdHlsZT1cImZvbnQtd2VpZ2h0OmJvbGQ7cGFkZGluZy1sZWZ0OjJweFwiPjwvYT48aSBjbGFzcz1cImZhIGZhLWNhcmV0LWRvd25cIiBzdHlsZT1cInBhZGRpbmctbGVmdDozcHhcIj48L2k+PC9idXR0b24+JylcclxuICAgIGlmKG9wdGlvbnMud2l0aEJvcmRlcikgdGhpcy5idXR0b24uYWRkQ2xhc3MoXCJ3My1ib3JkZXJcIilcclxuICAgIGlmKG9wdGlvbnMuZm9udFNpemUpIHRoaXMuRE9NLmNzcyhcImZvbnQtc2l6ZVwiLG9wdGlvbnMuZm9udFNpemUpXHJcbiAgICBpZihvcHRpb25zLmNvbG9yQ2xhc3MpIHRoaXMuYnV0dG9uLmFkZENsYXNzKG9wdGlvbnMuY29sb3JDbGFzcylcclxuICAgIGlmKG9wdGlvbnMud2lkdGgpIHRoaXMuYnV0dG9uLmNzcyhcIndpZHRoXCIsb3B0aW9ucy53aWR0aClcclxuICAgIGlmKG9wdGlvbnMuYnV0dG9uQ1NTKSB0aGlzLmJ1dHRvbi5jc3Mob3B0aW9ucy5idXR0b25DU1MpXHJcbiAgICBpZihvcHRpb25zLmFkanVzdFBvc2l0aW9uQW5jaG9yKSB0aGlzLmFkanVzdFBvc2l0aW9uQW5jaG9yPW9wdGlvbnMuYWRqdXN0UG9zaXRpb25BbmNob3JcclxuXHJcbiAgICB0aGlzLm9wdGlvbkNvbnRlbnRET009JCgnPGRpdiBjbGFzcz1cInczLWRyb3Bkb3duLWNvbnRlbnQgdzMtYmFyLWJsb2NrIHczLWNhcmQtNFwiPjwvZGl2PicpXHJcbiAgICBpZihvcHRpb25zLm9wdGlvbkxpc3RIZWlnaHQpIHRoaXMub3B0aW9uQ29udGVudERPTS5jc3Moe1wibWF4LWhlaWdodFwiOm9wdGlvbnMub3B0aW9uTGlzdEhlaWdodCtcInB4XCIsXCJvdmVyZmxvdy15XCI6XCJhdXRvXCIsXCJvdmVyZmxvdy14XCI6XCJ2aXNpYmxlXCJ9KVxyXG4gICAgaWYob3B0aW9ucy5vcHRpb25MaXN0TWFyZ2luVG9wKSB0aGlzLm9wdGlvbkNvbnRlbnRET00uY3NzKHtcIm1hcmdpbi10b3BcIjpvcHRpb25zLm9wdGlvbkxpc3RNYXJnaW5Ub3ArXCJweFwifSlcclxuICAgIGlmKG9wdGlvbnMub3B0aW9uTGlzdE1hcmdpbkxlZnQpIHRoaXMub3B0aW9uQ29udGVudERPTS5jc3Moe1wibWFyZ2luLWxlZnRcIjpvcHRpb25zLm9wdGlvbkxpc3RNYXJnaW5MZWZ0K1wicHhcIn0pXHJcbiAgICBcclxuICAgIHRoaXMuRE9NLmFwcGVuZCh0aGlzLmJ1dHRvbix0aGlzLm9wdGlvbkNvbnRlbnRET00pXHJcbiAgICB0aGlzLmN1clNlbGVjdFZhbD1udWxsO1xyXG5cclxuICAgIGlmKG9wdGlvbnMuaXNDbGlja2FibGUpe1xyXG4gICAgICAgIHRoaXMuYnV0dG9uLm9uKFwiY2xpY2tcIiwoZSk9PntcclxuICAgICAgICAgICAgdGhpcy5hZGp1c3REcm9wRG93blBvc2l0aW9uKClcclxuICAgICAgICAgICAgaWYodGhpcy5vcHRpb25Db250ZW50RE9NLmhhc0NsYXNzKFwidzMtc2hvd1wiKSkgIHRoaXMub3B0aW9uQ29udGVudERPTS5yZW1vdmVDbGFzcyhcInczLXNob3dcIilcclxuICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FsbEJhY2tfYmVmb3JlQ2xpY2tFeHBhbmQoKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25Db250ZW50RE9NLmFkZENsYXNzKFwidzMtc2hvd1wiKVxyXG4gICAgICAgICAgICB9IFxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfSkgICAgXHJcbiAgICB9XHJcbn1cclxuXHJcbnNpbXBsZVNlbGVjdE1lbnUucHJvdG90eXBlLnNocmluaz1mdW5jdGlvbigpe1xyXG4gICAgaWYodGhpcy5vcHRpb25Db250ZW50RE9NLmhhc0NsYXNzKFwidzMtc2hvd1wiKSkgIHRoaXMub3B0aW9uQ29udGVudERPTS5yZW1vdmVDbGFzcyhcInczLXNob3dcIilcclxufVxyXG5cclxuc2ltcGxlU2VsZWN0TWVudS5wcm90b3R5cGUuYWRqdXN0RHJvcERvd25Qb3NpdGlvbj1mdW5jdGlvbigpe1xyXG4gICAgaWYoIXRoaXMuYWRqdXN0UG9zaXRpb25BbmNob3IpIHJldHVybjtcclxuICAgIHZhciBvZmZzZXQ9dGhpcy5ET00ub2Zmc2V0KClcclxuICAgIHZhciBuZXdUb3A9b2Zmc2V0LnRvcC10aGlzLmFkanVzdFBvc2l0aW9uQW5jaG9yLnRvcFxyXG4gICAgdmFyIG5ld0xlZnQ9b2Zmc2V0LmxlZnQtdGhpcy5hZGp1c3RQb3NpdGlvbkFuY2hvci5sZWZ0XHJcbiAgICB0aGlzLm9wdGlvbkNvbnRlbnRET00uY3NzKHtcInRvcFwiOm5ld1RvcCtcInB4XCIsXCJsZWZ0XCI6bmV3TGVmdCtcInB4XCJ9KVxyXG59XHJcblxyXG5zaW1wbGVTZWxlY3RNZW51LnByb3RvdHlwZS5maW5kT3B0aW9uPWZ1bmN0aW9uKG9wdGlvblZhbHVlKXtcclxuICAgIHZhciBvcHRpb25zPXRoaXMub3B0aW9uQ29udGVudERPTS5jaGlsZHJlbigpXHJcbiAgICBmb3IodmFyIGk9MDtpPG9wdGlvbnMubGVuZ3RoO2krKyl7XHJcbiAgICAgICAgdmFyIGFuT3B0aW9uPSQob3B0aW9uc1tpXSlcclxuICAgICAgICBpZihvcHRpb25WYWx1ZT09YW5PcHRpb24uZGF0YShcIm9wdGlvblZhbHVlXCIpKXtcclxuICAgICAgICAgICAgcmV0dXJuIHtcInRleHRcIjphbk9wdGlvbi50ZXh0KCksXCJ2YWx1ZVwiOmFuT3B0aW9uLmRhdGEoXCJvcHRpb25WYWx1ZVwiKSxcImNvbG9yQ2xhc3NcIjphbk9wdGlvbi5kYXRhKFwib3B0aW9uQ29sb3JDbGFzc1wiKX1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbnNpbXBsZVNlbGVjdE1lbnUucHJvdG90eXBlLmZpbmRPcHRpb25CeVRleHQ9ZnVuY3Rpb24ob3B0aW9uVGV4dCl7XHJcbiAgICB2YXIgb3B0aW9ucz10aGlzLm9wdGlvbkNvbnRlbnRET00uY2hpbGRyZW4oKVxyXG4gICAgZm9yKHZhciBpPTA7aTxvcHRpb25zLmxlbmd0aDtpKyspe1xyXG4gICAgICAgIHZhciBhbk9wdGlvbj0kKG9wdGlvbnNbaV0pXHJcbiAgICAgICAgaWYob3B0aW9uVGV4dD09YW5PcHRpb24udGV4dCgpKXtcclxuICAgICAgICAgICAgcmV0dXJuIHtcInRleHRcIjphbk9wdGlvbi50ZXh0KCksXCJ2YWx1ZVwiOmFuT3B0aW9uLmRhdGEoXCJvcHRpb25WYWx1ZVwiKSxcImNvbG9yQ2xhc3NcIjphbk9wdGlvbi5kYXRhKFwib3B0aW9uQ29sb3JDbGFzc1wiKX1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbnNpbXBsZVNlbGVjdE1lbnUucHJvdG90eXBlLmFkZE9wdGlvbkFycj1mdW5jdGlvbihhcnIpe1xyXG4gICAgYXJyLmZvckVhY2goZWxlbWVudCA9PiB7XHJcbiAgICAgICAgdGhpcy5hZGRPcHRpb24oZWxlbWVudClcclxuICAgIH0pO1xyXG59XHJcblxyXG5zaW1wbGVTZWxlY3RNZW51LnByb3RvdHlwZS5hZGRPcHRpb249ZnVuY3Rpb24ob3B0aW9uVGV4dCxvcHRpb25WYWx1ZSxjb2xvckNsYXNzKXtcclxuICAgIHZhciBvcHRpb25JdGVtPSQoJzxhIGhyZWY9XCIjXCIgY2xhc3M9XCJ3My1iYXItaXRlbSB3My1idXR0b25cIiBzdHlsZT1cIndoaXRlLXNwYWNlOm5vd3JhcFwiPicrb3B0aW9uVGV4dCsnPC9hPicpXHJcbiAgICBpZihjb2xvckNsYXNzKSBvcHRpb25JdGVtLmFkZENsYXNzKGNvbG9yQ2xhc3MpXHJcbiAgICB0aGlzLm9wdGlvbkNvbnRlbnRET00uYXBwZW5kKG9wdGlvbkl0ZW0pXHJcbiAgICBvcHRpb25JdGVtLmRhdGEoXCJvcHRpb25WYWx1ZVwiLG9wdGlvblZhbHVlfHxvcHRpb25UZXh0KVxyXG4gICAgb3B0aW9uSXRlbS5kYXRhKFwib3B0aW9uQ29sb3JDbGFzc1wiLGNvbG9yQ2xhc3MpXHJcbiAgICBvcHRpb25JdGVtLm9uKCdjbGljaycsKGUpPT57XHJcbiAgICAgICAgdGhpcy5jdXJTZWxlY3RWYWw9b3B0aW9uSXRlbS5kYXRhKFwib3B0aW9uVmFsdWVcIilcclxuICAgICAgICBpZih0aGlzLmlzQ2xpY2thYmxlKXtcclxuICAgICAgICAgICAgdGhpcy5vcHRpb25Db250ZW50RE9NLnJlbW92ZUNsYXNzKFwidzMtc2hvd1wiKVxyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICB0aGlzLkRPTS5yZW1vdmVDbGFzcygndzMtZHJvcGRvd24taG92ZXInKVxyXG4gICAgICAgICAgICB0aGlzLkRPTS5hZGRDbGFzcygndzMtZHJvcGRvd24tY2xpY2snKVxyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsgLy90aGlzIGlzIHRvIGhpZGUgdGhlIGRyb3AgZG93biBtZW51IGFmdGVyIGNsaWNrXHJcbiAgICAgICAgICAgICAgICB0aGlzLkRPTS5hZGRDbGFzcygndzMtZHJvcGRvd24taG92ZXInKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5ET00ucmVtb3ZlQ2xhc3MoJ3czLWRyb3Bkb3duLWNsaWNrJylcclxuICAgICAgICAgICAgfSwgMTAwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jYWxsQmFja19jbGlja09wdGlvbihvcHRpb25UZXh0LG9wdGlvbkl0ZW0uZGF0YShcIm9wdGlvblZhbHVlXCIpLFwicmVhbE1vdXNlQ2xpY2tcIixvcHRpb25JdGVtLmRhdGEoXCJvcHRpb25Db2xvckNsYXNzXCIpKVxyXG4gICAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgfSlcclxufVxyXG5cclxuc2ltcGxlU2VsZWN0TWVudS5wcm90b3R5cGUuY2hhbmdlTmFtZT1mdW5jdGlvbihuYW1lU3RyMSxuYW1lU3RyMil7XHJcbiAgICB0aGlzLmJ1dHRvbi5jaGlsZHJlbihcIjpmaXJzdFwiKS50ZXh0KG5hbWVTdHIxKVxyXG4gICAgdGhpcy5idXR0b24uY2hpbGRyZW4oKS5lcSgxKS50ZXh0KG5hbWVTdHIyKVxyXG59XHJcblxyXG5zaW1wbGVTZWxlY3RNZW51LnByb3RvdHlwZS50cmlnZ2VyT3B0aW9uSW5kZXg9ZnVuY3Rpb24ob3B0aW9uSW5kZXgpe1xyXG4gICAgdmFyIHRoZU9wdGlvbj10aGlzLm9wdGlvbkNvbnRlbnRET00uY2hpbGRyZW4oKS5lcShvcHRpb25JbmRleClcclxuICAgIGlmKHRoZU9wdGlvbi5sZW5ndGg9PTApIHtcclxuICAgICAgICB0aGlzLmN1clNlbGVjdFZhbD1udWxsO1xyXG4gICAgICAgIHRoaXMuY2FsbEJhY2tfY2xpY2tPcHRpb24obnVsbCxudWxsKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHRoaXMuY3VyU2VsZWN0VmFsPXRoZU9wdGlvbi5kYXRhKFwib3B0aW9uVmFsdWVcIilcclxuICAgIHRoaXMuY2FsbEJhY2tfY2xpY2tPcHRpb24odGhlT3B0aW9uLnRleHQoKSx0aGVPcHRpb24uZGF0YShcIm9wdGlvblZhbHVlXCIpLG51bGwsdGhlT3B0aW9uLmRhdGEoXCJvcHRpb25Db2xvckNsYXNzXCIpKVxyXG59XHJcblxyXG5zaW1wbGVTZWxlY3RNZW51LnByb3RvdHlwZS50cmlnZ2VyT3B0aW9uVmFsdWU9ZnVuY3Rpb24ob3B0aW9uVmFsdWUpe1xyXG4gICAgdmFyIHJlPXRoaXMuZmluZE9wdGlvbihvcHRpb25WYWx1ZSlcclxuICAgIGlmKHJlPT1udWxsKXtcclxuICAgICAgICB0aGlzLmN1clNlbGVjdFZhbD1udWxsXHJcbiAgICAgICAgdGhpcy5jYWxsQmFja19jbGlja09wdGlvbihudWxsLG51bGwpXHJcbiAgICB9ZWxzZXtcclxuICAgICAgICB0aGlzLmN1clNlbGVjdFZhbD1yZS52YWx1ZVxyXG4gICAgICAgIHRoaXMuY2FsbEJhY2tfY2xpY2tPcHRpb24ocmUudGV4dCxyZS52YWx1ZSxudWxsLHJlLmNvbG9yQ2xhc3MpXHJcbiAgICB9XHJcbn1cclxuXHJcbnNpbXBsZVNlbGVjdE1lbnUucHJvdG90eXBlLnRyaWdnZXJPcHRpb25UZXh0PWZ1bmN0aW9uKG9wdGlvblRleHQpe1xyXG4gICAgdmFyIHJlPXRoaXMuZmluZE9wdGlvbkJ5VGV4dChvcHRpb25UZXh0KVxyXG4gICAgaWYocmU9PW51bGwpe1xyXG4gICAgICAgIHRoaXMuY3VyU2VsZWN0VmFsPW51bGxcclxuICAgICAgICB0aGlzLmNhbGxCYWNrX2NsaWNrT3B0aW9uKG51bGwsbnVsbClcclxuICAgIH1lbHNle1xyXG4gICAgICAgIHRoaXMuY3VyU2VsZWN0VmFsPXJlLnZhbHVlXHJcbiAgICAgICAgdGhpcy5jYWxsQmFja19jbGlja09wdGlvbihyZS50ZXh0LHJlLnZhbHVlLG51bGwscmUuY29sb3JDbGFzcylcclxuICAgIH1cclxufVxyXG5cclxuXHJcbnNpbXBsZVNlbGVjdE1lbnUucHJvdG90eXBlLmNsZWFyT3B0aW9ucz1mdW5jdGlvbihvcHRpb25UZXh0LG9wdGlvblZhbHVlKXtcclxuICAgIHRoaXMub3B0aW9uQ29udGVudERPTS5lbXB0eSgpXHJcbiAgICB0aGlzLmN1clNlbGVjdFZhbD1udWxsO1xyXG59XHJcblxyXG5zaW1wbGVTZWxlY3RNZW51LnByb3RvdHlwZS5jYWxsQmFja19jbGlja09wdGlvbj1mdW5jdGlvbihvcHRpb250ZXh0LG9wdGlvblZhbHVlLHJlYWxNb3VzZUNsaWNrKXtcclxufVxyXG5cclxuc2ltcGxlU2VsZWN0TWVudS5wcm90b3R5cGUuY2FsbEJhY2tfYmVmb3JlQ2xpY2tFeHBhbmQ9ZnVuY3Rpb24ob3B0aW9udGV4dCxvcHRpb25WYWx1ZSxyZWFsTW91c2VDbGljayl7XHJcbn1cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHNpbXBsZVNlbGVjdE1lbnU7IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuZnVuY3Rpb24gc2ltcGxlVHJlZShET00sb3B0aW9ucyl7XHJcbiAgICB0aGlzLkRPTT1ET01cclxuICAgIHRoaXMuZ3JvdXBOb2Rlcz1bXSAvL2VhY2ggZ3JvdXAgaGVhZGVyIGlzIG9uZSBub2RlXHJcbiAgICB0aGlzLnNlbGVjdGVkTm9kZXM9W107XHJcbiAgICB0aGlzLm9wdGlvbnM9b3B0aW9ucyB8fCB7fVxyXG5cclxuICAgIHRoaXMubGFzdENsaWNrZWROb2RlPW51bGw7XHJcbn1cclxuXHJcbnNpbXBsZVRyZWUucHJvdG90eXBlLnNjcm9sbFRvTGVhZk5vZGU9ZnVuY3Rpb24oYU5vZGUpe1xyXG4gICAgdmFyIHNjcm9sbFRvcD10aGlzLkRPTS5zY3JvbGxUb3AoKVxyXG4gICAgdmFyIHRyZWVIZWlnaHQ9dGhpcy5ET00uaGVpZ2h0KClcclxuICAgIHZhciBub2RlUG9zaXRpb249YU5vZGUuRE9NLnBvc2l0aW9uKCkudG9wIC8vd2hpY2ggZG9lcyBub3QgY29uc2lkZXIgcGFyZW50IERPTSdzIHNjcm9sbCBoZWlnaHRcclxuICAgIC8vY29uc29sZS5sb2coc2Nyb2xsVG9wLHRyZWVIZWlnaHQsbm9kZVBvc2l0aW9uKVxyXG4gICAgaWYodHJlZUhlaWdodC01MDxub2RlUG9zaXRpb24pe1xyXG4gICAgICAgIHRoaXMuRE9NLnNjcm9sbFRvcChzY3JvbGxUb3AgKyBub2RlUG9zaXRpb24tKHRyZWVIZWlnaHQtNTApKSBcclxuICAgIH1lbHNlIGlmKG5vZGVQb3NpdGlvbjw1MCl7XHJcbiAgICAgICAgdGhpcy5ET00uc2Nyb2xsVG9wKHNjcm9sbFRvcCArIChub2RlUG9zaXRpb24tNTApKSBcclxuICAgIH1cclxufVxyXG5cclxuc2ltcGxlVHJlZS5wcm90b3R5cGUuY2xlYXJBbGxMZWFmTm9kZXM9ZnVuY3Rpb24oKXtcclxuICAgIHRoaXMubGFzdENsaWNrZWROb2RlPW51bGxcclxuICAgIHRoaXMuZ3JvdXBOb2Rlcy5mb3JFYWNoKChnTm9kZSk9PntcclxuICAgICAgICBnTm9kZS5saXN0RE9NLmVtcHR5KClcclxuICAgICAgICBnTm9kZS5jaGlsZExlYWZOb2Rlcy5sZW5ndGg9MFxyXG4gICAgICAgIGdOb2RlLnJlZnJlc2hOYW1lKClcclxuICAgIH0pXHJcbn1cclxuXHJcbnNpbXBsZVRyZWUucHJvdG90eXBlLmZpcnN0TGVhZk5vZGU9ZnVuY3Rpb24oKXtcclxuICAgIGlmKHRoaXMuZ3JvdXBOb2Rlcy5sZW5ndGg9PTApIHJldHVybiBudWxsO1xyXG4gICAgdmFyIGZpcnN0TGVhZk5vZGU9bnVsbDtcclxuICAgIHRoaXMuZ3JvdXBOb2Rlcy5mb3JFYWNoKGFHcm91cE5vZGU9PntcclxuICAgICAgICBpZihmaXJzdExlYWZOb2RlIT1udWxsKSByZXR1cm47XHJcbiAgICAgICAgaWYoYUdyb3VwTm9kZS5jaGlsZExlYWZOb2Rlcy5sZW5ndGg+MCkgZmlyc3RMZWFmTm9kZT1hR3JvdXBOb2RlLmNoaWxkTGVhZk5vZGVzWzBdXHJcbiAgICB9KVxyXG5cclxuICAgIHJldHVybiBmaXJzdExlYWZOb2RlXHJcbn1cclxuXHJcbnNpbXBsZVRyZWUucHJvdG90eXBlLm5leHRHcm91cE5vZGU9ZnVuY3Rpb24oYUdyb3VwTm9kZSl7XHJcbiAgICBpZihhR3JvdXBOb2RlPT1udWxsKSByZXR1cm47XHJcbiAgICB2YXIgaW5kZXg9dGhpcy5ncm91cE5vZGVzLmluZGV4T2YoYUdyb3VwTm9kZSlcclxuICAgIGlmKHRoaXMuZ3JvdXBOb2Rlcy5sZW5ndGgtMT5pbmRleCl7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JvdXBOb2Rlc1tpbmRleCsxXVxyXG4gICAgfWVsc2V7IC8vcm90YXRlIGJhY2t3YXJkIHRvIGZpcnN0IGdyb3VwIG5vZGVcclxuICAgICAgICByZXR1cm4gdGhpcy5ncm91cE5vZGVzWzBdIFxyXG4gICAgfVxyXG59XHJcblxyXG5zaW1wbGVUcmVlLnByb3RvdHlwZS5uZXh0TGVhZk5vZGU9ZnVuY3Rpb24oYUxlYWZOb2RlKXtcclxuICAgIGlmKGFMZWFmTm9kZT09bnVsbCkgcmV0dXJuO1xyXG4gICAgdmFyIGFHcm91cE5vZGU9YUxlYWZOb2RlLnBhcmVudEdyb3VwTm9kZVxyXG4gICAgdmFyIGluZGV4PWFHcm91cE5vZGUuY2hpbGRMZWFmTm9kZXMuaW5kZXhPZihhTGVhZk5vZGUpXHJcbiAgICBpZihhR3JvdXBOb2RlLmNoaWxkTGVhZk5vZGVzLmxlbmd0aC0xPmluZGV4KXtcclxuICAgICAgICAvL25leHQgbm9kZSBpcyBpbiBzYW1lIGdyb3VwXHJcbiAgICAgICAgcmV0dXJuIGFHcm91cE5vZGUuY2hpbGRMZWFmTm9kZXNbaW5kZXgrMV1cclxuICAgIH1lbHNle1xyXG4gICAgICAgIC8vZmluZCBuZXh0IGdyb3VwIGZpcnN0IG5vZGVcclxuICAgICAgICB3aGlsZSh0cnVlKXtcclxuICAgICAgICAgICAgdmFyIG5leHRHcm91cE5vZGUgPSB0aGlzLm5leHRHcm91cE5vZGUoYUdyb3VwTm9kZSlcclxuICAgICAgICAgICAgaWYobmV4dEdyb3VwTm9kZS5jaGlsZExlYWZOb2Rlcy5sZW5ndGg9PTApe1xyXG4gICAgICAgICAgICAgICAgYUdyb3VwTm9kZT1uZXh0R3JvdXBOb2RlXHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHRHcm91cE5vZGUuY2hpbGRMZWFmTm9kZXNbMF1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuc2ltcGxlVHJlZS5wcm90b3R5cGUuc2VhcmNoVGV4dD1mdW5jdGlvbihzdHIpe1xyXG4gICAgaWYoc3RyPT1cIlwiKSByZXR1cm4gbnVsbDtcclxuICAgIC8vc2VhcmNoIGZyb20gY3VycmVudCBzZWxlY3QgaXRlbSB0aGUgbmV4dCBsZWFmIGl0ZW0gY29udGFpbnMgdGhlIHRleHRcclxuICAgIHZhciByZWdleCA9IG5ldyBSZWdFeHAoc3RyLCAnaScpO1xyXG4gICAgdmFyIHN0YXJ0Tm9kZVxyXG4gICAgaWYodGhpcy5zZWxlY3RlZE5vZGVzLmxlbmd0aD09MCkge1xyXG4gICAgICAgIHN0YXJ0Tm9kZT10aGlzLmZpcnN0TGVhZk5vZGUoKVxyXG4gICAgICAgIGlmKHN0YXJ0Tm9kZT09bnVsbCkgcmV0dXJuO1xyXG4gICAgICAgIHZhciB0aGVTdHI9c3RhcnROb2RlLm5hbWU7XHJcbiAgICAgICAgaWYodGhlU3RyLm1hdGNoKHJlZ2V4KSE9bnVsbCl7XHJcbiAgICAgICAgICAgIC8vZmluZCB0YXJnZXQgbm9kZSBcclxuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0Tm9kZVxyXG4gICAgICAgIH1cclxuICAgIH1lbHNlIHN0YXJ0Tm9kZT10aGlzLnNlbGVjdGVkTm9kZXNbMF1cclxuXHJcbiAgICBpZihzdGFydE5vZGU9PW51bGwpIHJldHVybiBudWxsO1xyXG4gICAgXHJcbiAgICB2YXIgZnJvbU5vZGU9c3RhcnROb2RlO1xyXG4gICAgd2hpbGUodHJ1ZSl7XHJcbiAgICAgICAgdmFyIG5leHROb2RlPXRoaXMubmV4dExlYWZOb2RlKGZyb21Ob2RlKVxyXG4gICAgICAgIGlmKG5leHROb2RlPT1zdGFydE5vZGUpIHJldHVybiBudWxsO1xyXG4gICAgICAgIHZhciBuZXh0Tm9kZVN0cj1uZXh0Tm9kZS5uYW1lO1xyXG4gICAgICAgIGlmKG5leHROb2RlU3RyLm1hdGNoKHJlZ2V4KSE9bnVsbCl7XHJcbiAgICAgICAgICAgIC8vZmluZCB0YXJnZXQgbm9kZVxyXG4gICAgICAgICAgICByZXR1cm4gbmV4dE5vZGVcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgZnJvbU5vZGU9bmV4dE5vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgfSAgICBcclxufVxyXG5cclxuc2ltcGxlVHJlZS5wcm90b3R5cGUuZ2V0QWxsTGVhZk5vZGVBcnI9ZnVuY3Rpb24oKXtcclxuICAgIHZhciBhbGxMZWFmPVtdXHJcbiAgICB0aGlzLmdyb3VwTm9kZXMuZm9yRWFjaChnbj0+e1xyXG4gICAgICAgIGFsbExlYWY9YWxsTGVhZi5jb25jYXQoZ24uY2hpbGRMZWFmTm9kZXMpXHJcbiAgICB9KVxyXG4gICAgcmV0dXJuIGFsbExlYWY7XHJcbn1cclxuXHJcblxyXG5zaW1wbGVUcmVlLnByb3RvdHlwZS5hZGRMZWFmbm9kZVRvR3JvdXA9ZnVuY3Rpb24oZ3JvdXBOYW1lLG9iaixza2lwUmVwZWF0KXtcclxuICAgIHZhciBhR3JvdXBOb2RlPXRoaXMuZmluZEdyb3VwTm9kZShncm91cE5hbWUpXHJcbiAgICBpZihhR3JvdXBOb2RlID09IG51bGwpIHJldHVybjtcclxuICAgIGFHcm91cE5vZGUuYWRkTm9kZShvYmosc2tpcFJlcGVhdClcclxufVxyXG5cclxuc2ltcGxlVHJlZS5wcm90b3R5cGUucmVtb3ZlQWxsTm9kZXM9ZnVuY3Rpb24oKXtcclxuICAgIHRoaXMubGFzdENsaWNrZWROb2RlPW51bGxcclxuICAgIHRoaXMuZ3JvdXBOb2Rlcy5sZW5ndGg9MDtcclxuICAgIHRoaXMuc2VsZWN0ZWROb2Rlcy5sZW5ndGg9MDtcclxuICAgIHRoaXMuRE9NLmVtcHR5KClcclxufVxyXG5cclxuc2ltcGxlVHJlZS5wcm90b3R5cGUuZmluZEdyb3VwTm9kZT1mdW5jdGlvbihncm91cE5hbWUpe1xyXG4gICAgdmFyIGZvdW5kR3JvdXBOb2RlPW51bGxcclxuICAgIHRoaXMuZ3JvdXBOb2Rlcy5mb3JFYWNoKGFHcm91cE5vZGU9PntcclxuICAgICAgICBpZihhR3JvdXBOb2RlLm5hbWU9PWdyb3VwTmFtZSl7XHJcbiAgICAgICAgICAgIGZvdW5kR3JvdXBOb2RlPWFHcm91cE5vZGVcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgIH0pXHJcbiAgICByZXR1cm4gZm91bmRHcm91cE5vZGU7XHJcbn1cclxuXHJcbnNpbXBsZVRyZWUucHJvdG90eXBlLmRlbEdyb3VwTm9kZT1mdW5jdGlvbihnbm9kZSl7XHJcbiAgICB0aGlzLmxhc3RDbGlja2VkTm9kZT1udWxsXHJcbiAgICBnbm9kZS5kZWxldGVTZWxmKClcclxufVxyXG5cclxuc2ltcGxlVHJlZS5wcm90b3R5cGUuZGVsZXRlTGVhZk5vZGU9ZnVuY3Rpb24obm9kZU5hbWUpe1xyXG4gICAgdGhpcy5sYXN0Q2xpY2tlZE5vZGU9bnVsbFxyXG4gICAgdmFyIGZpbmRMZWFmTm9kZT1udWxsXHJcbiAgICB0aGlzLmdyb3VwTm9kZXMuZm9yRWFjaCgoZ05vZGUpPT57XHJcbiAgICAgICAgaWYoZmluZExlYWZOb2RlIT1udWxsKSByZXR1cm47XHJcbiAgICAgICAgZ05vZGUuY2hpbGRMZWFmTm9kZXMuZm9yRWFjaCgoYUxlYWYpPT57XHJcbiAgICAgICAgICAgIGlmKGFMZWFmLm5hbWU9PW5vZGVOYW1lKXtcclxuICAgICAgICAgICAgICAgIGZpbmRMZWFmTm9kZT1hTGVhZlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgIH0pXHJcbiAgICBpZihmaW5kTGVhZk5vZGU9PW51bGwpIHJldHVybjtcclxuICAgIGZpbmRMZWFmTm9kZS5kZWxldGVTZWxmKClcclxufVxyXG5cclxuXHJcbnNpbXBsZVRyZWUucHJvdG90eXBlLmluc2VydEdyb3VwTm9kZT1mdW5jdGlvbihvYmosaW5kZXgpe1xyXG4gICAgdmFyIGFOZXdHcm91cE5vZGUgPSBuZXcgc2ltcGxlVHJlZUdyb3VwTm9kZSh0aGlzLG9iailcclxuICAgIHZhciBleGlzdEdyb3VwTm9kZT0gdGhpcy5maW5kR3JvdXBOb2RlKGFOZXdHcm91cE5vZGUubmFtZSlcclxuICAgIGlmKGV4aXN0R3JvdXBOb2RlIT1udWxsKSByZXR1cm47XHJcbiAgICB0aGlzLmdyb3VwTm9kZXMuc3BsaWNlKGluZGV4LCAwLCBhTmV3R3JvdXBOb2RlKTtcclxuXHJcbiAgICBpZihpbmRleD09MCl7XHJcbiAgICAgICAgdGhpcy5ET00uYXBwZW5kKGFOZXdHcm91cE5vZGUuaGVhZGVyRE9NKVxyXG4gICAgICAgIHRoaXMuRE9NLmFwcGVuZChhTmV3R3JvdXBOb2RlLmxpc3RET00pXHJcbiAgICB9ZWxzZXtcclxuICAgICAgICB2YXIgcHJldkdyb3VwTm9kZT10aGlzLmdyb3VwTm9kZXNbaW5kZXgtMV1cclxuICAgICAgICBhTmV3R3JvdXBOb2RlLmhlYWRlckRPTS5pbnNlcnRBZnRlcihwcmV2R3JvdXBOb2RlLmxpc3RET00pXHJcbiAgICAgICAgYU5ld0dyb3VwTm9kZS5saXN0RE9NLmluc2VydEFmdGVyKGFOZXdHcm91cE5vZGUuaGVhZGVyRE9NKVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBhTmV3R3JvdXBOb2RlO1xyXG59XHJcblxyXG5zaW1wbGVUcmVlLnByb3RvdHlwZS5hZGRHcm91cE5vZGU9ZnVuY3Rpb24ob2JqKXtcclxuICAgIHZhciBhTmV3R3JvdXBOb2RlID0gbmV3IHNpbXBsZVRyZWVHcm91cE5vZGUodGhpcyxvYmopXHJcbiAgICB2YXIgZXhpc3RHcm91cE5vZGU9IHRoaXMuZmluZEdyb3VwTm9kZShhTmV3R3JvdXBOb2RlLm5hbWUpXHJcbiAgICBpZihleGlzdEdyb3VwTm9kZSE9bnVsbCkgcmV0dXJuIGV4aXN0R3JvdXBOb2RlO1xyXG4gICAgdGhpcy5ncm91cE5vZGVzLnB1c2goYU5ld0dyb3VwTm9kZSk7XHJcbiAgICB0aGlzLkRPTS5hcHBlbmQoYU5ld0dyb3VwTm9kZS5oZWFkZXJET00pXHJcbiAgICB0aGlzLkRPTS5hcHBlbmQoYU5ld0dyb3VwTm9kZS5saXN0RE9NKVxyXG4gICAgcmV0dXJuIGFOZXdHcm91cE5vZGU7XHJcbn1cclxuXHJcbnNpbXBsZVRyZWUucHJvdG90eXBlLnNlbGVjdExlYWZOb2RlPWZ1bmN0aW9uKGxlYWZOb2RlLG1vdXNlQ2xpY2tEZXRhaWwpe1xyXG4gICAgdGhpcy5zZWxlY3RMZWFmTm9kZUFycihbbGVhZk5vZGVdLG1vdXNlQ2xpY2tEZXRhaWwpXHJcbn1cclxuc2ltcGxlVHJlZS5wcm90b3R5cGUuYXBwZW5kTGVhZk5vZGVUb1NlbGVjdGlvbj1mdW5jdGlvbihsZWFmTm9kZSl7XHJcbiAgICB2YXIgbmV3QXJyPVtdLmNvbmNhdCh0aGlzLnNlbGVjdGVkTm9kZXMpXHJcbiAgICBuZXdBcnIucHVzaChsZWFmTm9kZSlcclxuICAgIHRoaXMuc2VsZWN0TGVhZk5vZGVBcnIobmV3QXJyKVxyXG59XHJcblxyXG5zaW1wbGVUcmVlLnByb3RvdHlwZS5hZGROb2RlQXJyYXlUb1NlbGVjdGlvbj1mdW5jdGlvbihhcnIpe1xyXG4gICAgdmFyIG5ld0FyciA9IHRoaXMuc2VsZWN0ZWROb2Rlc1xyXG4gICAgdmFyIGZpbHRlckFycj1hcnIuZmlsdGVyKChpdGVtKSA9PiBuZXdBcnIuaW5kZXhPZihpdGVtKSA8IDApXHJcbiAgICBuZXdBcnIgPSBuZXdBcnIuY29uY2F0KGZpbHRlckFycilcclxuICAgIHRoaXMuc2VsZWN0TGVhZk5vZGVBcnIobmV3QXJyKVxyXG59XHJcblxyXG5zaW1wbGVUcmVlLnByb3RvdHlwZS5zZWxlY3RHcm91cE5vZGU9ZnVuY3Rpb24oZ3JvdXBOb2RlKXtcclxuICAgIGlmKHRoaXMuY2FsbGJhY2tfYWZ0ZXJTZWxlY3RHcm91cE5vZGUpIHRoaXMuY2FsbGJhY2tfYWZ0ZXJTZWxlY3RHcm91cE5vZGUoZ3JvdXBOb2RlLmluZm8pXHJcbn1cclxuXHJcbnNpbXBsZVRyZWUucHJvdG90eXBlLnNlbGVjdExlYWZOb2RlQXJyPWZ1bmN0aW9uKGxlYWZOb2RlQXJyLG1vdXNlQ2xpY2tEZXRhaWwpe1xyXG4gICAgZm9yKHZhciBpPTA7aTx0aGlzLnNlbGVjdGVkTm9kZXMubGVuZ3RoO2krKyl7XHJcbiAgICAgICAgdGhpcy5zZWxlY3RlZE5vZGVzW2ldLmRpbSgpXHJcbiAgICB9XHJcbiAgICB0aGlzLnNlbGVjdGVkTm9kZXMubGVuZ3RoPTA7XHJcbiAgICB0aGlzLnNlbGVjdGVkTm9kZXM9dGhpcy5zZWxlY3RlZE5vZGVzLmNvbmNhdChsZWFmTm9kZUFycilcclxuICAgIGZvcih2YXIgaT0wO2k8dGhpcy5zZWxlY3RlZE5vZGVzLmxlbmd0aDtpKyspe1xyXG4gICAgICAgIHRoaXMuc2VsZWN0ZWROb2Rlc1tpXS5oaWdobGlnaHQoKVxyXG4gICAgfVxyXG5cclxuICAgIGlmKHRoaXMuY2FsbGJhY2tfYWZ0ZXJTZWxlY3ROb2RlcykgdGhpcy5jYWxsYmFja19hZnRlclNlbGVjdE5vZGVzKHRoaXMuc2VsZWN0ZWROb2Rlcyxtb3VzZUNsaWNrRGV0YWlsKVxyXG59XHJcblxyXG5zaW1wbGVUcmVlLnByb3RvdHlwZS5kYmxDbGlja05vZGU9ZnVuY3Rpb24odGhlTm9kZSl7XHJcbiAgICBpZih0aGlzLmNhbGxiYWNrX2FmdGVyRGJsY2xpY2tOb2RlKSB0aGlzLmNhbGxiYWNrX2FmdGVyRGJsY2xpY2tOb2RlKHRoZU5vZGUpXHJcbn1cclxuXHJcbnNpbXBsZVRyZWUucHJvdG90eXBlLnNvcnRBbGxMZWF2ZXM9ZnVuY3Rpb24oKXtcclxuICAgIHRoaXMuZ3JvdXBOb2Rlcy5mb3JFYWNoKG9uZUdyb3VwTm9kZT0+e29uZUdyb3VwTm9kZS5zb3J0Tm9kZXNCeU5hbWUoKX0pXHJcbn1cclxuXHJcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXRyZWUgZ3JvdXAgbm9kZS0tLS0tLS0tLS0tLS0tLVxyXG5mdW5jdGlvbiBzaW1wbGVUcmVlR3JvdXBOb2RlKHBhcmVudFRyZWUsb2JqKXtcclxuICAgIHRoaXMucGFyZW50VHJlZT1wYXJlbnRUcmVlXHJcbiAgICB0aGlzLmluZm89b2JqXHJcbiAgICB0aGlzLmNoaWxkTGVhZk5vZGVzPVtdIC8vaXQncyBjaGlsZCBsZWFmIG5vZGVzIGFycmF5XHJcbiAgICB0aGlzLm5hbWU9b2JqLmRpc3BsYXlOYW1lO1xyXG4gICAgdGhpcy5jcmVhdGVET00oKVxyXG59XHJcblxyXG5zaW1wbGVUcmVlR3JvdXBOb2RlLnByb3RvdHlwZS5yZWZyZXNoTmFtZT1mdW5jdGlvbigpe1xyXG4gICAgdGhpcy5oZWFkZXJET00uZW1wdHkoKVxyXG4gICAgdmFyIG5hbWVEaXY9JChcIjxkaXYgc3R5bGU9J2Rpc3BsYXk6aW5saW5lO3BhZGRpbmctbGVmdDo1cHg7cGFkZGluZy1yaWdodDozcHg7dmVydGljYWwtYWxpZ246bWlkZGxlJz48L2Rpdj5cIilcclxuICAgIG5hbWVEaXYudGV4dCh0aGlzLm5hbWUpXHJcbiAgICBcclxuICAgIGlmKHRoaXMuY2hpbGRMZWFmTm9kZXMubGVuZ3RoPjApIGxibENvbG9yPVwidzMtbGltZVwiXHJcbiAgICBlbHNlIHZhciBsYmxDb2xvcj1cInczLWdyYXlcIiBcclxuICAgIHRoaXMuaGVhZGVyRE9NLmNzcyhcImZvbnQtd2VpZ2h0XCIsXCJib2xkXCIpXHJcblxyXG4gICAgXHJcbiAgICBpZih0aGlzLnBhcmVudFRyZWUub3B0aW9ucy5ncm91cE5vZGVJY29uRnVuYyl7XHJcbiAgICAgICAgdmFyIGljb25MYWJlbD10aGlzLnBhcmVudFRyZWUub3B0aW9ucy5ncm91cE5vZGVJY29uRnVuYyh0aGlzKVxyXG4gICAgICAgIGlmKGljb25MYWJlbCl7XHJcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyRE9NLmFwcGVuZChpY29uTGFiZWwpXHJcbiAgICAgICAgICAgIHZhciByb3dIZWlnaHQ9aWNvbkxhYmVsLmhlaWdodCgpXHJcbiAgICAgICAgICAgIG5hbWVEaXYuY3NzKFwibGluZS1oZWlnaHRcIixyb3dIZWlnaHQrXCJweFwiKSAgICBcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHZhciBudW1iZXJsYWJlbD0kKFwiPGxhYmVsIGNsYXNzPSdcIitsYmxDb2xvcitcIicgc3R5bGU9J2Rpc3BsYXk6aW5saW5lO2ZvbnQtc2l6ZTo5cHg7cGFkZGluZzoycHggNHB4O2ZvbnQtd2VpZ2h0Om5vcm1hbDtib3JkZXItcmFkaXVzOiAycHg7Jz5cIit0aGlzLmNoaWxkTGVhZk5vZGVzLmxlbmd0aCtcIjwvbGFiZWw+XCIpXHJcbiAgICB0aGlzLmhlYWRlckRPTS5hcHBlbmQobmFtZURpdixudW1iZXJsYWJlbClcclxuXHJcblxyXG4gICAgaWYodGhpcy5wYXJlbnRUcmVlLm9wdGlvbnMuZ3JvdXBOb2RlVGFpbEJ1dHRvbkZ1bmMpe1xyXG4gICAgICAgIHZhciB0YWlsQnV0dG9uPXRoaXMucGFyZW50VHJlZS5vcHRpb25zLmdyb3VwTm9kZVRhaWxCdXR0b25GdW5jKHRoaXMpXHJcbiAgICAgICAgdGhpcy5oZWFkZXJET00uYXBwZW5kKHRhaWxCdXR0b24pXHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5jaGVja09wdGlvbkhpZGVFbXB0eUdyb3VwKClcclxuXHJcbn1cclxuc2ltcGxlVHJlZUdyb3VwTm9kZS5wcm90b3R5cGUuY2hlY2tPcHRpb25IaWRlRW1wdHlHcm91cD1mdW5jdGlvbigpe1xyXG4gICAgaWYgKHRoaXMucGFyZW50VHJlZS5vcHRpb25zLmhpZGVFbXB0eUdyb3VwICYmIHRoaXMuY2hpbGRMZWFmTm9kZXMubGVuZ3RoID09IDApIHtcclxuICAgICAgICB0aGlzLnNocmluaygpXHJcbiAgICAgICAgdGhpcy5oZWFkZXJET00uaGlkZSgpXHJcbiAgICAgICAgaWYgKHRoaXMubGlzdERPTSkgdGhpcy5saXN0RE9NLmhpZGUoKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmhlYWRlckRPTS5zaG93KClcclxuICAgICAgICBpZiAodGhpcy5saXN0RE9NKSB0aGlzLmxpc3RET00uc2hvdygpXHJcbiAgICB9XHJcblxyXG59XHJcbnNpbXBsZVRyZWVHcm91cE5vZGUucHJvdG90eXBlLmRlbGV0ZVNlbGYgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLmhlYWRlckRPTS5yZW1vdmUoKVxyXG4gICAgdGhpcy5saXN0RE9NLnJlbW92ZSgpXHJcbiAgICB2YXIgcGFyZW50QXJyID0gdGhpcy5wYXJlbnRUcmVlLmdyb3VwTm9kZXNcclxuICAgIGNvbnN0IGluZGV4ID0gcGFyZW50QXJyLmluZGV4T2YodGhpcyk7XHJcbiAgICBpZiAoaW5kZXggPiAtMSkgcGFyZW50QXJyLnNwbGljZShpbmRleCwgMSk7XHJcbn1cclxuXHJcbnNpbXBsZVRyZWVHcm91cE5vZGUucHJvdG90eXBlLmNyZWF0ZURPTT1mdW5jdGlvbigpe1xyXG4gICAgdGhpcy5oZWFkZXJET009JCgnPGJ1dHRvbiBjbGFzcz1cInczLWJ1dHRvbiB3My1ibG9jayB3My1saWdodC1ncmV5IHczLWxlZnQtYWxpZ24gdzMtYm9yZGVyLWJvdHRvbVwiIHN0eWxlPVwicG9zaXRpb246cmVsYXRpdmVcIj48L2J1dHRvbj4nKVxyXG4gICAgdGhpcy5yZWZyZXNoTmFtZSgpXHJcbiAgICB0aGlzLmxpc3RET009JCgnPGRpdiBjbGFzcz1cInczLWNvbnRhaW5lciB3My1oaWRlIHczLWJvcmRlclwiIHN0eWxlPVwicGFkZGluZzo4cHhcIj48L2Rpdj4nKVxyXG5cclxuICAgIHRoaXMuaGVhZGVyRE9NLm9uKFwiY2xpY2tcIiwoZXZ0KT0+IHtcclxuICAgICAgICBpZih0aGlzLmxpc3RET00uaGFzQ2xhc3MoXCJ3My1zaG93XCIpKSB0aGlzLmxpc3RET00ucmVtb3ZlQ2xhc3MoXCJ3My1zaG93XCIpXHJcbiAgICAgICAgZWxzZSB0aGlzLmxpc3RET00uYWRkQ2xhc3MoXCJ3My1zaG93XCIpXHJcblxyXG4gICAgICAgIHRoaXMucGFyZW50VHJlZS5zZWxlY3RHcm91cE5vZGUodGhpcykgICAgXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbnNpbXBsZVRyZWVHcm91cE5vZGUucHJvdG90eXBlLmlzT3Blbj1mdW5jdGlvbigpe1xyXG4gICAgcmV0dXJuICB0aGlzLmxpc3RET00uaGFzQ2xhc3MoXCJ3My1zaG93XCIpXHJcbn1cclxuXHJcblxyXG5zaW1wbGVUcmVlR3JvdXBOb2RlLnByb3RvdHlwZS5leHBhbmQ9ZnVuY3Rpb24oKXtcclxuICAgIGlmKHRoaXMubGlzdERPTSkgdGhpcy5saXN0RE9NLmFkZENsYXNzKFwidzMtc2hvd1wiKVxyXG59XHJcblxyXG5zaW1wbGVUcmVlR3JvdXBOb2RlLnByb3RvdHlwZS5zaHJpbms9ZnVuY3Rpb24oKXtcclxuICAgIGlmKHRoaXMubGlzdERPTSkgdGhpcy5saXN0RE9NLnJlbW92ZUNsYXNzKFwidzMtc2hvd1wiKVxyXG59XHJcblxyXG5zaW1wbGVUcmVlR3JvdXBOb2RlLnByb3RvdHlwZS5zb3J0Tm9kZXNCeU5hbWU9ZnVuY3Rpb24oKXtcclxuICAgIHZhciB0cmVlT3B0aW9ucz10aGlzLnBhcmVudFRyZWUub3B0aW9uc1xyXG4gICAgaWYodHJlZU9wdGlvbnMubGVhZk5hbWVQcm9wZXJ0eSkgdmFyIGxlYWZOYW1lUHJvcGVydHk9dHJlZU9wdGlvbnMubGVhZk5hbWVQcm9wZXJ0eVxyXG4gICAgZWxzZSBsZWFmTmFtZVByb3BlcnR5PVwiJGR0SWRcIlxyXG4gICAgdGhpcy5jaGlsZExlYWZOb2Rlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IFxyXG4gICAgICAgIHZhciBhTmFtZT1hLm5hbWUudG9Mb3dlckNhc2UoKVxyXG4gICAgICAgIHZhciBiTmFtZT1iLm5hbWUudG9Mb3dlckNhc2UoKVxyXG4gICAgICAgIHJldHVybiBhTmFtZS5sb2NhbGVDb21wYXJlKGJOYW1lKSBcclxuICAgIH0pO1xyXG4gICAgLy90aGlzLmxpc3RET00uZW1wdHkoKSAvL05PVEU6IENhbiBub3QgZGVsZXRlIHRob3NlIGxlYWYgbm9kZSBvdGhlcndpc2UgdGhlIGV2ZW50IGhhbmRsZSBpcyBsb3N0XHJcbiAgICB0aGlzLmNoaWxkTGVhZk5vZGVzLmZvckVhY2gob25lTGVhZj0+e3RoaXMubGlzdERPTS5hcHBlbmQob25lTGVhZi5ET00pfSlcclxufVxyXG5cclxuc2ltcGxlVHJlZUdyb3VwTm9kZS5wcm90b3R5cGUuYWRkTm9kZT1mdW5jdGlvbihvYmosc2tpcFJlcGVhdCl7XHJcbiAgICB2YXIgdHJlZU9wdGlvbnM9dGhpcy5wYXJlbnRUcmVlLm9wdGlvbnNcclxuICAgIGlmKHRyZWVPcHRpb25zLmxlYWZOYW1lUHJvcGVydHkpIHZhciBsZWFmTmFtZVByb3BlcnR5PXRyZWVPcHRpb25zLmxlYWZOYW1lUHJvcGVydHlcclxuICAgIGVsc2UgbGVhZk5hbWVQcm9wZXJ0eT1cIiRkdElkXCJcclxuXHJcbiAgICBpZihza2lwUmVwZWF0KXtcclxuICAgICAgICB2YXIgZm91bmRSZXBlYXQ9ZmFsc2U7XHJcbiAgICAgICAgdGhpcy5jaGlsZExlYWZOb2Rlcy5mb3JFYWNoKGFOb2RlPT57XHJcbiAgICAgICAgICAgIGlmKGFOb2RlLm5hbWU9PW9ialtsZWFmTmFtZVByb3BlcnR5XSkge1xyXG4gICAgICAgICAgICAgICAgZm91bmRSZXBlYXQ9dHJ1ZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICBpZihmb3VuZFJlcGVhdCkgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBhTmV3Tm9kZSA9IG5ldyBzaW1wbGVUcmVlTGVhZk5vZGUodGhpcyxvYmopXHJcbiAgICB0aGlzLmNoaWxkTGVhZk5vZGVzLnB1c2goYU5ld05vZGUpXHJcbiAgICB0aGlzLnJlZnJlc2hOYW1lKClcclxuICAgIHRoaXMubGlzdERPTS5hcHBlbmQoYU5ld05vZGUuRE9NKVxyXG59XHJcblxyXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS10cmVlIGxlYWYgbm9kZS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5mdW5jdGlvbiBzaW1wbGVUcmVlTGVhZk5vZGUocGFyZW50R3JvdXBOb2RlLG9iail7XHJcbiAgICB0aGlzLnBhcmVudEdyb3VwTm9kZT1wYXJlbnRHcm91cE5vZGVcclxuICAgIHRoaXMubGVhZkluZm89b2JqO1xyXG5cclxuICAgIHZhciB0cmVlT3B0aW9ucz10aGlzLnBhcmVudEdyb3VwTm9kZS5wYXJlbnRUcmVlLm9wdGlvbnNcclxuICAgIGlmKHRyZWVPcHRpb25zLmxlYWZOYW1lUHJvcGVydHkpIHRoaXMubmFtZT10aGlzLmxlYWZJbmZvW3RyZWVPcHRpb25zLmxlYWZOYW1lUHJvcGVydHldXHJcbiAgICBlbHNlIHRoaXMubmFtZT10aGlzLmxlYWZJbmZvW1wiJGR0SWRcIl1cclxuXHJcbiAgICB0aGlzLmNyZWF0ZUxlYWZOb2RlRE9NKClcclxufVxyXG5cclxuc2ltcGxlVHJlZUxlYWZOb2RlLnByb3RvdHlwZS5kZWxldGVTZWxmID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5ET00ucmVtb3ZlKClcclxuICAgIHZhciBnTm9kZSA9IHRoaXMucGFyZW50R3JvdXBOb2RlXHJcbiAgICBjb25zdCBpbmRleCA9IGdOb2RlLmNoaWxkTGVhZk5vZGVzLmluZGV4T2YodGhpcyk7XHJcbiAgICBpZiAoaW5kZXggPiAtMSkgZ05vZGUuY2hpbGRMZWFmTm9kZXMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgIGdOb2RlLnJlZnJlc2hOYW1lKClcclxufVxyXG5cclxuc2ltcGxlVHJlZUxlYWZOb2RlLnByb3RvdHlwZS5jbGlja1NlbGY9ZnVuY3Rpb24obW91c2VDbGlja0RldGFpbCl7XHJcbiAgICB0aGlzLnBhcmVudEdyb3VwTm9kZS5wYXJlbnRUcmVlLmxhc3RDbGlja2VkTm9kZT10aGlzO1xyXG4gICAgdGhpcy5wYXJlbnRHcm91cE5vZGUucGFyZW50VHJlZS5zZWxlY3RMZWFmTm9kZSh0aGlzLG1vdXNlQ2xpY2tEZXRhaWwpXHJcbn1cclxuXHJcbnNpbXBsZVRyZWVMZWFmTm9kZS5wcm90b3R5cGUuY3JlYXRlTGVhZk5vZGVET009ZnVuY3Rpb24oKXtcclxuICAgIHRoaXMuRE9NPSQoJzxidXR0b24gY2xhc3M9XCJ3My1idXR0b24gdzMtd2hpdGVcIiBzdHlsZT1cImRpc3BsYXk6YmxvY2s7dGV4dC1hbGlnbjpsZWZ0O3dpZHRoOjk4JVwiPjwvYnV0dG9uPicpXHJcbiAgICB0aGlzLnJlZHJhd0xhYmVsKClcclxuXHJcblxyXG4gICAgdmFyIGNsaWNrRj0oZSk9PntcclxuICAgICAgICB0aGlzLmhpZ2hsaWdodCgpO1xyXG4gICAgICAgIHZhciBjbGlja0RldGFpbD1lLmRldGFpbFxyXG4gICAgICAgIGlmIChlLmN0cmxLZXkpIHtcclxuICAgICAgICAgICAgaWYodGhpcy5wYXJlbnRHcm91cE5vZGUucGFyZW50VHJlZS5vcHRpb25zLm5vTXVsdGlwbGVTZWxlY3RBbGxvd2VkKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2xpY2tTZWxmKClcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnBhcmVudEdyb3VwTm9kZS5wYXJlbnRUcmVlLmFwcGVuZExlYWZOb2RlVG9TZWxlY3Rpb24odGhpcylcclxuICAgICAgICAgICAgdGhpcy5wYXJlbnRHcm91cE5vZGUucGFyZW50VHJlZS5sYXN0Q2xpY2tlZE5vZGU9dGhpcztcclxuICAgICAgICB9ZWxzZSBpZihlLnNoaWZ0S2V5KXtcclxuICAgICAgICAgICAgaWYodGhpcy5wYXJlbnRHcm91cE5vZGUucGFyZW50VHJlZS5vcHRpb25zLm5vTXVsdGlwbGVTZWxlY3RBbGxvd2VkKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2xpY2tTZWxmKClcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZih0aGlzLnBhcmVudEdyb3VwTm9kZS5wYXJlbnRUcmVlLmxhc3RDbGlja2VkTm9kZT09bnVsbCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNsaWNrU2VsZigpXHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgdmFyIGFsbExlYWZOb2RlQXJyPXRoaXMucGFyZW50R3JvdXBOb2RlLnBhcmVudFRyZWUuZ2V0QWxsTGVhZk5vZGVBcnIoKVxyXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4MSA9IGFsbExlYWZOb2RlQXJyLmluZGV4T2YodGhpcy5wYXJlbnRHcm91cE5vZGUucGFyZW50VHJlZS5sYXN0Q2xpY2tlZE5vZGUpXHJcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXgyID0gYWxsTGVhZk5vZGVBcnIuaW5kZXhPZih0aGlzKVxyXG4gICAgICAgICAgICAgICAgaWYoaW5kZXgxPT0tMSB8fCBpbmRleDI9PS0xKXtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsaWNrU2VsZigpXHJcbiAgICAgICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICAvL3NlbGVjdCBhbGwgbGVhZiBiZXR3ZWVuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxvd2VyST0gTWF0aC5taW4oaW5kZXgxLGluZGV4MilcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaGlnaGVyST0gTWF0aC5tYXgoaW5kZXgxLGluZGV4MilcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbWlkZGxlQXJyPWFsbExlYWZOb2RlQXJyLnNsaWNlKGxvd2VySSxoaWdoZXJJKSAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIG1pZGRsZUFyci5wdXNoKGFsbExlYWZOb2RlQXJyW2hpZ2hlckldKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50R3JvdXBOb2RlLnBhcmVudFRyZWUuYWRkTm9kZUFycmF5VG9TZWxlY3Rpb24obWlkZGxlQXJyKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIHRoaXMuY2xpY2tTZWxmKGNsaWNrRGV0YWlsKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHRoaXMuRE9NLm9uKFwiY2xpY2tcIiwoZSk9PntjbGlja0YoZSl9KVxyXG5cclxuICAgIHRoaXMuRE9NLm9uKFwiZGJsY2xpY2tcIiwoZSk9PntcclxuICAgICAgICB0aGlzLnBhcmVudEdyb3VwTm9kZS5wYXJlbnRUcmVlLmRibENsaWNrTm9kZSh0aGlzKVxyXG4gICAgfSlcclxufVxyXG5cclxuc2ltcGxlVHJlZUxlYWZOb2RlLnByb3RvdHlwZS5yZWRyYXdMYWJlbD1mdW5jdGlvbigpe1xyXG4gICAgdGhpcy5ET00uZW1wdHkoKVxyXG5cclxuICAgIHZhciBuYW1lRGl2PSQoXCI8bGFiZWwgc3R5bGU9J2Rpc3BsYXk6aW5saW5lO3BhZGRpbmctbGVmdDo1cHg7cGFkZGluZy1yaWdodDozcHg7dmVydGljYWwtYWxpZ246bWlkZGxlJz48L2xhYmVsPlwiKVxyXG4gICAgbmFtZURpdi50ZXh0KHRoaXMubmFtZSlcclxuXHJcbiAgICBpZih0aGlzLnBhcmVudEdyb3VwTm9kZS5wYXJlbnRUcmVlLm9wdGlvbnMubGVhZk5vZGVJY29uRnVuYyl7XHJcbiAgICAgICAgdmFyIGljb25MYWJlbD10aGlzLnBhcmVudEdyb3VwTm9kZS5wYXJlbnRUcmVlLm9wdGlvbnMubGVhZk5vZGVJY29uRnVuYyh0aGlzKVxyXG4gICAgICAgIHRoaXMuRE9NLmFwcGVuZChpY29uTGFiZWwpXHJcbiAgICAgICAgdmFyIHJvd0hlaWdodD1pY29uTGFiZWwuaGVpZ2h0KClcclxuICAgICAgICBuYW1lRGl2LmNzcyhcImxpbmUtaGVpZ2h0XCIscm93SGVpZ2h0K1wicHhcIilcclxuICAgIH1cclxuICAgIFxyXG4gICAgdGhpcy5ET00uYXBwZW5kKG5hbWVEaXYpXHJcbn1cclxuc2ltcGxlVHJlZUxlYWZOb2RlLnByb3RvdHlwZS5oaWdobGlnaHQ9ZnVuY3Rpb24oKXtcclxuICAgIHRoaXMuRE9NLmFkZENsYXNzKFwidzMtb3JhbmdlXCIpXHJcbiAgICB0aGlzLkRPTS5hZGRDbGFzcyhcInczLWhvdmVyLWFtYmVyXCIpXHJcbiAgICB0aGlzLkRPTS5yZW1vdmVDbGFzcyhcInczLXdoaXRlXCIpXHJcbn1cclxuc2ltcGxlVHJlZUxlYWZOb2RlLnByb3RvdHlwZS5kaW09ZnVuY3Rpb24oKXtcclxuICAgIHRoaXMuRE9NLnJlbW92ZUNsYXNzKFwidzMtb3JhbmdlXCIpXHJcbiAgICB0aGlzLkRPTS5yZW1vdmVDbGFzcyhcInczLWhvdmVyLWFtYmVyXCIpXHJcbiAgICB0aGlzLkRPTS5hZGRDbGFzcyhcInczLXdoaXRlXCIpXHJcbn1cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHNpbXBsZVRyZWU7Il19
